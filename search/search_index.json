{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u0130ndeks B\u00f6l\u00fcm 1 \u0130ndeks Ruby Hakk\u0131nda Kurulum \u0130nteraktif Kullan\u0131m Ruby Komutu ve Parametreleri * B\u00f6l\u00fcm 2 \u0130ndeks Syntax ( S\u00f6z Dizimi ) Comments ( Yorum sat\u0131r\u0131 ) Rezerve Edilmi\u015f Kelimeler De\u011fi\u015fken Tan\u0131mlama ve T\u00fcrleri Duck Typing \u00d6n Tan\u0131ml\u0131 De\u011fi\u015fkenler Pseudo De\u011fi\u015fkenler Operat\u00f6rler Global Constants ( Genel Sabitler ) B\u00f6l\u00fcm 3 \u0130ndeks Methods (Fonksiyonlar) Blocks (Bloklar) Proc ve Lambda Conditional Statements (Ko\u015fullar) B\u00f6l\u00fcm 4 \u0130ndeks Object Number String Array Hash Symbol Class Module B\u00f6l\u00fcm 5 \u0130ndeks Enumeration ve Iteration Ranges File System ve IO (Dosya Sistemi) Exception Handling * Kernel Mod\u00fcl\u00fc * B\u00f6l\u00fcm 6 \u0130ndeks Monkey Patching Regular Expressions * Time ve Date Nesneleri * Ruby Paketleri: RubyGems Paket Y\u00f6neticisi: Bundler * Komut Sat\u0131r\u0131 (Command-Line) Kullan\u0131m\u0131 * Meta Programming B\u00f6l\u00fcm 7 \u0130ndeks Kod Yazma Tarz\u0131 (Style Guide) B\u00f6l\u00fcm 8 \u0130ndeks Neden Ruby? Ruby ve TDD/BDD/CI * Kendi Rubygem'imizi yapal\u0131m! * Sinatra ve Web * * : Eksik b\u00f6l\u00fcmler...","title":"B\u00f6l\u00fcm \u0130ndeksi"},{"location":"#indeks","text":"","title":"\u0130ndeks"},{"location":"#bolum-1","text":"\u0130ndeks Ruby Hakk\u0131nda Kurulum \u0130nteraktif Kullan\u0131m Ruby Komutu ve Parametreleri *","title":"B\u00f6l\u00fcm 1"},{"location":"#bolum-2","text":"\u0130ndeks Syntax ( S\u00f6z Dizimi ) Comments ( Yorum sat\u0131r\u0131 ) Rezerve Edilmi\u015f Kelimeler De\u011fi\u015fken Tan\u0131mlama ve T\u00fcrleri Duck Typing \u00d6n Tan\u0131ml\u0131 De\u011fi\u015fkenler Pseudo De\u011fi\u015fkenler Operat\u00f6rler Global Constants ( Genel Sabitler )","title":"B\u00f6l\u00fcm 2"},{"location":"#bolum-3","text":"\u0130ndeks Methods (Fonksiyonlar) Blocks (Bloklar) Proc ve Lambda Conditional Statements (Ko\u015fullar)","title":"B\u00f6l\u00fcm 3"},{"location":"#bolum-4","text":"\u0130ndeks Object Number String Array Hash Symbol Class Module","title":"B\u00f6l\u00fcm 4"},{"location":"#bolum-5","text":"\u0130ndeks Enumeration ve Iteration Ranges File System ve IO (Dosya Sistemi) Exception Handling * Kernel Mod\u00fcl\u00fc *","title":"B\u00f6l\u00fcm 5"},{"location":"#bolum-6","text":"\u0130ndeks Monkey Patching Regular Expressions * Time ve Date Nesneleri * Ruby Paketleri: RubyGems Paket Y\u00f6neticisi: Bundler * Komut Sat\u0131r\u0131 (Command-Line) Kullan\u0131m\u0131 * Meta Programming","title":"B\u00f6l\u00fcm 6"},{"location":"#bolum-7","text":"\u0130ndeks Kod Yazma Tarz\u0131 (Style Guide)","title":"B\u00f6l\u00fcm 7"},{"location":"#bolum-8","text":"\u0130ndeks Neden Ruby? Ruby ve TDD/BDD/CI * Kendi Rubygem'imizi yapal\u0131m! * Sinatra ve Web * * : Eksik b\u00f6l\u00fcmler...","title":"B\u00f6l\u00fcm 8"},{"location":"acknowledgements/","text":"Te\u015fekk\u00fcrler @wip","title":"Te\u015fekk\u00fcrler"},{"location":"acknowledgements/#tesekkurler","text":"@wip","title":"Te\u015fekk\u00fcrler"},{"location":"cover/","text":"","title":"Kapak"},{"location":"preface/","text":"\u00d6ns\u00f6z Kitap yazmak hep hayalini kurdu\u011fum bir \u015feydi. Hem kendi i\u015fime yarayacak hem de ba\u015fkalar\u0131n\u0131n i\u015fini g\u00f6recek bir kitap olmal\u0131yd\u0131. Asl\u0131nda bir sene \u00f6nce bu i\u015fe soyundum ama bir t\u00fcrl\u00fc f\u0131rsat bulamad\u0131m. Kafamda kabaca planlar yapt\u0131m hep ama son noktay\u0131 bir t\u00fcrl\u00fc koyamad\u0131m. Gitbook.io bu konuda \u00e7ok i\u015fime yarad\u0131. Hem beni fi\u015fekledi hem de GitHub ile kolay entegre olmas\u0131 kendimi organize etmem a\u00e7\u0131s\u0131ndan \u00e7ok rahat oldu. Daha sonra Gitbook de\u011fi\u015fti ve benim kitaplar u\u00e7tu... \u00c7ok moralim bozuld ve kitaba devam edemedim. Repo benim kontrol\u00fcmde oldu\u011fu i\u00e7in uzun y\u0131llar uykuya dald\u0131... Hep O\u2019Reilly \u2019nin Pocket yani cep kitaplar\u0131na bay\u0131lm\u0131\u015f\u0131md\u0131r. Hem boyut itibariyle hem de i\u00e7erik anlam\u0131nda. S\u00fcrekli yan\u0131n\u0131zda ta\u015f\u0131yabilece\u011finiz, i\u00e7inde konusuyla ilgili her \u015feyin kompak bir \u015fekilde bulundu\u011fu kaynak. Amac\u0131m, bu kitaplar tad\u0131nda, her zaman yan\u0131n\u0131zda bulunabilecek, tabiri caizse ba\u015fucu kitab\u0131 haz\u0131rlamak. Kitab\u0131 haz\u0131rlarken en \u00e7ok zorland\u0131\u011f\u0131m k\u0131s\u0131m \u0130ngilizce\u2019den anlaml\u0131 T\u00fcrk\u00e7e metinler \u00e7\u0131kartmak oldu. Baz\u0131 \u015feyleri \u0130ngilizce olarak ifade etmek \u00e7ok kolay, fakat baz\u0131 durumlarda tam T\u00fcrk\u00e7e anlaml\u0131 kar\u015f\u0131l\u0131k bulmak ger\u00e7ekten zor oluyor. Prensip olarak Developer ( Yaz\u0131l\u0131m Geli\u015ftiren Ki\u015fi ) denen insan\u0131n default olarak \u0130ngilizce bilmesi gerekti\u011fine inan\u0131yorum. Neden? \u00d6rne\u011fin milyonlarca a\u00e7\u0131k-kaynak projenin bulundu\u011fu GitHub\u2019da herkes \u0130ngilizce konu\u015fuyor. Tak\u0131ld\u0131\u011f\u0131n\u0131z bir konuda, GitHub\u2019da yorumlar\u0131 okuman\u0131z gerekecek. Hatta bazen siz bir \u015fey soracaks\u0131n\u0131z. Issue \u2019lara bakacaks\u0131n\u0131z, Pull Request yapacaks\u0131n\u0131z. G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi bir c\u00fcmlede iki tane \u0130ngilizce terim. Bunlar evrensel. Bilmemiz gerekiyor yoksa \u00e7uvallar\u0131z :) \u00d6zellikle pek \u00e7ok \u015feyi oldu\u011fu gibi \u0130ngilizce olarak kullanmak istedim. Tabii ki T\u00fcrk\u00e7e anlam\u0131n\u0131 da yazd\u0131m fakat, genel olarak kulland\u0131\u011f\u0131m terminoloji Ruby ve yaz\u0131l\u0131m geli\u015ftirme terminolojisi. \u00d6rne\u011fin Constant dedi\u011fimde bunun ne anlama geldi\u011fini anlam\u0131\u015f olman\u0131z gerekiyor. Ya da Instance dedi\u011fimde, bunun s\u0131n\u0131ftan olu\u015fturulmu\u015f bir nesne oldu\u011funu anlaman\u0131z gerekiyor. Yaz\u0131l\u0131m d\u00fcnyas\u0131 ne yaz\u0131k ki \u0130ngilizce ve t\u00fcm kaynaklar da \u0130ngilizce. Bu bak\u0131mdan orijinal kelimeleri ve terminolojiyi \u00f6\u011frenmemiz, bilmemiz \u015fart :) Neticede ben yazar de\u011filim. Y\u00fcksek ihtimalle \u00e7ok say\u0131da imla ve yaz\u0131m hatas\u0131 yapaca\u011f\u0131m. Yard\u0131m edip hatalar\u0131 d\u00fczeltmeme yard\u0131mc\u0131 olursan\u0131z sevinirim.","title":"\u00d6ns\u00f6z"},{"location":"preface/#onsoz","text":"Kitap yazmak hep hayalini kurdu\u011fum bir \u015feydi. Hem kendi i\u015fime yarayacak hem de ba\u015fkalar\u0131n\u0131n i\u015fini g\u00f6recek bir kitap olmal\u0131yd\u0131. Asl\u0131nda bir sene \u00f6nce bu i\u015fe soyundum ama bir t\u00fcrl\u00fc f\u0131rsat bulamad\u0131m. Kafamda kabaca planlar yapt\u0131m hep ama son noktay\u0131 bir t\u00fcrl\u00fc koyamad\u0131m. Gitbook.io bu konuda \u00e7ok i\u015fime yarad\u0131. Hem beni fi\u015fekledi hem de GitHub ile kolay entegre olmas\u0131 kendimi organize etmem a\u00e7\u0131s\u0131ndan \u00e7ok rahat oldu. Daha sonra Gitbook de\u011fi\u015fti ve benim kitaplar u\u00e7tu... \u00c7ok moralim bozuld ve kitaba devam edemedim. Repo benim kontrol\u00fcmde oldu\u011fu i\u00e7in uzun y\u0131llar uykuya dald\u0131... Hep O\u2019Reilly \u2019nin Pocket yani cep kitaplar\u0131na bay\u0131lm\u0131\u015f\u0131md\u0131r. Hem boyut itibariyle hem de i\u00e7erik anlam\u0131nda. S\u00fcrekli yan\u0131n\u0131zda ta\u015f\u0131yabilece\u011finiz, i\u00e7inde konusuyla ilgili her \u015feyin kompak bir \u015fekilde bulundu\u011fu kaynak. Amac\u0131m, bu kitaplar tad\u0131nda, her zaman yan\u0131n\u0131zda bulunabilecek, tabiri caizse ba\u015fucu kitab\u0131 haz\u0131rlamak. Kitab\u0131 haz\u0131rlarken en \u00e7ok zorland\u0131\u011f\u0131m k\u0131s\u0131m \u0130ngilizce\u2019den anlaml\u0131 T\u00fcrk\u00e7e metinler \u00e7\u0131kartmak oldu. Baz\u0131 \u015feyleri \u0130ngilizce olarak ifade etmek \u00e7ok kolay, fakat baz\u0131 durumlarda tam T\u00fcrk\u00e7e anlaml\u0131 kar\u015f\u0131l\u0131k bulmak ger\u00e7ekten zor oluyor. Prensip olarak Developer ( Yaz\u0131l\u0131m Geli\u015ftiren Ki\u015fi ) denen insan\u0131n default olarak \u0130ngilizce bilmesi gerekti\u011fine inan\u0131yorum. Neden? \u00d6rne\u011fin milyonlarca a\u00e7\u0131k-kaynak projenin bulundu\u011fu GitHub\u2019da herkes \u0130ngilizce konu\u015fuyor. Tak\u0131ld\u0131\u011f\u0131n\u0131z bir konuda, GitHub\u2019da yorumlar\u0131 okuman\u0131z gerekecek. Hatta bazen siz bir \u015fey soracaks\u0131n\u0131z. Issue \u2019lara bakacaks\u0131n\u0131z, Pull Request yapacaks\u0131n\u0131z. G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi bir c\u00fcmlede iki tane \u0130ngilizce terim. Bunlar evrensel. Bilmemiz gerekiyor yoksa \u00e7uvallar\u0131z :) \u00d6zellikle pek \u00e7ok \u015feyi oldu\u011fu gibi \u0130ngilizce olarak kullanmak istedim. Tabii ki T\u00fcrk\u00e7e anlam\u0131n\u0131 da yazd\u0131m fakat, genel olarak kulland\u0131\u011f\u0131m terminoloji Ruby ve yaz\u0131l\u0131m geli\u015ftirme terminolojisi. \u00d6rne\u011fin Constant dedi\u011fimde bunun ne anlama geldi\u011fini anlam\u0131\u015f olman\u0131z gerekiyor. Ya da Instance dedi\u011fimde, bunun s\u0131n\u0131ftan olu\u015fturulmu\u015f bir nesne oldu\u011funu anlaman\u0131z gerekiyor. Yaz\u0131l\u0131m d\u00fcnyas\u0131 ne yaz\u0131k ki \u0130ngilizce ve t\u00fcm kaynaklar da \u0130ngilizce. Bu bak\u0131mdan orijinal kelimeleri ve terminolojiyi \u00f6\u011frenmemiz, bilmemiz \u015fart :) Neticede ben yazar de\u011filim. Y\u00fcksek ihtimalle \u00e7ok say\u0131da imla ve yaz\u0131m hatas\u0131 yapaca\u011f\u0131m. Yard\u0131m edip hatalar\u0131 d\u00fczeltmeme yard\u0131mc\u0131 olursan\u0131z sevinirim.","title":"\u00d6ns\u00f6z"},{"location":"technical-review/","text":"Teknik Ele\u015ftiri / \u0130nceleme @wip","title":"Teknik \u0130ncleme"},{"location":"technical-review/#teknik-elestiri-inceleme","text":"@wip","title":"Teknik Ele\u015ftiri / \u0130nceleme"},{"location":"bolum-01/","text":"B\u00f6l\u00fcm 1 Bu b\u00f6l\u00fcmde Ruby'nin k\u0131saca tarih\u00e7esine bakaca\u011f\u0131z. Buna ek olarak farkl\u0131 i\u015fletim sistemlerinde Ruby kurulumuna k\u0131saca de\u011finece\u011fiz. E\u011fer OSX ya da Linux t\u00fcrevi i\u015fletim sistemi kullan\u0131yorsan\u0131z i\u015finiz kolay :) Windows kullan\u0131c\u0131lar\u0131 i\u00e7in \u00f6zel bir Installer var. Bu b\u00f6l\u00fcmde son olarak da IRB ve komut sat\u0131r\u0131 \u00fczerinden Ruby \u00e7al\u0131\u015ft\u0131rmay\u0131 g\u00f6rece\u011fiz. Ruby Hakk\u0131nda Kurulum \u0130nteraktif Kullan\u0131m Ruby Komutu ve Parametreleri *","title":"\u0130ndeks"},{"location":"bolum-01/#bolum-1","text":"Bu b\u00f6l\u00fcmde Ruby'nin k\u0131saca tarih\u00e7esine bakaca\u011f\u0131z. Buna ek olarak farkl\u0131 i\u015fletim sistemlerinde Ruby kurulumuna k\u0131saca de\u011finece\u011fiz. E\u011fer OSX ya da Linux t\u00fcrevi i\u015fletim sistemi kullan\u0131yorsan\u0131z i\u015finiz kolay :) Windows kullan\u0131c\u0131lar\u0131 i\u00e7in \u00f6zel bir Installer var. Bu b\u00f6l\u00fcmde son olarak da IRB ve komut sat\u0131r\u0131 \u00fczerinden Ruby \u00e7al\u0131\u015ft\u0131rmay\u0131 g\u00f6rece\u011fiz. Ruby Hakk\u0131nda Kurulum \u0130nteraktif Kullan\u0131m Ruby Komutu ve Parametreleri *","title":"B\u00f6l\u00fcm 1"},{"location":"bolum-01/01-tarihce/","text":"Ruby Hakk\u0131nda 1990'l\u0131 y\u0131llar\u0131n ortalar\u0131nda (1995) Yukuhiro \"Matz\" Matsumoto taraf\u0131ndan geli\u015ftirilen Ruby, g\u00fcn\u00fcm\u00fczde en \u00e7ok kullan\u0131lan a\u00e7\u0131k-kaynak yaz\u0131l\u0131mlar\u0131n ba\u015f\u0131nda geliyor. \u00dcretkenlik (az kod, \u00e7ok i\u015f) ve basitli\u011fe odakl\u0131, dinamik, a\u00e7\u0131k-kaynak programlama dili. Okumas\u0131 ve yazmas\u0131 kolay, anla\u015f\u0131labilir nitelikte! Dilin en b\u00fcy\u00fck esin kaynaklar\u0131 tabii ki yine varolan diller. Bunlar; Perl, Smalltalk, Eiffel, Ada ve Lisp dilleri. \u0130lk kararl\u0131 (stable) s\u00fcr\u00fcm\u00fc 1995'de yay\u0131nlanan Ruby'nin geli\u015ftiricilerin tam anlam\u0131yla dikkatini \u00e7ekmesi 2006 y\u0131l\u0131na kadar s\u00fcrd\u00fc. Keza ilk versiyonlar\u0131 ger\u00e7ekten \u00e7ok yava\u015f ve s\u0131k\u0131nt\u0131l\u0131yd\u0131. Ruby en b\u00fcy\u00fck patlamas\u0131n\u0131 Ruby on Rails framework'\u00fc ile yapt\u0131. Danimarkal\u0131 yaz\u0131l\u0131mc\u0131 @dhh 'in ( David Heinemeier Hansson ) yay\u0131nlad\u0131\u011f\u0131 bu framework ne yaz\u0131k ki Ruby dilinin \u00f6n\u00fcne bile ge\u00e7ti. Kitab\u0131 yazd\u0131\u011f\u0131m an itibariyle ( 13 Temmuz 2014, Pazar ) Ruby'nin en son s\u00fcr\u00fcm\u00fc 2.1.2 (Stabil s\u00fcr\u00fcm) G\u00fcncelleme: Ruby versiyon 2.1.3 oldu. ( 26 Ekim 2014, Pazar ) G\u00fcncelleme: Ruby versiyon 2.1.5 oldu. ( 6 Aral\u0131k 2014, Pazar ) G\u00fcncelleme: Ruby versiyon 2.2.0 oldu. ( 25 Aral\u0131k 2014 ) G\u00fcncelleme: Ruby versiyon 2.2.1 oldu. ( 3 Mart 2015 ) G\u00fcncelleme: Ruby versiyon 2.2.2 oldu. ( 1 May\u0131s 2015 ) G\u00fcncelleme: Ruby versiyon 2.3.0 oldu. ( 24 Aral\u0131k 2015 ) G\u00fcncelleme: Ruby versiyon 2.3.1 oldu. Uzunca bir ara... G\u00fcncelleme: Ruby versiyon 3.0.2 oldu. ( 20 A\u011fustos 2021 ) Ruby'nin en \u00f6nemli \u00f6zelli\u011fi her \u015feyin bir nesne yani Object olmas\u0131d\u0131r. Nesneyi bir t\u00fcr paket \\/ kutu gibi d\u00fc\u015f\u00fcnebilirsiniz. Do\u011fal olarak, Object yani nesne olan bir \u015feyin, action'lar\u0131 \\/ method'lar\u0131 da olur. Ruby'nin yarat\u0131c\u0131s\u0131 Matz \u015f\u00f6yle demi\u015f: Perl dilinden daha g\u00fc\u00e7l\u00fc, Python dilinden daha object-oriented bir script dili olmas\u0131n\u0131 istedim. Pek \u00e7ok programlama dilinde say\u0131lar primitive (ilkel\\/basit) tiplerdir, nesne de\u011fildirler. Halbuki Ruby'de say\u0131lar dahil her \u015fey nesnedir. Yani say\u0131n\u0131n method'lar\u0131 vard\u0131r :) \u00d6rnek class Numeric def topla ( x ) self . + ( x ) end end 5 . topla ( 6 ) # => 11 5 . topla ( 16 ) # => 21 Say\u0131lara ( yani Numeric tipine ) topla diye bir method ekledik... Block ve Mixin ise Ruby'nin yine \u00f6ne \u00e7\u0131kan \u00f6zelliklerindendir. Block denen \u015fey asl\u0131nda closure 'dur. Herhangi bir method'a block tak\u0131labilir: search_engines = %w[Google Yahoo MSN] . map do | engine | \"http://www.\" + engine . downcase + \".com\" end search_engines # => [\"http://www.google.com\", \"http://www.yahoo.com\", \"http://www.msn.com\"] Bu \u00f6rnekte %w string'i bo\u015fluklar\u0131ndan ay\u0131rarak bir array (dizi) format\u0131na \u00e7eviri. Yani sonu\u00e7ta %w[Google Yahoo MSN] dedi\u011fimizde elimize [\"Google\",\"Yahoo\", \"MSN\"] dizisi gelir. map metodu bize bu diziden bir Enumarator d\u00f6necektir ve do/end k\u0131sm\u0131 ise bizim block k\u0131sm\u0131m\u0131zd\u0131r. Bu konuda daha a\u00e7\u0131klay\u0131c\u0131 bilgiyi 3. b\u00f6l\u00fcmdeki Bloklar ba\u015fl\u0131\u011f\u0131 alt\u0131nda bulacaks\u0131n\u0131z. Ruby'de bir Class (s\u0131n\u0131f) sadece tek bir s\u0131n\u0131ftan t\u00fcreyebilir. Yani A class'\u0131 B'den t\u00fcrer ama ayn\u0131 anda hem B'den hem C'den t\u00fcreyemez. Bu Python'da m\u00fcmk\u00fcn olan bir \u015feydir. Ruby'de ise bunun \u00fcstesinden gelmek i\u00e7in class'lar Module 'leri kullan\u0131r. Bir Class N tane Module i\u00e7erebilir, i\u015fte bu t\u00fcr nesnelere Mixin denir: class MyArray include Enumerable end Ortak kullan\u0131lacak metodlar\u0131 ya da de\u011fi\u015fkenleri ayr\u0131 bir Module olarak tasarlay\u0131p, gerekti\u011fi yerde include ederek Class + Module kar\u0131\u015f\u0131m\u0131ndan olu\u015fan Mixin'ler ortaya \u00e7\u0131kar. Di\u011fer dillerdeki gibi Exception Handling, Garbage Collector \u00f6zelliklerinin yan\u0131 s\u0131ra, C-Extension'\u0131 yazmak di\u011fer dillere g\u00f6re daha kolayd\u0131r. \u0130\u015fletim sisteminden ba\u011f\u0131ms\u0131z threading imkan\u0131 sunmaktad\u0131r. Pek \u00e7ok i\u015fletim sisteminde Ruby kullanmak m\u00fcmk\u00fcnd\u00fcr: Linux \\/ Unix \\/ Mac OS X \\/ Windows \\/ DOS \\/ BeOS \\/ OS\\/2 gibi... Ruby'den t\u00fcremi\u015f farkl\u0131 Ruby uygulamalar\u0131 da var: JRuby Rubinius MacRuby mruby IronRuby MagLev Cardinal Son olarak, Test Driven Development yani test'le y\u00fcr\u00fcyen geli\u015ftirme mantalitesinin en iyi oturdu\u011funu d\u00fc\u015f\u00fcnd\u00fc\u011f\u00fcm dillerden biri Ruby'dir. \u00c7ok g\u00fczel test k\u00fct\u00fcphaneleri var ve nas\u0131l kullanabilece\u011fimize dair tonlarca blog\\/video sitesi de mevcut! Ruby ile programlamak e\u011flencelidir! diyor Matz, haydi o halde biz de bu e\u011flenceye kat\u0131lal\u0131m :)","title":"Ruby Hakk\u0131nda"},{"location":"bolum-01/01-tarihce/#ruby-hakknda","text":"1990'l\u0131 y\u0131llar\u0131n ortalar\u0131nda (1995) Yukuhiro \"Matz\" Matsumoto taraf\u0131ndan geli\u015ftirilen Ruby, g\u00fcn\u00fcm\u00fczde en \u00e7ok kullan\u0131lan a\u00e7\u0131k-kaynak yaz\u0131l\u0131mlar\u0131n ba\u015f\u0131nda geliyor. \u00dcretkenlik (az kod, \u00e7ok i\u015f) ve basitli\u011fe odakl\u0131, dinamik, a\u00e7\u0131k-kaynak programlama dili. Okumas\u0131 ve yazmas\u0131 kolay, anla\u015f\u0131labilir nitelikte! Dilin en b\u00fcy\u00fck esin kaynaklar\u0131 tabii ki yine varolan diller. Bunlar; Perl, Smalltalk, Eiffel, Ada ve Lisp dilleri. \u0130lk kararl\u0131 (stable) s\u00fcr\u00fcm\u00fc 1995'de yay\u0131nlanan Ruby'nin geli\u015ftiricilerin tam anlam\u0131yla dikkatini \u00e7ekmesi 2006 y\u0131l\u0131na kadar s\u00fcrd\u00fc. Keza ilk versiyonlar\u0131 ger\u00e7ekten \u00e7ok yava\u015f ve s\u0131k\u0131nt\u0131l\u0131yd\u0131. Ruby en b\u00fcy\u00fck patlamas\u0131n\u0131 Ruby on Rails framework'\u00fc ile yapt\u0131. Danimarkal\u0131 yaz\u0131l\u0131mc\u0131 @dhh 'in ( David Heinemeier Hansson ) yay\u0131nlad\u0131\u011f\u0131 bu framework ne yaz\u0131k ki Ruby dilinin \u00f6n\u00fcne bile ge\u00e7ti. Kitab\u0131 yazd\u0131\u011f\u0131m an itibariyle ( 13 Temmuz 2014, Pazar ) Ruby'nin en son s\u00fcr\u00fcm\u00fc 2.1.2 (Stabil s\u00fcr\u00fcm) G\u00fcncelleme: Ruby versiyon 2.1.3 oldu. ( 26 Ekim 2014, Pazar ) G\u00fcncelleme: Ruby versiyon 2.1.5 oldu. ( 6 Aral\u0131k 2014, Pazar ) G\u00fcncelleme: Ruby versiyon 2.2.0 oldu. ( 25 Aral\u0131k 2014 ) G\u00fcncelleme: Ruby versiyon 2.2.1 oldu. ( 3 Mart 2015 ) G\u00fcncelleme: Ruby versiyon 2.2.2 oldu. ( 1 May\u0131s 2015 ) G\u00fcncelleme: Ruby versiyon 2.3.0 oldu. ( 24 Aral\u0131k 2015 ) G\u00fcncelleme: Ruby versiyon 2.3.1 oldu. Uzunca bir ara... G\u00fcncelleme: Ruby versiyon 3.0.2 oldu. ( 20 A\u011fustos 2021 ) Ruby'nin en \u00f6nemli \u00f6zelli\u011fi her \u015feyin bir nesne yani Object olmas\u0131d\u0131r. Nesneyi bir t\u00fcr paket \\/ kutu gibi d\u00fc\u015f\u00fcnebilirsiniz. Do\u011fal olarak, Object yani nesne olan bir \u015feyin, action'lar\u0131 \\/ method'lar\u0131 da olur. Ruby'nin yarat\u0131c\u0131s\u0131 Matz \u015f\u00f6yle demi\u015f: Perl dilinden daha g\u00fc\u00e7l\u00fc, Python dilinden daha object-oriented bir script dili olmas\u0131n\u0131 istedim. Pek \u00e7ok programlama dilinde say\u0131lar primitive (ilkel\\/basit) tiplerdir, nesne de\u011fildirler. Halbuki Ruby'de say\u0131lar dahil her \u015fey nesnedir. Yani say\u0131n\u0131n method'lar\u0131 vard\u0131r :) \u00d6rnek class Numeric def topla ( x ) self . + ( x ) end end 5 . topla ( 6 ) # => 11 5 . topla ( 16 ) # => 21 Say\u0131lara ( yani Numeric tipine ) topla diye bir method ekledik... Block ve Mixin ise Ruby'nin yine \u00f6ne \u00e7\u0131kan \u00f6zelliklerindendir. Block denen \u015fey asl\u0131nda closure 'dur. Herhangi bir method'a block tak\u0131labilir: search_engines = %w[Google Yahoo MSN] . map do | engine | \"http://www.\" + engine . downcase + \".com\" end search_engines # => [\"http://www.google.com\", \"http://www.yahoo.com\", \"http://www.msn.com\"] Bu \u00f6rnekte %w string'i bo\u015fluklar\u0131ndan ay\u0131rarak bir array (dizi) format\u0131na \u00e7eviri. Yani sonu\u00e7ta %w[Google Yahoo MSN] dedi\u011fimizde elimize [\"Google\",\"Yahoo\", \"MSN\"] dizisi gelir. map metodu bize bu diziden bir Enumarator d\u00f6necektir ve do/end k\u0131sm\u0131 ise bizim block k\u0131sm\u0131m\u0131zd\u0131r. Bu konuda daha a\u00e7\u0131klay\u0131c\u0131 bilgiyi 3. b\u00f6l\u00fcmdeki Bloklar ba\u015fl\u0131\u011f\u0131 alt\u0131nda bulacaks\u0131n\u0131z. Ruby'de bir Class (s\u0131n\u0131f) sadece tek bir s\u0131n\u0131ftan t\u00fcreyebilir. Yani A class'\u0131 B'den t\u00fcrer ama ayn\u0131 anda hem B'den hem C'den t\u00fcreyemez. Bu Python'da m\u00fcmk\u00fcn olan bir \u015feydir. Ruby'de ise bunun \u00fcstesinden gelmek i\u00e7in class'lar Module 'leri kullan\u0131r. Bir Class N tane Module i\u00e7erebilir, i\u015fte bu t\u00fcr nesnelere Mixin denir: class MyArray include Enumerable end Ortak kullan\u0131lacak metodlar\u0131 ya da de\u011fi\u015fkenleri ayr\u0131 bir Module olarak tasarlay\u0131p, gerekti\u011fi yerde include ederek Class + Module kar\u0131\u015f\u0131m\u0131ndan olu\u015fan Mixin'ler ortaya \u00e7\u0131kar. Di\u011fer dillerdeki gibi Exception Handling, Garbage Collector \u00f6zelliklerinin yan\u0131 s\u0131ra, C-Extension'\u0131 yazmak di\u011fer dillere g\u00f6re daha kolayd\u0131r. \u0130\u015fletim sisteminden ba\u011f\u0131ms\u0131z threading imkan\u0131 sunmaktad\u0131r. Pek \u00e7ok i\u015fletim sisteminde Ruby kullanmak m\u00fcmk\u00fcnd\u00fcr: Linux \\/ Unix \\/ Mac OS X \\/ Windows \\/ DOS \\/ BeOS \\/ OS\\/2 gibi... Ruby'den t\u00fcremi\u015f farkl\u0131 Ruby uygulamalar\u0131 da var: JRuby Rubinius MacRuby mruby IronRuby MagLev Cardinal Son olarak, Test Driven Development yani test'le y\u00fcr\u00fcyen geli\u015ftirme mantalitesinin en iyi oturdu\u011funu d\u00fc\u015f\u00fcnd\u00fc\u011f\u00fcm dillerden biri Ruby'dir. \u00c7ok g\u00fczel test k\u00fct\u00fcphaneleri var ve nas\u0131l kullanabilece\u011fimize dair tonlarca blog\\/video sitesi de mevcut! Ruby ile programlamak e\u011flencelidir! diyor Matz, haydi o halde biz de bu e\u011flenceye kat\u0131lal\u0131m :)","title":"Ruby Hakk\u0131nda"},{"location":"bolum-01/02-kurulum/","text":"Kurulum OSX E\u011fer Mac OSX kullan\u0131yorsan\u0131z ilk etapta hi\u00e7bir \u015feye ihtiyac\u0131n\u0131z yok, \u00e7\u00fcnk\u00fc Mac OSX'de Ruby haz\u0131r kurulu olarak geliyor. OSX Mavericks (10.9.4) Ruby s\u00fcr\u00fcm\u00fc: ruby 2.1.0p0 (2013-12-25 revision 44422) [x86_64-darwin13.0] macOS Catalina (10.5.7) Ruby s\u00fcr\u00fcm\u00fc: ruby 2.6.3p62 (2019-04-16 revision 67580) [universal.x86_64-darwin19] Linux Debian ve Ubuntu kullanan okuyucular\u0131m\u0131z $ sudo apt-get install ruby # ya da $ sudo aptitude install ruby CentOS Fedora ya da RedHat kullananlar: $ sudo yum install ruby Gentoo kullananlar; $ sudo emerge dev-lang/ruby Kaynaktan Kurulum Ruby'nin sitesinden tar dosyas\u0131n\u0131 indirip; $ ./configure $ make $ sudo make install \u015feklinde de kurulum yapabilirsiniz. Windows Bu siteden \u00f6zel Windows i\u00e7in haz\u0131rlanm\u0131\u015f Ruby kurulum paketini indirip klasik \"next\" > \"next\" diyerek kurulum yapabilirsiniz. Ruby Versiyon Y\u00f6neticileri Bazen, kulland\u0131\u011f\u0131n\u0131z haz\u0131r k\u00fct\u00fcphanelerin destekledikleri Ruby versiyonlar\u0131ndaki k\u0131s\u0131tlamalar ya da ki\u015fisel tercihiniz gibi, farkl\u0131 nedenlerle birden fazla Ruby s\u00fcr\u00fcm\u00fc ile \u00e7al\u0131\u015fmak isteyebilirsiniz. Projelerinizden biri, \u00f6rne\u011fin ruby 1.9.3 kullan\u0131rken, di\u011fer bir projeniz ruby 2.1.0 kullan\u0131yor olabilir. Bu anlarda kulland\u0131\u011f\u0131n\u0131z Ruby versiyonunu kolayca de\u011fi\u015ftirmek, asl\u0131nda aktive etmek de diyebiliriz, i\u00e7in 2 adet pop\u00fcler versiyon y\u00f6neticisi bulunmaktad\u0131r. Rbenv Rbenv me\u015fhur 37 Signals '\u0131n. Asl\u0131nda orada \u00e7al\u0131\u015fan Sam Stephenson taraf\u0131ndan geli\u015ftirilmi\u015f bir ara\u00e7. E\u011fer OSX ve Homebrew kullan\u0131yorsan\u0131z kurulum \u00e7ok kolay: $ brew install rbenv ruby-build E\u011fer farkl\u0131 bir i\u015fletim sistemi kullan\u0131yorsan\u0131z (Linux/Unix tabanl\u0131) $ git clone https://github.com/sstephenson/rbenv.git ~/.rbenv sonra PATH 'e ekleyin ( bash profile ya da ne kullan\u0131yorsan\u0131z ) export PATH = \" $HOME /.rbenv/bin: $PATH \" # a\u00e7\u0131l\u0131\u015fa bunuda ekleyin # hangisini kullan\u0131yorsan\u0131z (.bashrc, .profile ya da .bash_profile) eval \" $( rbenv init - ) \" Kurulumdan sonra istedi\u011fini Ruby versiyonu i\u00e7in; # kurulabilecek versiyonlar\u0131 g\u00f6ster $ rbenv install -l # ruby 2.3.0'\u0131 kural\u0131m $ rbenv install 2 .3.0 Kurulan Ruby'yi Sistem genelinde rbenv global Sadece bulundu\u011fumuz dizin i\u00e7inde (Uygulamaya \u00d6zel) rbenv local Anl\u0131k, sadece Shell'de rbenv shell aktive etme opsiyonlar\u0131m\u0131z var. \u00d6rne\u011fin proje dizinin i\u00e7ine .ruby-version dosyas\u0131 koyar ve i\u00e7ine de hangi versiyonu kulland\u0131\u011f\u0131m\u0131z\u0131 yazarsak o dizine ge\u00e7ti\u011fimiz an Ruby versiyonu de\u011fi\u015fir. Yani A projesinde versiyon 2.1.1 , B projesinde version 1.9.3 kullanmak i\u00e7in; $ cd ~/projelerim/A/ $ echo \"1.9.3\" > .ruby-version $ cd ~/projelerim/B/ $ echo \"2.1.1\" > .ruby-version # bakal\u0131m hangi versiyonu aktive etmi\u015fiz? $ rbenv version RVM Ad\u0131ndan da anla\u015f\u0131laca\u011f\u0131 gibi R uby V ersion M anager yani RVM de ayn\u0131 Rbenv gibi Ruby versiyonlar\u0131n\u0131 kolay y\u00f6netmeyi sa\u011fl\u0131yor. Ruby d\u00fcnyas\u0131ndan Rbenv'ciler ve RVM'ciler olarak iki kanat oldu\u011funu s\u00f6yleyebilirim. Kurulumu da zor de\u011fil: $ gpg --keyserver hkp://keys.gnupg.net --recv-keys D39DC0E3 \\c url -sSL https://get.rvm.io | bash -s stable Rbenv'den en b\u00fcy\u00fck farkl\u0131\u011f\u0131 Gem Set yani proje bazl\u0131 Ruby paketi y\u00f6netimi \u00f6zelli\u011fi. Ben Rbenv'ci oldu\u011fum i\u00e7in RVM kullanm\u0131yorum. \u00d6zellikle yeni ba\u015flayanlar i\u00e7in RVM'i \u00f6neriyorum, Rbenv'e g\u00f6re daha kolay kurulumu ve kullan\u0131m\u0131 var.","title":"Kurulum"},{"location":"bolum-01/02-kurulum/#kurulum","text":"","title":"Kurulum"},{"location":"bolum-01/02-kurulum/#osx","text":"E\u011fer Mac OSX kullan\u0131yorsan\u0131z ilk etapta hi\u00e7bir \u015feye ihtiyac\u0131n\u0131z yok, \u00e7\u00fcnk\u00fc Mac OSX'de Ruby haz\u0131r kurulu olarak geliyor. OSX Mavericks (10.9.4) Ruby s\u00fcr\u00fcm\u00fc: ruby 2.1.0p0 (2013-12-25 revision 44422) [x86_64-darwin13.0] macOS Catalina (10.5.7) Ruby s\u00fcr\u00fcm\u00fc: ruby 2.6.3p62 (2019-04-16 revision 67580) [universal.x86_64-darwin19]","title":"OSX"},{"location":"bolum-01/02-kurulum/#linux","text":"Debian ve Ubuntu kullanan okuyucular\u0131m\u0131z $ sudo apt-get install ruby # ya da $ sudo aptitude install ruby CentOS Fedora ya da RedHat kullananlar: $ sudo yum install ruby Gentoo kullananlar; $ sudo emerge dev-lang/ruby","title":"Linux"},{"location":"bolum-01/02-kurulum/#kaynaktan-kurulum","text":"Ruby'nin sitesinden tar dosyas\u0131n\u0131 indirip; $ ./configure $ make $ sudo make install \u015feklinde de kurulum yapabilirsiniz.","title":"Kaynaktan Kurulum"},{"location":"bolum-01/02-kurulum/#windows","text":"Bu siteden \u00f6zel Windows i\u00e7in haz\u0131rlanm\u0131\u015f Ruby kurulum paketini indirip klasik \"next\" > \"next\" diyerek kurulum yapabilirsiniz.","title":"Windows"},{"location":"bolum-01/02-kurulum/#ruby-versiyon-yoneticileri","text":"Bazen, kulland\u0131\u011f\u0131n\u0131z haz\u0131r k\u00fct\u00fcphanelerin destekledikleri Ruby versiyonlar\u0131ndaki k\u0131s\u0131tlamalar ya da ki\u015fisel tercihiniz gibi, farkl\u0131 nedenlerle birden fazla Ruby s\u00fcr\u00fcm\u00fc ile \u00e7al\u0131\u015fmak isteyebilirsiniz. Projelerinizden biri, \u00f6rne\u011fin ruby 1.9.3 kullan\u0131rken, di\u011fer bir projeniz ruby 2.1.0 kullan\u0131yor olabilir. Bu anlarda kulland\u0131\u011f\u0131n\u0131z Ruby versiyonunu kolayca de\u011fi\u015ftirmek, asl\u0131nda aktive etmek de diyebiliriz, i\u00e7in 2 adet pop\u00fcler versiyon y\u00f6neticisi bulunmaktad\u0131r.","title":"Ruby Versiyon Y\u00f6neticileri"},{"location":"bolum-01/02-kurulum/#rbenv","text":"Rbenv me\u015fhur 37 Signals '\u0131n. Asl\u0131nda orada \u00e7al\u0131\u015fan Sam Stephenson taraf\u0131ndan geli\u015ftirilmi\u015f bir ara\u00e7. E\u011fer OSX ve Homebrew kullan\u0131yorsan\u0131z kurulum \u00e7ok kolay: $ brew install rbenv ruby-build E\u011fer farkl\u0131 bir i\u015fletim sistemi kullan\u0131yorsan\u0131z (Linux/Unix tabanl\u0131) $ git clone https://github.com/sstephenson/rbenv.git ~/.rbenv sonra PATH 'e ekleyin ( bash profile ya da ne kullan\u0131yorsan\u0131z ) export PATH = \" $HOME /.rbenv/bin: $PATH \" # a\u00e7\u0131l\u0131\u015fa bunuda ekleyin # hangisini kullan\u0131yorsan\u0131z (.bashrc, .profile ya da .bash_profile) eval \" $( rbenv init - ) \" Kurulumdan sonra istedi\u011fini Ruby versiyonu i\u00e7in; # kurulabilecek versiyonlar\u0131 g\u00f6ster $ rbenv install -l # ruby 2.3.0'\u0131 kural\u0131m $ rbenv install 2 .3.0 Kurulan Ruby'yi Sistem genelinde rbenv global Sadece bulundu\u011fumuz dizin i\u00e7inde (Uygulamaya \u00d6zel) rbenv local Anl\u0131k, sadece Shell'de rbenv shell aktive etme opsiyonlar\u0131m\u0131z var. \u00d6rne\u011fin proje dizinin i\u00e7ine .ruby-version dosyas\u0131 koyar ve i\u00e7ine de hangi versiyonu kulland\u0131\u011f\u0131m\u0131z\u0131 yazarsak o dizine ge\u00e7ti\u011fimiz an Ruby versiyonu de\u011fi\u015fir. Yani A projesinde versiyon 2.1.1 , B projesinde version 1.9.3 kullanmak i\u00e7in; $ cd ~/projelerim/A/ $ echo \"1.9.3\" > .ruby-version $ cd ~/projelerim/B/ $ echo \"2.1.1\" > .ruby-version # bakal\u0131m hangi versiyonu aktive etmi\u015fiz? $ rbenv version","title":"Rbenv"},{"location":"bolum-01/02-kurulum/#rvm","text":"Ad\u0131ndan da anla\u015f\u0131laca\u011f\u0131 gibi R uby V ersion M anager yani RVM de ayn\u0131 Rbenv gibi Ruby versiyonlar\u0131n\u0131 kolay y\u00f6netmeyi sa\u011fl\u0131yor. Ruby d\u00fcnyas\u0131ndan Rbenv'ciler ve RVM'ciler olarak iki kanat oldu\u011funu s\u00f6yleyebilirim. Kurulumu da zor de\u011fil: $ gpg --keyserver hkp://keys.gnupg.net --recv-keys D39DC0E3 \\c url -sSL https://get.rvm.io | bash -s stable Rbenv'den en b\u00fcy\u00fck farkl\u0131\u011f\u0131 Gem Set yani proje bazl\u0131 Ruby paketi y\u00f6netimi \u00f6zelli\u011fi. Ben Rbenv'ci oldu\u011fum i\u00e7in RVM kullanm\u0131yorum. \u00d6zellikle yeni ba\u015flayanlar i\u00e7in RVM'i \u00f6neriyorum, Rbenv'e g\u00f6re daha kolay kurulumu ve kullan\u0131m\u0131 var.","title":"RVM"},{"location":"bolum-01/03-interaktif-kullanim/","text":"\u0130nteraktif Kullan\u0131m Ruby'nin ( ve benzer dillerin ) en \u00e7ok ho\u015fuma giden \u00f6zelli\u011fi \u0130nteraktif Shell \u00f6zelli\u011fi olmas\u0131d\u0131r. Ayn\u0131 eskiden Commodore 64 g\u00fcnlerindeki gibi, shell'i a\u00e7\u0131p Ruby yazmaya ba\u015flayabiliriz. Genel olarak bu interaktif kullan\u0131m REPL olarak ge\u00e7er. REPL asl\u0131nda R ead E valuate P rint L oop'un ba\u015f harfleridir. Yani, kullan\u0131c\u0131dan bir input ( Read ) gelir, bu girdi \u00e7al\u0131\u015ft\u0131r\u0131l\u0131r ( Evaluate ), sonu\u00e7 ekrana yazd\u0131r\u0131l\u0131r ( Print ) ve son olarak ba\u015fa d\u00f6ner ve yine input bekler ( Loop ). REPL olay\u0131, Python ve PHP'de de var. IRB Ruby kurulumu ile beraber gelir. Yapman\u0131z gereken Terminal'i a\u00e7\u0131p irb yaz\u0131p enter a basmak. $ irb irb ( main ) :001:0> print \"Merhaba D\u00fcnya\" Merhaba D\u00fcnya = > nil irb ( main ) :002:0> \u00d6rnekleri yaparken \u00e7ok s\u0131k kullanaca\u011f\u0131z bu komutu. Keza, daha da geli\u015ftirilmi\u015f bir versiyon olan pry gem'ini de g\u00f6rece\u011fiz ilerleyen b\u00f6l\u00fcmlerde. Shell Shebang dedi\u011fimiz y\u00f6ntemli Linux/Unix tabanl\u0131 i\u015fletim sistemlerinde Ruby dosyalar\u0131n\u0131 ayn\u0131 bir uygulama \u00e7al\u0131\u015ft\u0131r\u0131r gibi kullanabilirsiniz. test.rb dosyas\u0131 oldu\u011funu d\u00fc\u015f\u00fcn\u00fcn; bu dosya #!/usr/bin/env ruby puts \"Merhaba d\u00fcnya\" \u015feklinde olsun. Bu dosyay\u0131 \u00e7al\u0131\u015ft\u0131rmak i\u00e7in ya $ ruby test.rb ya da, dosyan\u0131n Execute flag'ini aktif hale getirerek $ chmod +x test.rb $ ./test.rb \u00e7al\u0131\u015ft\u0131rabilirsiniz. E\u011fer Execute flag'ini aktif hale getirmez iseniz i\u015fletim sistemi size a\u015fa\u011f\u0131daki gibi bir hata d\u00f6necektir. permission denied: ./test.rb Bunun sebebi dosyan\u0131z\u0131n execute edilebilmesi i\u00e7in izninin bulunmamas\u0131d\u0131r. Konuya daha yak\u0131ndan bakmak i\u00e7in test.rb dosyas\u0131n\u0131n bulundu\u011fu dizinde ls -l komutunu \u00e7al\u0131\u015ft\u0131ral\u0131m. $ ls -l total 8 -rw-r--r-- 1 kullanici staff 42 May 20 23 :48 test.rb Burada g\u00f6r\u00fclece\u011fi gibi -rw-r--r-- dosyan\u0131z\u0131n sadece okuma ve aktif kullan\u0131c\u0131 i\u00e7in yazma izni bulunmakta. E\u011fer yukar\u0131daki gibi Execute flag'ini aktif hale getirirseniz dosyan\u0131z\u0131n son hali a\u015fa\u011f\u0131daki gibi olacakt\u0131r. $ ls -l total 8 -rwxr-xr-x 1 kullanici staff 42 May 20 23 :48 test.rb \u015eu anda dosyan\u0131z t\u00fcm kullan\u0131c\u0131larda okunabilir ve \u00e7al\u0131\u015ft\u0131r\u0131labilir durumda.","title":"\u0130nteraktif Kullan\u0131m"},{"location":"bolum-01/03-interaktif-kullanim/#interaktif-kullanm","text":"Ruby'nin ( ve benzer dillerin ) en \u00e7ok ho\u015fuma giden \u00f6zelli\u011fi \u0130nteraktif Shell \u00f6zelli\u011fi olmas\u0131d\u0131r. Ayn\u0131 eskiden Commodore 64 g\u00fcnlerindeki gibi, shell'i a\u00e7\u0131p Ruby yazmaya ba\u015flayabiliriz. Genel olarak bu interaktif kullan\u0131m REPL olarak ge\u00e7er. REPL asl\u0131nda R ead E valuate P rint L oop'un ba\u015f harfleridir. Yani, kullan\u0131c\u0131dan bir input ( Read ) gelir, bu girdi \u00e7al\u0131\u015ft\u0131r\u0131l\u0131r ( Evaluate ), sonu\u00e7 ekrana yazd\u0131r\u0131l\u0131r ( Print ) ve son olarak ba\u015fa d\u00f6ner ve yine input bekler ( Loop ). REPL olay\u0131, Python ve PHP'de de var.","title":"\u0130nteraktif Kullan\u0131m"},{"location":"bolum-01/03-interaktif-kullanim/#irb","text":"Ruby kurulumu ile beraber gelir. Yapman\u0131z gereken Terminal'i a\u00e7\u0131p irb yaz\u0131p enter a basmak. $ irb irb ( main ) :001:0> print \"Merhaba D\u00fcnya\" Merhaba D\u00fcnya = > nil irb ( main ) :002:0> \u00d6rnekleri yaparken \u00e7ok s\u0131k kullanaca\u011f\u0131z bu komutu. Keza, daha da geli\u015ftirilmi\u015f bir versiyon olan pry gem'ini de g\u00f6rece\u011fiz ilerleyen b\u00f6l\u00fcmlerde.","title":"IRB"},{"location":"bolum-01/03-interaktif-kullanim/#shell","text":"Shebang dedi\u011fimiz y\u00f6ntemli Linux/Unix tabanl\u0131 i\u015fletim sistemlerinde Ruby dosyalar\u0131n\u0131 ayn\u0131 bir uygulama \u00e7al\u0131\u015ft\u0131r\u0131r gibi kullanabilirsiniz. test.rb dosyas\u0131 oldu\u011funu d\u00fc\u015f\u00fcn\u00fcn; bu dosya #!/usr/bin/env ruby puts \"Merhaba d\u00fcnya\" \u015feklinde olsun. Bu dosyay\u0131 \u00e7al\u0131\u015ft\u0131rmak i\u00e7in ya $ ruby test.rb ya da, dosyan\u0131n Execute flag'ini aktif hale getirerek $ chmod +x test.rb $ ./test.rb \u00e7al\u0131\u015ft\u0131rabilirsiniz. E\u011fer Execute flag'ini aktif hale getirmez iseniz i\u015fletim sistemi size a\u015fa\u011f\u0131daki gibi bir hata d\u00f6necektir. permission denied: ./test.rb Bunun sebebi dosyan\u0131z\u0131n execute edilebilmesi i\u00e7in izninin bulunmamas\u0131d\u0131r. Konuya daha yak\u0131ndan bakmak i\u00e7in test.rb dosyas\u0131n\u0131n bulundu\u011fu dizinde ls -l komutunu \u00e7al\u0131\u015ft\u0131ral\u0131m. $ ls -l total 8 -rw-r--r-- 1 kullanici staff 42 May 20 23 :48 test.rb Burada g\u00f6r\u00fclece\u011fi gibi -rw-r--r-- dosyan\u0131z\u0131n sadece okuma ve aktif kullan\u0131c\u0131 i\u00e7in yazma izni bulunmakta. E\u011fer yukar\u0131daki gibi Execute flag'ini aktif hale getirirseniz dosyan\u0131z\u0131n son hali a\u015fa\u011f\u0131daki gibi olacakt\u0131r. $ ls -l total 8 -rwxr-xr-x 1 kullanici staff 42 May 20 23 :48 test.rb \u015eu anda dosyan\u0131z t\u00fcm kullan\u0131c\u0131larda okunabilir ve \u00e7al\u0131\u015ft\u0131r\u0131labilir durumda.","title":"Shell"},{"location":"bolum-01/04-ruby-komutu-ve-parametreleri/","text":"Ruby Komutu ve Parametreleri Kurulum i\u015flemleri bittikten sonra ya da kulland\u0131\u011f\u0131n\u0131z OS ( \u0130\u015fletim Sistemi ) \u00f6n tan\u0131ml\u0131 Ruby ile geliyorsa hemen a\u015fa\u011f\u0131daki testi yapabilirsiniz: $ ruby --help Usage: ruby [ switches ] [ -- ] [ programfile ] [ arguments ] ruby 'yi \u00e7a\u011f\u0131r\u0131rken, her shell arac\u0131 gibi ( binary mi diyim, executable m\u0131 diyim karar veremedim! ) Ruby de \u00e7e\u015fitli parametreler alabiliyor. Bu k\u0131s\u0131ma dikkat edelim \u00e7\u00fcnk\u00fc burada bahsi ge\u00e7ecek Switch 'ler 2.B\u00f6l\u00fcmde g\u00f6rece\u011fimiz \u00d6n Tan\u0131ml\u0131 De\u011fi\u015fkenler ile \u00e7ok alakal\u0131. Switch A\u00e7\u0131klamas\u0131 -0[octal] $/ de\u011feridir. ( \u00d6n tan\u0131ml\u0131 de\u011fi\u015fkenlerde g\u00f6rece\u011fiz ) octal yani 8'lik sistemde de\u011fer atan\u0131r. \u00d6rne\u011fin ruby -0777 \u015feklinde \u00e7al\u0131\u015ft\u0131r\u0131lsa, Ruby, dosya okuma i\u015flemleri s\u0131ras\u0131nda tek seferde dosyay\u0131 okur ve tek String haline getirir. -a -n ve -p ile birlikte kullan\u0131l\u0131nca autosplit mode olarak \u00e7al\u0131\u015f\u0131r. Yani $F => $_.split \u015feklinde i\u015fler. -c Syntax Check yani dosya i\u00e7indeki kodu \u00e7al\u0131\u015ft\u0131rmadan, sadece s\u00f6z dizimi kontrol\u00fc yapar ve \u00e7\u0131kar. -C directory Ruby \u00f6nce belirtilen directory 'ye cd ( Shell'de bir dizine ge\u00e7i\u015f yapmak ) yapar ve daha sonra kodu \u00e7al\u0131\u015ft\u0131r\u0131r. ruby -C/tmp/foo gibi.. -d, --debug Debug modda \u00e7al\u0131\u015ft\u0131r\u0131r. Bu esnada $DEBUG de\u011fi\u015fkeni de true de\u011ferini al\u0131r. Yani e\u011fer kodunuzun i\u00e7inde if $DEBUG gibi bir ifade kullanabilir ve sonucunu g\u00f6rebilirsiniz. -e 'command' Komut sat\u0131r\u0131ndan tek sat\u0131rda Ruby kodu \u00e7al\u0131\u015ft\u0131rmak i\u00e7in. ruby -e 'puts \"hello\"' gibi. -Eex[:in], --encoding=ex[:in] Varsay\u0131lan karakter encoding'i ( Internal ve External i\u00e7in... ) --external-encoding=encoding -E gibi --internal-encoding=encoding -E gibi -F pattern auto split i\u00e7in ve split() i\u00e7in varsay\u0131lan regex pattern'i. $; de\u011feri. -i in-place-edit mod. L\u00fctfen \u00f6rne\u011fe bak\u0131n! -I $LOAD_PATH 'e ilave path ekleme. -K Japonca ( KANJI ) encoding belirtilir. UTF-8 i\u00e7in -K u kullan\u0131labilir. -l Otomatik sat\u0131r sonu ( Line Ending ) i\u015flemi. -n ve -p ile \u00e7al\u0131\u015f\u0131r. \u00d6nce $\\ de\u011fi\u015fkenine $/ de\u011feri atan\u0131r, chop! method\u2019u her sat\u0131ra uygulan\u0131r. -n Komut sat\u0131r\u0131ndaki sed -n ya da awk gibi \u00e7al\u0131\u015f\u0131r. Sanki kodun etraf\u0131nda loop varm\u0131\u015f gibi davranarak s\u00fczge\u00e7ten ge\u00e7irir. -p -n gibi \u00e7al\u0131\u015f\u0131r, fark\u0131 $_ den gelen de\u011feri d\u00f6ng\u00fcn\u00fcn sonunda print eder. -r require komutunun yapt\u0131\u011f\u0131 gibi verilen de\u011feri require eder. ( require komutunu ileride g\u00f6rece\u011fiz) -s Komut sat\u0131r\u0131 arg\u00fcmanlar\u0131n\u0131 parse etme ( i\u015fleme ) \u00f6zelli\u011fini aktive eder. -S $PATH \u00e7evre de\u011fi\u015fkenini bulmay\u0131 forse eder. \u00d6rne\u011fe bak\u0131n\u0131z! -T G\u00fcvenlik seviyesi, tainted kontrol\u00fcn\u00fc devreye sokmak. $SAFE de\u011fi\u015fkenine -T ile ge\u00e7ilen de\u011fer atan\u0131r. -v, --verbose \u00d6nce versiyon numaras\u0131n\u0131 yazar sonra da verbose ( Ayr\u0131nt\u0131l\u0131 \u00e7al\u0131\u015ft\u0131rma ) modu aktive eder. Yani $VERBOSE true olur. -w -v ile ayn\u0131 i\u015fi yapar sadece versiyon numaras\u0131n\u0131 yazmaz. -W Uyar\u0131 seviyesini belirler ( Warning Level ). 0 Sessiz, 1 Orta \u015fekerli, 2 Verbose! -x Shebang 'den \u00f6nceki yaz\u0131y\u0131 siler atar ve alternatif olarak ilgili dizine cd yapar. --copyright Ruby'e ait telif bilgisini yazar. ruby - Copyright (C) 1993-2013 Yukihiro Matsumoto --enable=feature[,...], --disable=feature[,...] \u00d6rne\u011fin kodun RubyGem 'lerini kullanmas\u0131n\u0131 istemiyorsan\u0131z --disable-gems \u015feklinde, ya da $RUBYOPT \u00e7evre de\u011fi\u015fkenini devre d\u0131\u015f\u0131 b\u0131rakmak i\u00e7in --disable-rubyopt gibi. --disable-all her ek \u00f6zelli\u011fi devre d\u0131\u015f\u0131 b\u0131rak\u0131r. --enable-all ya da devreye sokar. --version Versiyon numaras\u0131n\u0131 yazar. --help Yard\u0131m sayfas\u0131n\u0131 g\u00f6sterir. ruby --help d\u0131\u015f\u0131nda daha detayl\u0131 bilgi man ruby yani man pages 'da bulmak m\u00fcmk\u00fcnd\u00fcr, ben de pek \u00e7ok \u015feye oradan bakt\u0131m. -i \u00f6rne\u011fi: \u00d6nce i\u00e7inde d\u00fcz metin olan bir dosya olu\u015ftural\u0131m: $ echo vigo > /tmp/test.txt $ cat /tmp/test.txt # vigo sonra; $ ruby -p -i.backup -e '$_.upcase!' /tmp/test.txt $ cat /tmp/test.txt.backup # VIGO Ne oldu? Amac\u0131m\u0131z, /tmp/test.txt dosyas\u0131nda, sat\u0131r sat\u0131r okuyup her sat\u0131rda yazan metni uppercase yani b\u00fcy\u00fck harfe \u00e7evirmek. Normalde bu i\u015flemi; $ ruby -p -e '$_.upcase!' /tmp/test.txt \u015feklinde komut sat\u0131r\u0131ndan yapabiliyoruz. Ama in-place-edit mod ve extension \u00f6zelli\u011fi ile, \u00e7al\u0131\u015ft\u0131r\u0131lm\u0131\u015f kod \u00e7\u0131kt\u0131s\u0131n\u0131 ba\u015fka bir dosyada g\u00f6r\u00fcnt\u00fcleyebiliriz. Bu noktada -i devreye giriyor. -i.backup sonucun g\u00f6r\u00fcnt\u00fclendi\u011fi dosya oluyor. -n \u00f6rne\u011fi: Loop'tan kast\u0131m, sanki; while gets # kod... end \u00e7evreler. -s \u00f6rne\u011fi: example_s.rb ad\u0131nda bir dosyam\u0131z olsun ve i\u00e7inde; print \"xyz arg\u00fcman\u0131 kullan\u0131ld\u0131 \\n \" if $xyz yazs\u0131n. Bu dosyay\u0131 \u00e7al\u0131\u015ft\u0131r\u0131n; $ ruby example_s.rb Hi\u00e7bir \u00e7\u0131kt\u0131 g\u00f6rmezsiniz. E\u011fer \u015fu \u015fekilde \u00e7al\u0131\u015ft\u0131r\u0131rsan\u0131z; $ ruby -s example_s.rb -xyz \u015fu \u00e7\u0131kt\u0131y\u0131 al\u0131rs\u0131n\u0131z: xyz arg\u00fcman\u0131 kullan\u0131ld\u0131 -S \u00f6rne\u011fi: Baz\u0131 i\u015fletim sistemlerin Shebang sorunu olabilir. #!/usr/bin/env ruby Bu gibi durumlarda; #!/bin/sh exec ruby -S -x $0 \" $@ \" \u015fekinde, bash \u00fczeriden Ruby scripti'ni \u00e7al\u0131\u015ft\u0131rabiliriz. @wip","title":"Ruby Komutu ve Parametreleri"},{"location":"bolum-01/04-ruby-komutu-ve-parametreleri/#ruby-komutu-ve-parametreleri","text":"Kurulum i\u015flemleri bittikten sonra ya da kulland\u0131\u011f\u0131n\u0131z OS ( \u0130\u015fletim Sistemi ) \u00f6n tan\u0131ml\u0131 Ruby ile geliyorsa hemen a\u015fa\u011f\u0131daki testi yapabilirsiniz: $ ruby --help Usage: ruby [ switches ] [ -- ] [ programfile ] [ arguments ] ruby 'yi \u00e7a\u011f\u0131r\u0131rken, her shell arac\u0131 gibi ( binary mi diyim, executable m\u0131 diyim karar veremedim! ) Ruby de \u00e7e\u015fitli parametreler alabiliyor. Bu k\u0131s\u0131ma dikkat edelim \u00e7\u00fcnk\u00fc burada bahsi ge\u00e7ecek Switch 'ler 2.B\u00f6l\u00fcmde g\u00f6rece\u011fimiz \u00d6n Tan\u0131ml\u0131 De\u011fi\u015fkenler ile \u00e7ok alakal\u0131. Switch A\u00e7\u0131klamas\u0131 -0[octal] $/ de\u011feridir. ( \u00d6n tan\u0131ml\u0131 de\u011fi\u015fkenlerde g\u00f6rece\u011fiz ) octal yani 8'lik sistemde de\u011fer atan\u0131r. \u00d6rne\u011fin ruby -0777 \u015feklinde \u00e7al\u0131\u015ft\u0131r\u0131lsa, Ruby, dosya okuma i\u015flemleri s\u0131ras\u0131nda tek seferde dosyay\u0131 okur ve tek String haline getirir. -a -n ve -p ile birlikte kullan\u0131l\u0131nca autosplit mode olarak \u00e7al\u0131\u015f\u0131r. Yani $F => $_.split \u015feklinde i\u015fler. -c Syntax Check yani dosya i\u00e7indeki kodu \u00e7al\u0131\u015ft\u0131rmadan, sadece s\u00f6z dizimi kontrol\u00fc yapar ve \u00e7\u0131kar. -C directory Ruby \u00f6nce belirtilen directory 'ye cd ( Shell'de bir dizine ge\u00e7i\u015f yapmak ) yapar ve daha sonra kodu \u00e7al\u0131\u015ft\u0131r\u0131r. ruby -C/tmp/foo gibi.. -d, --debug Debug modda \u00e7al\u0131\u015ft\u0131r\u0131r. Bu esnada $DEBUG de\u011fi\u015fkeni de true de\u011ferini al\u0131r. Yani e\u011fer kodunuzun i\u00e7inde if $DEBUG gibi bir ifade kullanabilir ve sonucunu g\u00f6rebilirsiniz. -e 'command' Komut sat\u0131r\u0131ndan tek sat\u0131rda Ruby kodu \u00e7al\u0131\u015ft\u0131rmak i\u00e7in. ruby -e 'puts \"hello\"' gibi. -Eex[:in], --encoding=ex[:in] Varsay\u0131lan karakter encoding'i ( Internal ve External i\u00e7in... ) --external-encoding=encoding -E gibi --internal-encoding=encoding -E gibi -F pattern auto split i\u00e7in ve split() i\u00e7in varsay\u0131lan regex pattern'i. $; de\u011feri. -i in-place-edit mod. L\u00fctfen \u00f6rne\u011fe bak\u0131n! -I $LOAD_PATH 'e ilave path ekleme. -K Japonca ( KANJI ) encoding belirtilir. UTF-8 i\u00e7in -K u kullan\u0131labilir. -l Otomatik sat\u0131r sonu ( Line Ending ) i\u015flemi. -n ve -p ile \u00e7al\u0131\u015f\u0131r. \u00d6nce $\\ de\u011fi\u015fkenine $/ de\u011feri atan\u0131r, chop! method\u2019u her sat\u0131ra uygulan\u0131r. -n Komut sat\u0131r\u0131ndaki sed -n ya da awk gibi \u00e7al\u0131\u015f\u0131r. Sanki kodun etraf\u0131nda loop varm\u0131\u015f gibi davranarak s\u00fczge\u00e7ten ge\u00e7irir. -p -n gibi \u00e7al\u0131\u015f\u0131r, fark\u0131 $_ den gelen de\u011feri d\u00f6ng\u00fcn\u00fcn sonunda print eder. -r require komutunun yapt\u0131\u011f\u0131 gibi verilen de\u011feri require eder. ( require komutunu ileride g\u00f6rece\u011fiz) -s Komut sat\u0131r\u0131 arg\u00fcmanlar\u0131n\u0131 parse etme ( i\u015fleme ) \u00f6zelli\u011fini aktive eder. -S $PATH \u00e7evre de\u011fi\u015fkenini bulmay\u0131 forse eder. \u00d6rne\u011fe bak\u0131n\u0131z! -T G\u00fcvenlik seviyesi, tainted kontrol\u00fcn\u00fc devreye sokmak. $SAFE de\u011fi\u015fkenine -T ile ge\u00e7ilen de\u011fer atan\u0131r. -v, --verbose \u00d6nce versiyon numaras\u0131n\u0131 yazar sonra da verbose ( Ayr\u0131nt\u0131l\u0131 \u00e7al\u0131\u015ft\u0131rma ) modu aktive eder. Yani $VERBOSE true olur. -w -v ile ayn\u0131 i\u015fi yapar sadece versiyon numaras\u0131n\u0131 yazmaz. -W Uyar\u0131 seviyesini belirler ( Warning Level ). 0 Sessiz, 1 Orta \u015fekerli, 2 Verbose! -x Shebang 'den \u00f6nceki yaz\u0131y\u0131 siler atar ve alternatif olarak ilgili dizine cd yapar. --copyright Ruby'e ait telif bilgisini yazar. ruby - Copyright (C) 1993-2013 Yukihiro Matsumoto --enable=feature[,...], --disable=feature[,...] \u00d6rne\u011fin kodun RubyGem 'lerini kullanmas\u0131n\u0131 istemiyorsan\u0131z --disable-gems \u015feklinde, ya da $RUBYOPT \u00e7evre de\u011fi\u015fkenini devre d\u0131\u015f\u0131 b\u0131rakmak i\u00e7in --disable-rubyopt gibi. --disable-all her ek \u00f6zelli\u011fi devre d\u0131\u015f\u0131 b\u0131rak\u0131r. --enable-all ya da devreye sokar. --version Versiyon numaras\u0131n\u0131 yazar. --help Yard\u0131m sayfas\u0131n\u0131 g\u00f6sterir. ruby --help d\u0131\u015f\u0131nda daha detayl\u0131 bilgi man ruby yani man pages 'da bulmak m\u00fcmk\u00fcnd\u00fcr, ben de pek \u00e7ok \u015feye oradan bakt\u0131m.","title":"Ruby Komutu ve Parametreleri"},{"location":"bolum-01/04-ruby-komutu-ve-parametreleri/#-i-ornegi","text":"\u00d6nce i\u00e7inde d\u00fcz metin olan bir dosya olu\u015ftural\u0131m: $ echo vigo > /tmp/test.txt $ cat /tmp/test.txt # vigo sonra; $ ruby -p -i.backup -e '$_.upcase!' /tmp/test.txt $ cat /tmp/test.txt.backup # VIGO Ne oldu? Amac\u0131m\u0131z, /tmp/test.txt dosyas\u0131nda, sat\u0131r sat\u0131r okuyup her sat\u0131rda yazan metni uppercase yani b\u00fcy\u00fck harfe \u00e7evirmek. Normalde bu i\u015flemi; $ ruby -p -e '$_.upcase!' /tmp/test.txt \u015feklinde komut sat\u0131r\u0131ndan yapabiliyoruz. Ama in-place-edit mod ve extension \u00f6zelli\u011fi ile, \u00e7al\u0131\u015ft\u0131r\u0131lm\u0131\u015f kod \u00e7\u0131kt\u0131s\u0131n\u0131 ba\u015fka bir dosyada g\u00f6r\u00fcnt\u00fcleyebiliriz. Bu noktada -i devreye giriyor. -i.backup sonucun g\u00f6r\u00fcnt\u00fclendi\u011fi dosya oluyor.","title":"-i \u00f6rne\u011fi:"},{"location":"bolum-01/04-ruby-komutu-ve-parametreleri/#-n-ornegi","text":"Loop'tan kast\u0131m, sanki; while gets # kod... end \u00e7evreler.","title":"-n \u00f6rne\u011fi:"},{"location":"bolum-01/04-ruby-komutu-ve-parametreleri/#-s-ornegi","text":"example_s.rb ad\u0131nda bir dosyam\u0131z olsun ve i\u00e7inde; print \"xyz arg\u00fcman\u0131 kullan\u0131ld\u0131 \\n \" if $xyz yazs\u0131n. Bu dosyay\u0131 \u00e7al\u0131\u015ft\u0131r\u0131n; $ ruby example_s.rb Hi\u00e7bir \u00e7\u0131kt\u0131 g\u00f6rmezsiniz. E\u011fer \u015fu \u015fekilde \u00e7al\u0131\u015ft\u0131r\u0131rsan\u0131z; $ ruby -s example_s.rb -xyz \u015fu \u00e7\u0131kt\u0131y\u0131 al\u0131rs\u0131n\u0131z: xyz arg\u00fcman\u0131 kullan\u0131ld\u0131","title":"-s \u00f6rne\u011fi:"},{"location":"bolum-01/04-ruby-komutu-ve-parametreleri/#-s-ornegi_1","text":"Baz\u0131 i\u015fletim sistemlerin Shebang sorunu olabilir. #!/usr/bin/env ruby Bu gibi durumlarda; #!/bin/sh exec ruby -S -x $0 \" $@ \" \u015fekinde, bash \u00fczeriden Ruby scripti'ni \u00e7al\u0131\u015ft\u0131rabiliriz. @wip","title":"-S \u00f6rne\u011fi:"},{"location":"bolum-02/","text":"B\u00f6l\u00fcm 2 Bu b\u00f6l\u00fcmde; Syntax ( S\u00f6z Dizimi ) Comments ( Yorum sat\u0131r\u0131 ) Rezerve Edilmi\u015f Kelimeler De\u011fi\u015fken Tan\u0131mlama ve T\u00fcrleri Duck Typing \u00d6n Tan\u0131ml\u0131 De\u011fi\u015fkenler Pseudo De\u011fi\u015fkenler Operat\u00f6rler Global Constants ( Genel Sabitler ) konular\u0131n\u0131 i\u015fleyece\u011fiz.","title":"\u0130ndeks"},{"location":"bolum-02/#bolum-2","text":"Bu b\u00f6l\u00fcmde; Syntax ( S\u00f6z Dizimi ) Comments ( Yorum sat\u0131r\u0131 ) Rezerve Edilmi\u015f Kelimeler De\u011fi\u015fken Tan\u0131mlama ve T\u00fcrleri Duck Typing \u00d6n Tan\u0131ml\u0131 De\u011fi\u015fkenler Pseudo De\u011fi\u015fkenler Operat\u00f6rler Global Constants ( Genel Sabitler ) konular\u0131n\u0131 i\u015fleyece\u011fiz.","title":"B\u00f6l\u00fcm 2"},{"location":"bolum-02/01-syntax-soz-dizimi-ve-degiskenler/","text":"Syntax (S\u00f6z Dizimi) ve Rezerve Kelimeler Syntax (S\u00f6z Dizimi) Genel olarak \u00e7ok kolay ve anla\u015f\u0131l\u0131r bir syntax 'a sahiptir. Sanki \u0130ngilizce okur/konu\u015fur gibi s\u00f6z dizimi bulunur. \u00d6rne\u011fin, E\u011fer a'n\u0131n de\u011feri 5'ten b\u00fcy\u00fckse ekrana \"Merhaba\" yaz demek istiyorsak; puts \"Merhaba\" if a > 5 \u015feklinde yazabiliriz. Di\u011fer dillerden farkl\u0131 olarak, Ruby'de fonksiyon (method) \u00e7a\u011f\u0131r\u0131rken parantez kullanmak zorunlu\u011fu yoktur. Bu ilk etapta kafa kar\u0131\u015ft\u0131r\u0131c\u0131 gibi dursa da, al\u0131\u015f\u0131nca ne kadar kolay okunabilir oldu\u011funu g\u00f6r\u00fcyorsunuz. Mecburi de\u011fil, yani parantez kullanman\u0131zda sorun yok. Parantezli kullan\u0131m; def greet_user ( user_name ) puts \"Merhaba #{ user_name } \" end greet_user ( \"U\u011fur\" ) # Merhaba U\u011fur E\u011fer parantez kullanmazsak; def greet_user user_name puts \"Merhaba #{ user_name } \" end greet_user \"U\u011fur\" # Merhaba U\u011fur \u015feklinde olur. Keza, pek \u00e7ok dilde, fonksiyon e\u011fer bir \u015fey d\u00f6nerse geriye, mutlaka return komutu kullan\u0131l\u0131r. Ruby'de buna da gerek yok. \u00c7\u00fcnk\u00fc her method ( yani Fonksiyon ) mutlaka default olarak bir \u015fey d\u00f6ner. Hi\u00e7bir \u015fey d\u00f6nmese bile nil d\u00f6ner. Bu bak\u0131mdan da; def greet_user user_name \"Merhaba #{ user_name } \" end puts greet_user \"U\u011fur\" # Merhaba U\u011fur \u015feklinde kullanabiliriz. Korkmay\u0131n, kafalar kar\u0131\u015fmas\u0131n. Detaylara ileride girece\u011fiz. Comments (Yorum Sat\u0131rlar\u0131) Her dilde oldu\u011fu gibi Comment out yani \"i\u015faretli k\u0131sm\u0131 \u00e7al\u0131\u015ft\u0131rma\" demek i\u00e7in kulland\u0131\u011f\u0131m\u0131z \u015fey Ruby'de de var. Comment i\u00e7in # i\u015fareti kullan\u0131l\u0131yor. Genelde line-comment yani sat\u0131r bazl\u0131, ve block-comment yani kod blo\u011fu bazl\u0131 yorum yapma \u015fekilleri var. # Bu sat\u0131r line-comment, yani tek sat\u0131rl\u0131 yorum # Bu k\u0131s\u0131m block-comment # # def test_user # true # end # ya da =begin Bu yorum... Bu da yorum... Hatta bu da... =end G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi block-comment i\u00e7in ilave olarak =begin ve =end kelimeleri kullan\u0131labiliyor. Rezerve Edilmi\u015f Kelimeler Her dilde oldu\u011fu gibi Ruby'de de daha \u00f6nceden rezerve edilmi\u015f baz\u0131 kelimeler bulunmaktad\u0131r. Bu kelimeleri de\u011fi\u015fken ya da method ad\u0131 olarak kullanam\u0131yoruz. Bu kelimeler Ruby komutlar\u0131 ve \u00f6zel durumlar i\u00e7in rezerve edilmi\u015f. Kelime Kelime BEGIN next END nil alias not and or begin redo break rescue case retry class return def self defined? super do then else true elsif undef end unless ensure until false when for while if yield in __FILE__ module __LINE__","title":"Syntax, Comments, Rezerve Edilmi\u015f Kelimeler"},{"location":"bolum-02/01-syntax-soz-dizimi-ve-degiskenler/#syntax-soz-dizimi-ve-rezerve-kelimeler","text":"","title":"Syntax (S\u00f6z Dizimi) ve Rezerve Kelimeler"},{"location":"bolum-02/01-syntax-soz-dizimi-ve-degiskenler/#syntax-soz-dizimi","text":"Genel olarak \u00e7ok kolay ve anla\u015f\u0131l\u0131r bir syntax 'a sahiptir. Sanki \u0130ngilizce okur/konu\u015fur gibi s\u00f6z dizimi bulunur. \u00d6rne\u011fin, E\u011fer a'n\u0131n de\u011feri 5'ten b\u00fcy\u00fckse ekrana \"Merhaba\" yaz demek istiyorsak; puts \"Merhaba\" if a > 5 \u015feklinde yazabiliriz. Di\u011fer dillerden farkl\u0131 olarak, Ruby'de fonksiyon (method) \u00e7a\u011f\u0131r\u0131rken parantez kullanmak zorunlu\u011fu yoktur. Bu ilk etapta kafa kar\u0131\u015ft\u0131r\u0131c\u0131 gibi dursa da, al\u0131\u015f\u0131nca ne kadar kolay okunabilir oldu\u011funu g\u00f6r\u00fcyorsunuz. Mecburi de\u011fil, yani parantez kullanman\u0131zda sorun yok. Parantezli kullan\u0131m; def greet_user ( user_name ) puts \"Merhaba #{ user_name } \" end greet_user ( \"U\u011fur\" ) # Merhaba U\u011fur E\u011fer parantez kullanmazsak; def greet_user user_name puts \"Merhaba #{ user_name } \" end greet_user \"U\u011fur\" # Merhaba U\u011fur \u015feklinde olur. Keza, pek \u00e7ok dilde, fonksiyon e\u011fer bir \u015fey d\u00f6nerse geriye, mutlaka return komutu kullan\u0131l\u0131r. Ruby'de buna da gerek yok. \u00c7\u00fcnk\u00fc her method ( yani Fonksiyon ) mutlaka default olarak bir \u015fey d\u00f6ner. Hi\u00e7bir \u015fey d\u00f6nmese bile nil d\u00f6ner. Bu bak\u0131mdan da; def greet_user user_name \"Merhaba #{ user_name } \" end puts greet_user \"U\u011fur\" # Merhaba U\u011fur \u015feklinde kullanabiliriz. Korkmay\u0131n, kafalar kar\u0131\u015fmas\u0131n. Detaylara ileride girece\u011fiz.","title":"Syntax (S\u00f6z Dizimi)"},{"location":"bolum-02/01-syntax-soz-dizimi-ve-degiskenler/#comments-yorum-satrlar","text":"Her dilde oldu\u011fu gibi Comment out yani \"i\u015faretli k\u0131sm\u0131 \u00e7al\u0131\u015ft\u0131rma\" demek i\u00e7in kulland\u0131\u011f\u0131m\u0131z \u015fey Ruby'de de var. Comment i\u00e7in # i\u015fareti kullan\u0131l\u0131yor. Genelde line-comment yani sat\u0131r bazl\u0131, ve block-comment yani kod blo\u011fu bazl\u0131 yorum yapma \u015fekilleri var. # Bu sat\u0131r line-comment, yani tek sat\u0131rl\u0131 yorum # Bu k\u0131s\u0131m block-comment # # def test_user # true # end # ya da =begin Bu yorum... Bu da yorum... Hatta bu da... =end G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi block-comment i\u00e7in ilave olarak =begin ve =end kelimeleri kullan\u0131labiliyor.","title":"Comments (Yorum Sat\u0131rlar\u0131)"},{"location":"bolum-02/01-syntax-soz-dizimi-ve-degiskenler/#rezerve-edilmis-kelimeler","text":"Her dilde oldu\u011fu gibi Ruby'de de daha \u00f6nceden rezerve edilmi\u015f baz\u0131 kelimeler bulunmaktad\u0131r. Bu kelimeleri de\u011fi\u015fken ya da method ad\u0131 olarak kullanam\u0131yoruz. Bu kelimeler Ruby komutlar\u0131 ve \u00f6zel durumlar i\u00e7in rezerve edilmi\u015f. Kelime Kelime BEGIN next END nil alias not and or begin redo break rescue case retry class return def self defined? super do then else true elsif undef end unless ensure until false when for while if yield in __FILE__ module __LINE__","title":"Rezerve Edilmi\u015f Kelimeler"},{"location":"bolum-02/02-degiskenler/","text":"De\u011fi\u015fkenler De\u011fi\u015fken denen \u015fey, yani Variable , nesneye atanm\u0131\u015f bir i\u015faret\u00e7idir asl\u0131nda. Ne demi\u015ftik? Ruby'de her \u015fey bir nesne yani Object . Bu nesnelere eri\u015fmek i\u00e7in arac\u0131d\u0131r de\u011fi\u015fkenler. Farkl\u0131 farkl\u0131 t\u00fcrleri vard\u0131r. Birazdan bunlara de\u011finece\u011fiz. En basit anlamda de\u011fi\u015fken tan\u0131mlamak; a = 5 user_email = \"example@foo.com\" \u015feklinde olur. Yukar\u0131daki \u00f6rnekte a ve user_email de\u011fi\u015fkenin ad\u0131d\u0131r. De\u011feri ise e\u015fittir i\u015faretinden sonra gelendir. Yani yukar\u0131da; a ya say\u0131 olarak 5 ve user_email e metin olarak example@foo.com de\u011ferleri atanm\u0131\u015ft\u0131r. Ruby Duck Typing \u015feklinde \u00e7al\u0131\u015f\u0131r. Yani atama yapmadan \u00f6nce ne t\u00fcr bir de\u011fer atamas\u0131 yapaca\u011f\u0131m\u0131z\u0131 belirtmemize gerek yok. Ruby zaten a = 5 dedi\u011fimizde, \"Hmmm, bu de\u011fer Fixnum t\u00fcr\u00fcnde\" diye de\u011ferlendirir. Duck Typing demek \u015fudur; E\u011fer \u00f6rdek gibi y\u00fcr\u00fcyorsa, \u00f6rdek gibi ses \u00e7\u0131kart\u0131yorsa e o zaman bu bir \u00d6rdektir! \u0130ngilizcesi; When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck Yani, bir ku\u015f, e\u011fer \u00f6rdek gibi y\u00fcr\u00fcyorsa, \u00f6rdek gibi y\u00fcz\u00fcyorsa ve \u00f6rdek gibi ses \u00e7\u0131kar\u0131yorsa ben buna \u00d6rdek derim! Metinsel Atamalar ve T\u0131rnak Kullan\u0131m\u0131 Yeri gelmi\u015fken h\u0131zl\u0131ca bir konuya de\u011finmek istiyorum. Metinsel de\u011fi\u015fkenler tan\u0131mlarken ( String ) e\u015fitlik esnas\u0131nda tek ya da \u00e7ift t\u0131rnak i\u015fareti kullanabiliriz. Fakat aradaki fark\u0131 bilerek kullanmam\u0131z gerekir. String i\u00e7inde de\u011fi\u015fken kullan\u0131m\u0131 yapt\u0131\u011f\u0131m\u0131z zaman yani; a = 41 puts \"Siz tam #{ a } ya\u015f\u0131ndas\u0131n\u0131z\" gibi bir durumda, g\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi #{a} \u015feklinde yaz\u0131 i\u00e7inde de\u011fi\u015fken kulland\u0131k. Bu kodun \u00e7\u0131kt\u0131s\u0131 a\u015fa\u011f\u0131daki gibi olacak. Siz tam 41 ya\u015f\u0131ndas\u0131n\u0131z Format olarak Ruby'de, #{BU KISIMDA KOD \u00c7ALI\u015eIR} \u015feklinde istedi\u011fimiz kodu \u00e7al\u0131\u015ft\u0131rma yetkimiz var. Bu i\u015flem sadece \u00e7ift t\u0131rnak kullan\u0131m\u0131nda ge\u00e7erlidir. Ba\u015fka bir \u00f6rnek vermek gerekirse; a = 41 puts \"Siz tam #{ a + 2 } ya\u015f\u0131ndas\u0131n\u0131z\" Yukar\u0131daki \u00f6rnekte Ruby a+2 komutunu \u00e7al\u0131\u015ft\u0131racakt\u0131r ve sonu\u00e7 olarak 43 de\u011ferini bulacakt\u0131r ve bunu ekrana yazd\u0131racak. Yani sonu\u00e7: Siz tam 43 ya\u015f\u0131ndas\u0131n\u0131z \u015feklinde olacakt\u0131r. Ancak ayn\u0131 kodu tek t\u0131rnak kullanarak yapm\u0131\u015f olsayd\u0131k; a = 41 puts 'Siz tam #{ a } ya\u015f\u0131ndas\u0131n\u0131z' \u00e7\u0131kt\u0131s\u0131: Siz tam #{a} ya\u015f\u0131ndas\u0131n\u0131z olacakt\u0131. Tek t\u0131rnak i\u00e7inde bu i\u015flem \u00e7al\u0131\u015fmaz! Local (B\u00f6lgesel) B\u00f6lgesel ya da Yerel de\u011fi\u015fkenler, bir scope i\u00e7indeki de\u011fi\u015fkenlerdir. Scope nedir? Kodun \u00e7al\u0131\u015ft\u0131\u011f\u0131 b\u00f6lge olarak tan\u0131mlayabiliriz. Bu t\u00fcr de\u011fi\u015fkenler mutlaka k\u00fc\u00e7\u00fck harfle ya da _ ( underscore ) i\u015fareti ile ba\u015flamal\u0131d\u0131r. Kesinlike @ , @@ ya da $ i\u015fareti gibi \u00f6n ekler alamazlar. out_text = \"vigo\" def greet_user ( user_name ) out_text = \"Merhaba #{ user_name } \" end puts greet_user ( \"vigo\" ) # Merhaba vigo puts out_text # vigo Program \u00e7al\u0131\u015ft\u0131\u011f\u0131nda out_text de\u011fi\u015fkeninin de\u011feri vigo olarak atanmaktad\u0131r. Daha sonra 6. sat\u0131rda greet_user method'u ( fonksiyonu ) \u00e7al\u0131\u015ft\u0131\u011f\u0131nda, o methodun i\u00e7erisinde out_text de\u011fi\u015fkeninin de\u011feri de\u011fi\u015ftiriliyor gibi g\u00f6r\u00fcn\u00fcyor. Daha sonra 7. sat\u0131rda out_text de\u011fi\u015fkeninin de\u011feri puts methodu ile ekrana yazd\u0131r\u0131lmaktad\u0131r. Ancak burada \u00e7\u0131kt\u0131lara bakt\u0131\u011f\u0131n\u0131zda methodun i\u00e7erisindeki out_text de\u011fi\u015fkenindeki de\u011fi\u015fim, program\u0131n en ba\u015f\u0131nda tan\u0131mlad\u0131\u011f\u0131m\u0131z out_text de\u011fi\u015fkenin de\u011ferini etkilememi\u015ftir. Method i\u00e7erisinde kalm\u0131\u015ft\u0131r. Burada method i\u00e7erisindeki out_text de\u011fi\u015fkeni asl\u0131nda local variable yani yerel de\u011fi\u015fken \u015feklinde \u00e7al\u0131\u015fmaktad\u0131r. Global (Genel) $ i\u015faretiyle ba\u015flayan t\u00fcm de\u011fi\u015fkenler Global de\u011fi\u015fkenlerdir. Kodun herhangi bir yerinde kullan\u0131labilir ve eri\u015filebilir. $today = \"Pazartesi\" def greet_user ( user_name ) out_text = \"Merhaba #{ user_name } , bug\u00fcn #{ $today } \" puts out_text end puts \"Bug\u00fcn g\u00fcnlerden ne? #{ $today } \" greet_user ( \"vigo\" ) # Merhaba vigo, bug\u00fcn Pazartesi Bu \u00f6rnekteki Global de\u011fi\u015fken $today de\u011fi\u015fkenidir. Constants (Sabitler) Sabit nedir? De\u011fi\u015ftirelemeyendir. Yani bu t\u00fcr de\u011fi\u015fkenler, ki bu de\u011fi\u015fken de\u011fildir :), sabit olarak adland\u0131r\u0131l\u0131r. Kural olarak mutlaka B\u00dcY\u00dcK HARF 'le ba\u015flar! Bazen de tamamen b\u00fcy\u00fck harflerden olu\u015fur. My_Age = 18 your_age = 22 puts defined? ( My_Age ) # constant puts defined? ( your_age ) # local-variable My_Age sabit, your_age de yerel de\u011fi\u015fken... Ruby'de ilgin\u00e7 bir durum daha var. Constant'lar mutable yani de\u011fi\u015ftirilebilir. Nas\u0131l yani? My_Age = 18 puts defined? ( My_Age ) # constant puts \"My_Age: #{ My_Age } \" # My_Age: 18 My_Age = 22 puts defined? ( My_Age ) # constant puts \"My_Age: #{ My_Age } \" # My_Age: 22 ama warning yani uyar\u0131 mesaj\u0131 ald\u0131k! untitled : 6 : warning : already initialized constant My_Age untitled : 1 : warning : previous definition of My_Age was here My_Age sabiti 6.sat\u0131rda zaten tan\u0131ml\u0131yd\u0131. \u00d6nceki de\u011feri de 1.sat\u0131rda diye bize ikaz etti Ruby yorumlay\u0131c\u0131s\u0131. Paralel Atama Hemen ne demek istedi\u011fimi bir \u00f6rnekle a\u00e7ay\u0131m: x , y , z = 5 , 11 , 88 puts x # 5 puts y # 11 puts z # 88 a , b , c = \"U\u011fur\" , 5 . 81 , 1972 puts a # U\u011fur puts b # 5.81 puts c # 1972 x, y, z = 5, 11, 88 derken tek harekette x = 5 , y = 11 ve z = 88 yapt\u0131k. \u0130\u015fte bu paralel atama. Instance Variable Instance dedi\u011fimiz \u015fey Class 'dan t\u00fcremi\u015f olan nesnedir. Bu konuyu detayl\u0131 olarak ileride inceleyece\u011fiz. Sadece \u00f6n bilgi olmas\u0131 ad\u0131na de\u011finiyorum. @ i\u015fareti ile ba\u015flarlar. class User attr_accessor :name def initialize ( name ) @name = name end def greet \"Merhaba #{ @name } \" end end u = User . new ( \"U\u011fur\" ) puts u . greet # Merhaba U\u011fur puts u . name # U\u011fur u.name diye \u00e7a\u011f\u0131rd\u0131\u011f\u0131m\u0131z \u015fey User class'\u0131ndan t\u00fcremi\u015f olan u nesnesinin Instance Variable '\u0131 yani t\u00fcremi\u015f nesneye ait de\u011fi\u015fkenidir. Fazla tak\u0131lmay\u0131n, Class konusunda bol bol de\u011finece\u011fiz... Class Variable Class 'a ait de\u011fi\u015fkendir. Dikkat edin burada t\u00fcreyen bir \u015fey yok. @@ ile ba\u015flar. Kullanmadan \u00f6nce bu de\u011fi\u015fkeni mutlaka init etmelisiniz ( Yani \u00f6n tan\u0131mlama yapmal\u0131s\u0131n\u0131z ) class User attr_accessor :name @@instance_count = 0 # Kullanmadan \u00f6nce init ettim def initialize ( name ) @name = name @@instance_count += 1 # Class'dan her instance olu\u015fmas\u0131nda sayac\u0131 1 artt\u0131r\u0131yorum end def greet \"Merhaba #{ @name } \" end def self . instance_count # buras\u0131 \u00f6neli @@instance_count end end user1 = User . new ( \"U\u011fur\" ) user2 = User . new ( \"Ezel\" ) user3 = User . new ( \"Ye\u015fim\" ) puts \"Ka\u00e7 defa User instance'\u0131 oldu? #{ User . instance_count } \" # Ka\u00e7 defa User instance'\u0131 oldu? 3 E\u011fer kafan\u0131z kar\u0131\u015ft\u0131ysa sorun de\u011fil, Class konusunda hepsinin \u00fczerinden tekrar ge\u00e7ece\u011fiz.","title":"De\u011fi\u015fkenler"},{"location":"bolum-02/02-degiskenler/#degiskenler","text":"De\u011fi\u015fken denen \u015fey, yani Variable , nesneye atanm\u0131\u015f bir i\u015faret\u00e7idir asl\u0131nda. Ne demi\u015ftik? Ruby'de her \u015fey bir nesne yani Object . Bu nesnelere eri\u015fmek i\u00e7in arac\u0131d\u0131r de\u011fi\u015fkenler. Farkl\u0131 farkl\u0131 t\u00fcrleri vard\u0131r. Birazdan bunlara de\u011finece\u011fiz. En basit anlamda de\u011fi\u015fken tan\u0131mlamak; a = 5 user_email = \"example@foo.com\" \u015feklinde olur. Yukar\u0131daki \u00f6rnekte a ve user_email de\u011fi\u015fkenin ad\u0131d\u0131r. De\u011feri ise e\u015fittir i\u015faretinden sonra gelendir. Yani yukar\u0131da; a ya say\u0131 olarak 5 ve user_email e metin olarak example@foo.com de\u011ferleri atanm\u0131\u015ft\u0131r. Ruby Duck Typing \u015feklinde \u00e7al\u0131\u015f\u0131r. Yani atama yapmadan \u00f6nce ne t\u00fcr bir de\u011fer atamas\u0131 yapaca\u011f\u0131m\u0131z\u0131 belirtmemize gerek yok. Ruby zaten a = 5 dedi\u011fimizde, \"Hmmm, bu de\u011fer Fixnum t\u00fcr\u00fcnde\" diye de\u011ferlendirir. Duck Typing demek \u015fudur; E\u011fer \u00f6rdek gibi y\u00fcr\u00fcyorsa, \u00f6rdek gibi ses \u00e7\u0131kart\u0131yorsa e o zaman bu bir \u00d6rdektir! \u0130ngilizcesi; When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck Yani, bir ku\u015f, e\u011fer \u00f6rdek gibi y\u00fcr\u00fcyorsa, \u00f6rdek gibi y\u00fcz\u00fcyorsa ve \u00f6rdek gibi ses \u00e7\u0131kar\u0131yorsa ben buna \u00d6rdek derim!","title":"De\u011fi\u015fkenler"},{"location":"bolum-02/02-degiskenler/#metinsel-atamalar-ve-trnak-kullanm","text":"Yeri gelmi\u015fken h\u0131zl\u0131ca bir konuya de\u011finmek istiyorum. Metinsel de\u011fi\u015fkenler tan\u0131mlarken ( String ) e\u015fitlik esnas\u0131nda tek ya da \u00e7ift t\u0131rnak i\u015fareti kullanabiliriz. Fakat aradaki fark\u0131 bilerek kullanmam\u0131z gerekir. String i\u00e7inde de\u011fi\u015fken kullan\u0131m\u0131 yapt\u0131\u011f\u0131m\u0131z zaman yani; a = 41 puts \"Siz tam #{ a } ya\u015f\u0131ndas\u0131n\u0131z\" gibi bir durumda, g\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi #{a} \u015feklinde yaz\u0131 i\u00e7inde de\u011fi\u015fken kulland\u0131k. Bu kodun \u00e7\u0131kt\u0131s\u0131 a\u015fa\u011f\u0131daki gibi olacak. Siz tam 41 ya\u015f\u0131ndas\u0131n\u0131z Format olarak Ruby'de, #{BU KISIMDA KOD \u00c7ALI\u015eIR} \u015feklinde istedi\u011fimiz kodu \u00e7al\u0131\u015ft\u0131rma yetkimiz var. Bu i\u015flem sadece \u00e7ift t\u0131rnak kullan\u0131m\u0131nda ge\u00e7erlidir. Ba\u015fka bir \u00f6rnek vermek gerekirse; a = 41 puts \"Siz tam #{ a + 2 } ya\u015f\u0131ndas\u0131n\u0131z\" Yukar\u0131daki \u00f6rnekte Ruby a+2 komutunu \u00e7al\u0131\u015ft\u0131racakt\u0131r ve sonu\u00e7 olarak 43 de\u011ferini bulacakt\u0131r ve bunu ekrana yazd\u0131racak. Yani sonu\u00e7: Siz tam 43 ya\u015f\u0131ndas\u0131n\u0131z \u015feklinde olacakt\u0131r. Ancak ayn\u0131 kodu tek t\u0131rnak kullanarak yapm\u0131\u015f olsayd\u0131k; a = 41 puts 'Siz tam #{ a } ya\u015f\u0131ndas\u0131n\u0131z' \u00e7\u0131kt\u0131s\u0131: Siz tam #{a} ya\u015f\u0131ndas\u0131n\u0131z olacakt\u0131. Tek t\u0131rnak i\u00e7inde bu i\u015flem \u00e7al\u0131\u015fmaz!","title":"Metinsel Atamalar ve T\u0131rnak Kullan\u0131m\u0131"},{"location":"bolum-02/02-degiskenler/#local-bolgesel","text":"B\u00f6lgesel ya da Yerel de\u011fi\u015fkenler, bir scope i\u00e7indeki de\u011fi\u015fkenlerdir. Scope nedir? Kodun \u00e7al\u0131\u015ft\u0131\u011f\u0131 b\u00f6lge olarak tan\u0131mlayabiliriz. Bu t\u00fcr de\u011fi\u015fkenler mutlaka k\u00fc\u00e7\u00fck harfle ya da _ ( underscore ) i\u015fareti ile ba\u015flamal\u0131d\u0131r. Kesinlike @ , @@ ya da $ i\u015fareti gibi \u00f6n ekler alamazlar. out_text = \"vigo\" def greet_user ( user_name ) out_text = \"Merhaba #{ user_name } \" end puts greet_user ( \"vigo\" ) # Merhaba vigo puts out_text # vigo Program \u00e7al\u0131\u015ft\u0131\u011f\u0131nda out_text de\u011fi\u015fkeninin de\u011feri vigo olarak atanmaktad\u0131r. Daha sonra 6. sat\u0131rda greet_user method'u ( fonksiyonu ) \u00e7al\u0131\u015ft\u0131\u011f\u0131nda, o methodun i\u00e7erisinde out_text de\u011fi\u015fkeninin de\u011feri de\u011fi\u015ftiriliyor gibi g\u00f6r\u00fcn\u00fcyor. Daha sonra 7. sat\u0131rda out_text de\u011fi\u015fkeninin de\u011feri puts methodu ile ekrana yazd\u0131r\u0131lmaktad\u0131r. Ancak burada \u00e7\u0131kt\u0131lara bakt\u0131\u011f\u0131n\u0131zda methodun i\u00e7erisindeki out_text de\u011fi\u015fkenindeki de\u011fi\u015fim, program\u0131n en ba\u015f\u0131nda tan\u0131mlad\u0131\u011f\u0131m\u0131z out_text de\u011fi\u015fkenin de\u011ferini etkilememi\u015ftir. Method i\u00e7erisinde kalm\u0131\u015ft\u0131r. Burada method i\u00e7erisindeki out_text de\u011fi\u015fkeni asl\u0131nda local variable yani yerel de\u011fi\u015fken \u015feklinde \u00e7al\u0131\u015fmaktad\u0131r.","title":"Local (B\u00f6lgesel)"},{"location":"bolum-02/02-degiskenler/#global-genel","text":"$ i\u015faretiyle ba\u015flayan t\u00fcm de\u011fi\u015fkenler Global de\u011fi\u015fkenlerdir. Kodun herhangi bir yerinde kullan\u0131labilir ve eri\u015filebilir. $today = \"Pazartesi\" def greet_user ( user_name ) out_text = \"Merhaba #{ user_name } , bug\u00fcn #{ $today } \" puts out_text end puts \"Bug\u00fcn g\u00fcnlerden ne? #{ $today } \" greet_user ( \"vigo\" ) # Merhaba vigo, bug\u00fcn Pazartesi Bu \u00f6rnekteki Global de\u011fi\u015fken $today de\u011fi\u015fkenidir.","title":"Global (Genel)"},{"location":"bolum-02/02-degiskenler/#constants-sabitler","text":"Sabit nedir? De\u011fi\u015ftirelemeyendir. Yani bu t\u00fcr de\u011fi\u015fkenler, ki bu de\u011fi\u015fken de\u011fildir :), sabit olarak adland\u0131r\u0131l\u0131r. Kural olarak mutlaka B\u00dcY\u00dcK HARF 'le ba\u015flar! Bazen de tamamen b\u00fcy\u00fck harflerden olu\u015fur. My_Age = 18 your_age = 22 puts defined? ( My_Age ) # constant puts defined? ( your_age ) # local-variable My_Age sabit, your_age de yerel de\u011fi\u015fken... Ruby'de ilgin\u00e7 bir durum daha var. Constant'lar mutable yani de\u011fi\u015ftirilebilir. Nas\u0131l yani? My_Age = 18 puts defined? ( My_Age ) # constant puts \"My_Age: #{ My_Age } \" # My_Age: 18 My_Age = 22 puts defined? ( My_Age ) # constant puts \"My_Age: #{ My_Age } \" # My_Age: 22 ama warning yani uyar\u0131 mesaj\u0131 ald\u0131k! untitled : 6 : warning : already initialized constant My_Age untitled : 1 : warning : previous definition of My_Age was here My_Age sabiti 6.sat\u0131rda zaten tan\u0131ml\u0131yd\u0131. \u00d6nceki de\u011feri de 1.sat\u0131rda diye bize ikaz etti Ruby yorumlay\u0131c\u0131s\u0131.","title":"Constants (Sabitler)"},{"location":"bolum-02/02-degiskenler/#paralel-atama","text":"Hemen ne demek istedi\u011fimi bir \u00f6rnekle a\u00e7ay\u0131m: x , y , z = 5 , 11 , 88 puts x # 5 puts y # 11 puts z # 88 a , b , c = \"U\u011fur\" , 5 . 81 , 1972 puts a # U\u011fur puts b # 5.81 puts c # 1972 x, y, z = 5, 11, 88 derken tek harekette x = 5 , y = 11 ve z = 88 yapt\u0131k. \u0130\u015fte bu paralel atama.","title":"Paralel Atama"},{"location":"bolum-02/02-degiskenler/#instance-variable","text":"Instance dedi\u011fimiz \u015fey Class 'dan t\u00fcremi\u015f olan nesnedir. Bu konuyu detayl\u0131 olarak ileride inceleyece\u011fiz. Sadece \u00f6n bilgi olmas\u0131 ad\u0131na de\u011finiyorum. @ i\u015fareti ile ba\u015flarlar. class User attr_accessor :name def initialize ( name ) @name = name end def greet \"Merhaba #{ @name } \" end end u = User . new ( \"U\u011fur\" ) puts u . greet # Merhaba U\u011fur puts u . name # U\u011fur u.name diye \u00e7a\u011f\u0131rd\u0131\u011f\u0131m\u0131z \u015fey User class'\u0131ndan t\u00fcremi\u015f olan u nesnesinin Instance Variable '\u0131 yani t\u00fcremi\u015f nesneye ait de\u011fi\u015fkenidir. Fazla tak\u0131lmay\u0131n, Class konusunda bol bol de\u011finece\u011fiz...","title":"Instance Variable"},{"location":"bolum-02/02-degiskenler/#class-variable","text":"Class 'a ait de\u011fi\u015fkendir. Dikkat edin burada t\u00fcreyen bir \u015fey yok. @@ ile ba\u015flar. Kullanmadan \u00f6nce bu de\u011fi\u015fkeni mutlaka init etmelisiniz ( Yani \u00f6n tan\u0131mlama yapmal\u0131s\u0131n\u0131z ) class User attr_accessor :name @@instance_count = 0 # Kullanmadan \u00f6nce init ettim def initialize ( name ) @name = name @@instance_count += 1 # Class'dan her instance olu\u015fmas\u0131nda sayac\u0131 1 artt\u0131r\u0131yorum end def greet \"Merhaba #{ @name } \" end def self . instance_count # buras\u0131 \u00f6neli @@instance_count end end user1 = User . new ( \"U\u011fur\" ) user2 = User . new ( \"Ezel\" ) user3 = User . new ( \"Ye\u015fim\" ) puts \"Ka\u00e7 defa User instance'\u0131 oldu? #{ User . instance_count } \" # Ka\u00e7 defa User instance'\u0131 oldu? 3 E\u011fer kafan\u0131z kar\u0131\u015ft\u0131ysa sorun de\u011fil, Class konusunda hepsinin \u00fczerinden tekrar ge\u00e7ece\u011fiz.","title":"Class Variable"},{"location":"bolum-02/03-on-tanimli-degiskenler/","text":"\u00d6n Tan\u0131ml\u0131 De\u011fi\u015fkenler Ruby, bir k\u0131s\u0131m \u00f6n tan\u0131ml\u0131 yani Predefined de\u011fi\u015fkenlerle geliyor. De\u011fi\u015fkenlerin ne oldu\u011funu; puts global_variables \u015feklinde g\u00f6rebiliriz. \u00d6nden bu bilgileri vermek zorunday\u0131m, daha geni\u015f kullan\u0131m\u0131 ve tam olarak ne i\u015fe yarad\u0131klar\u0131n\u0131 ileriki b\u00f6l\u00fcmlerde daha iyi anlayacaks\u0131n\u0131z. De\u011fi\u015fken A\u00e7\u0131klama $! raise ile atanan exception bilgisidir. rescue ile eri\u015filir. $@ Son exception 'a ait backtrace ( bir t\u00fcr log ) bilgilerinin tutuldu\u011fu dizi ( Array ) $& Son yakalanan match 'in tutuldu\u011fu String ( Regex konusunda g\u00f6rece\u011fiz ) $` Son yakalanan match 'in solunda kalan k\u0131s\u0131m $' Son yakalanan match 'in sa\u011f\u0131nda kalan k\u0131s\u0131m $+ En y\u00fcksek group match 'in tutuldu\u011fu yer. ( Regex yaparken group yakalama konusunda g\u00f6rece\u011fiz ) $1, $2, ..., $9 Yine, Regex ile patern yakalama ( pattern matching ) yapt\u0131\u011f\u0131m\u0131zda, yakalad\u0131\u011f\u0131m\u0131z \u015feylerin s\u0131ra numaras\u0131. $~ O anki kapsama alan\u0131nda ( scope ) son yakalananla ilgili bilgilerin tutuldu\u011fu de\u011fi\u015fken $= Regex ile u\u011fra\u015f\u0131rken, karakterlerin b\u00fcy\u00fck/k\u00fc\u00e7\u00fck harfe duyarl\u0131l\u0131\u011f\u0131 ile ilgi ayarlar vard\u0131r. \u00d6rne\u011fin b\u00fcy\u00fck/k\u00fc\u00e7\u00fck harf fark\u0131 olmadan aramak yaparken ( case insensitive ) bu de\u011fi\u015fkene atama yapar\u0131z. Varsay\u0131lan de\u011fer ( default ) nil 'dir $/ Dosyadan okuma yap\u0131l\u0131rken sat\u0131rlar\u0131n nas\u0131l ayr\u0131ld\u0131\u011f\u0131n\u0131n tespit edildi\u011fi de\u011fi\u015fkendir. E\u011fer nil olarak atarn\u0131rsa, dosya okumas\u0131 esnas\u0131nda sat\u0131r-sat\u0131r okuma yerine t\u00fcm dosya bir anda okunur. $\\ Bu da \u00e7\u0131kt\u0131 i\u00e7in ayra\u00e7t\u0131r. print ve puts gibi komutlarda IO#write gibi i\u015flemlerde kullan\u0131l\u0131r. Varsay\u0131lan de\u011fer nil 'dir $, print ve Array#join de kullan\u0131lan ayra\u00e7t\u0131r. $; String#split de kullan\u0131lan ayra\u00e7t\u0131r. $. Dosya i\u015flemlerinde son okunan dosyan\u0131n aktif sat\u0131r numaras\u0131n\u0131 verir. $< Ayn\u0131 shell deki ekleme ( concatenation ) i\u015flemi gibi sanal ekleme yapar. $> print ve printf i\u015flemi i\u00e7in varsay\u0131lan \u00e7\u0131kt\u0131d\u0131r. Varsay\u0131lan de\u011feri de $stdout $_ gets veya readline ile al\u0131nan son sat\u0131rd\u0131r, cinsi String 'dir. $0 \u00c7al\u0131\u015ft\u0131r\u0131lan script'in dosya ad\u0131d\u0131r. $* Komut sat\u0131r\u0131 i\u015flemlerinde, dosyaya ge\u00e7ilen arg\u00fcmanlar\u0131n sakland\u0131\u011f\u0131 de\u011fi\u015fkendir. $$ \u00c7al\u0131\u015ft\u0131r\u0131lan script'in i\u015flem numaras\u0131 ( Process Number ) $? \u00c7al\u0131\u015ft\u0131r\u0131lan son alt i\u015flemin ( Child Process ) durumu. $: Mod\u00fcller ve ek dosyalar i\u00e7in Path (_Load Path__) bilgisi. require komutunda g\u00f6rece\u011fiz. $\" require ile y\u00fcklenen dosyalar\u0131n adlar\u0131n\u0131n tutuldu\u011fu dizi ( Array ) $DEBUG Ad\u0131ndan da anla\u015f\u0131ld\u0131\u011f\u0131 gibi, e\u011fer DEBUG modda \u00e7al\u0131\u015ft\u0131rma yap\u0131yorsak ( ki bunu -d ile yapar\u0131z ) olu\u015fan her exception '\u0131n $stderr de\u011fi\u015fkenine atanmas\u0131n\u0131 sa\u011flar. $KCODE Kod yazd\u0131\u011f\u0131m\u0131z script dosyas\u0131n\u0131n encoding tipini se\u00e7memize yarar. Son s\u00fcr\u00fcmlerde ihtiya\u00e7 kalmad\u0131, her \u015fey default olarak UTF-8 \u00e7al\u0131\u015f\u0131yor. $FILENAME Komut sat\u0131r\u0131ndan arg\u00fcman olarak dosya ge\u00e7ti\u011fimizde ge\u00e7ilen dosyan\u0131n ad\u0131n\u0131 almak i\u00e7in kullan\u0131l\u0131r. Asl\u0131nda ARGF.filename ile ayn\u0131 i\u015fi yapar. $LOAD_PATH $: ile ayn\u0131 i\u015fi yapan alias 'd\u0131r ( alias = takma ad ) $SAFE G\u00fcvenlik seviyesidir. Varsay\u0131lan de\u011fer 0 d\u0131r. Bu dereceler 0'dan 4'e kadard\u0131r. Kod g\u00fcvenli\u011fi ve kilitleme yapmak i\u00e7in kullan\u0131l\u0131r. Biraz karma\u015f\u0131k bir konudur :) \u00d6rne\u011fin, emin olmad\u0131\u011f\u0131n\u0131z bir k\u00fct\u00fcphane kullan\u0131rken kodunuzu g\u00fcvenli hale getirmek i\u00e7in, kod blo\u011funun \u00f6n\u00fcne $SAFE=4 ekerseniz, takip eden kod array hash ve string lerde hi\u00e7 bir modifikasyon yapamaz! Hatta pek \u00e7ok \u015feyi yapamaz! $stdin Standart giri\u015f. $stdout Standart \u00e7\u0131k\u0131\u015f. $stderr Giri\u015f/\u00c7\u0131k\u0131\u015f hata bildirimi. $VERBOSE Kernel taraf\u0131ndan \u00fcretilen t\u00fcm uyar\u0131 mesajlar\u0131n\u0131n ( warning gibi... ) g\u00f6r\u00fcnt\u00fclenmesi i\u00e7in kullan\u0131l\u0131r. $-0 $/ ile ayn\u0131 i\u015fi yapar. $-a Komut sat\u0131r\u0131ndan \u00e7al\u0131\u015ft\u0131rma yaparkan -a atamas\u0131 yap\u0131lm\u0131\u015fsa $-a true d\u00f6ner. $-d $DEBUG ile ayn\u0131 i\u015fi yapar. $-F $; ile ayn\u0131 i\u015fi yapar. $-i Bu de\u011fi\u015fken in-place-edit modda extension '\u0131 saklar. $-I $: ile ayn\u0131 i\u015fi yapar. ( B\u00fcy\u00fck i ) $-l E\u011fer -lis set edilmi\u015fse true d\u00f6ner. Read Only yani sadece okunur, de\u011feri de\u011fi\u015ftirilemez! ( K\u00fc\u00e7\u00fck l ) $-p E\u011fer -pis set edilmi\u015fse true d\u00f6ner. Read Only yani sadece okunur, de\u011feri de\u011fi\u015ftirilemez! $-K $KCODE ile ayn\u0131 i\u015fi yapar. $-v $VERBOSE ile ayn\u0131 i\u015fi yapar. $-w E\u011fer -w set edilmi\u015fse true d\u00f6ner. $-W Warning Level yani olu\u015fabilecek hatalar vs ile ilgili 0, 1 ya da 2.seviyede uyar\u0131 mesajlar\u0131 g\u00f6stermek i\u00e7in. $LOADED_FEATURES $\" ile ayn\u0131 i\u015fi yapar. $PROGRAM_NAME $0 ile ayn\u0131 i\u015fi yapar. Pseudo (Ger\u00e7ek Olmayan) De\u011fi\u015fkenler De\u011fi\u015fken ( Variable ) gibi g\u00f6r\u00fcnen ama Sabit ( Constant ) gibi davranan ve kesinlikle de\u011fer atamas\u0131 yap\u0131lamayan \u015feylerdir. De\u011fi\u015fken A\u00e7\u0131klama self Al\u0131c\u0131 nesnenin o anki aktif method\u2019u. Yani bu bir Class ise kendisi... nil Tan\u0131m\u0131 olmayan ( Undefined ) \u015feylerin de\u011feri. true Mant\u0131ksal ( Boolean ) i\u015flem, anlayaca\u011f\u0131n\u0131z gibi true yani 1 false true 'nun tersi ( Boolean ) yani 0 __FILE__ \u00c7al\u0131\u015fan kaynak kod dosyas\u0131n\u0131n ad\u0131 __LINE__ \u00c7al\u0131\u015fan kaynak kod dosyas\u0131ndaki, o anki aktif sat\u0131r\u0131n numaras\u0131","title":"\u00d6n Tan\u0131ml\u0131 De\u011fi\u015fkenler"},{"location":"bolum-02/03-on-tanimli-degiskenler/#on-tanml-degiskenler","text":"Ruby, bir k\u0131s\u0131m \u00f6n tan\u0131ml\u0131 yani Predefined de\u011fi\u015fkenlerle geliyor. De\u011fi\u015fkenlerin ne oldu\u011funu; puts global_variables \u015feklinde g\u00f6rebiliriz. \u00d6nden bu bilgileri vermek zorunday\u0131m, daha geni\u015f kullan\u0131m\u0131 ve tam olarak ne i\u015fe yarad\u0131klar\u0131n\u0131 ileriki b\u00f6l\u00fcmlerde daha iyi anlayacaks\u0131n\u0131z. De\u011fi\u015fken A\u00e7\u0131klama $! raise ile atanan exception bilgisidir. rescue ile eri\u015filir. $@ Son exception 'a ait backtrace ( bir t\u00fcr log ) bilgilerinin tutuldu\u011fu dizi ( Array ) $& Son yakalanan match 'in tutuldu\u011fu String ( Regex konusunda g\u00f6rece\u011fiz ) $` Son yakalanan match 'in solunda kalan k\u0131s\u0131m $' Son yakalanan match 'in sa\u011f\u0131nda kalan k\u0131s\u0131m $+ En y\u00fcksek group match 'in tutuldu\u011fu yer. ( Regex yaparken group yakalama konusunda g\u00f6rece\u011fiz ) $1, $2, ..., $9 Yine, Regex ile patern yakalama ( pattern matching ) yapt\u0131\u011f\u0131m\u0131zda, yakalad\u0131\u011f\u0131m\u0131z \u015feylerin s\u0131ra numaras\u0131. $~ O anki kapsama alan\u0131nda ( scope ) son yakalananla ilgili bilgilerin tutuldu\u011fu de\u011fi\u015fken $= Regex ile u\u011fra\u015f\u0131rken, karakterlerin b\u00fcy\u00fck/k\u00fc\u00e7\u00fck harfe duyarl\u0131l\u0131\u011f\u0131 ile ilgi ayarlar vard\u0131r. \u00d6rne\u011fin b\u00fcy\u00fck/k\u00fc\u00e7\u00fck harf fark\u0131 olmadan aramak yaparken ( case insensitive ) bu de\u011fi\u015fkene atama yapar\u0131z. Varsay\u0131lan de\u011fer ( default ) nil 'dir $/ Dosyadan okuma yap\u0131l\u0131rken sat\u0131rlar\u0131n nas\u0131l ayr\u0131ld\u0131\u011f\u0131n\u0131n tespit edildi\u011fi de\u011fi\u015fkendir. E\u011fer nil olarak atarn\u0131rsa, dosya okumas\u0131 esnas\u0131nda sat\u0131r-sat\u0131r okuma yerine t\u00fcm dosya bir anda okunur. $\\ Bu da \u00e7\u0131kt\u0131 i\u00e7in ayra\u00e7t\u0131r. print ve puts gibi komutlarda IO#write gibi i\u015flemlerde kullan\u0131l\u0131r. Varsay\u0131lan de\u011fer nil 'dir $, print ve Array#join de kullan\u0131lan ayra\u00e7t\u0131r. $; String#split de kullan\u0131lan ayra\u00e7t\u0131r. $. Dosya i\u015flemlerinde son okunan dosyan\u0131n aktif sat\u0131r numaras\u0131n\u0131 verir. $< Ayn\u0131 shell deki ekleme ( concatenation ) i\u015flemi gibi sanal ekleme yapar. $> print ve printf i\u015flemi i\u00e7in varsay\u0131lan \u00e7\u0131kt\u0131d\u0131r. Varsay\u0131lan de\u011feri de $stdout $_ gets veya readline ile al\u0131nan son sat\u0131rd\u0131r, cinsi String 'dir. $0 \u00c7al\u0131\u015ft\u0131r\u0131lan script'in dosya ad\u0131d\u0131r. $* Komut sat\u0131r\u0131 i\u015flemlerinde, dosyaya ge\u00e7ilen arg\u00fcmanlar\u0131n sakland\u0131\u011f\u0131 de\u011fi\u015fkendir. $$ \u00c7al\u0131\u015ft\u0131r\u0131lan script'in i\u015flem numaras\u0131 ( Process Number ) $? \u00c7al\u0131\u015ft\u0131r\u0131lan son alt i\u015flemin ( Child Process ) durumu. $: Mod\u00fcller ve ek dosyalar i\u00e7in Path (_Load Path__) bilgisi. require komutunda g\u00f6rece\u011fiz. $\" require ile y\u00fcklenen dosyalar\u0131n adlar\u0131n\u0131n tutuldu\u011fu dizi ( Array ) $DEBUG Ad\u0131ndan da anla\u015f\u0131ld\u0131\u011f\u0131 gibi, e\u011fer DEBUG modda \u00e7al\u0131\u015ft\u0131rma yap\u0131yorsak ( ki bunu -d ile yapar\u0131z ) olu\u015fan her exception '\u0131n $stderr de\u011fi\u015fkenine atanmas\u0131n\u0131 sa\u011flar. $KCODE Kod yazd\u0131\u011f\u0131m\u0131z script dosyas\u0131n\u0131n encoding tipini se\u00e7memize yarar. Son s\u00fcr\u00fcmlerde ihtiya\u00e7 kalmad\u0131, her \u015fey default olarak UTF-8 \u00e7al\u0131\u015f\u0131yor. $FILENAME Komut sat\u0131r\u0131ndan arg\u00fcman olarak dosya ge\u00e7ti\u011fimizde ge\u00e7ilen dosyan\u0131n ad\u0131n\u0131 almak i\u00e7in kullan\u0131l\u0131r. Asl\u0131nda ARGF.filename ile ayn\u0131 i\u015fi yapar. $LOAD_PATH $: ile ayn\u0131 i\u015fi yapan alias 'd\u0131r ( alias = takma ad ) $SAFE G\u00fcvenlik seviyesidir. Varsay\u0131lan de\u011fer 0 d\u0131r. Bu dereceler 0'dan 4'e kadard\u0131r. Kod g\u00fcvenli\u011fi ve kilitleme yapmak i\u00e7in kullan\u0131l\u0131r. Biraz karma\u015f\u0131k bir konudur :) \u00d6rne\u011fin, emin olmad\u0131\u011f\u0131n\u0131z bir k\u00fct\u00fcphane kullan\u0131rken kodunuzu g\u00fcvenli hale getirmek i\u00e7in, kod blo\u011funun \u00f6n\u00fcne $SAFE=4 ekerseniz, takip eden kod array hash ve string lerde hi\u00e7 bir modifikasyon yapamaz! Hatta pek \u00e7ok \u015feyi yapamaz! $stdin Standart giri\u015f. $stdout Standart \u00e7\u0131k\u0131\u015f. $stderr Giri\u015f/\u00c7\u0131k\u0131\u015f hata bildirimi. $VERBOSE Kernel taraf\u0131ndan \u00fcretilen t\u00fcm uyar\u0131 mesajlar\u0131n\u0131n ( warning gibi... ) g\u00f6r\u00fcnt\u00fclenmesi i\u00e7in kullan\u0131l\u0131r. $-0 $/ ile ayn\u0131 i\u015fi yapar. $-a Komut sat\u0131r\u0131ndan \u00e7al\u0131\u015ft\u0131rma yaparkan -a atamas\u0131 yap\u0131lm\u0131\u015fsa $-a true d\u00f6ner. $-d $DEBUG ile ayn\u0131 i\u015fi yapar. $-F $; ile ayn\u0131 i\u015fi yapar. $-i Bu de\u011fi\u015fken in-place-edit modda extension '\u0131 saklar. $-I $: ile ayn\u0131 i\u015fi yapar. ( B\u00fcy\u00fck i ) $-l E\u011fer -lis set edilmi\u015fse true d\u00f6ner. Read Only yani sadece okunur, de\u011feri de\u011fi\u015ftirilemez! ( K\u00fc\u00e7\u00fck l ) $-p E\u011fer -pis set edilmi\u015fse true d\u00f6ner. Read Only yani sadece okunur, de\u011feri de\u011fi\u015ftirilemez! $-K $KCODE ile ayn\u0131 i\u015fi yapar. $-v $VERBOSE ile ayn\u0131 i\u015fi yapar. $-w E\u011fer -w set edilmi\u015fse true d\u00f6ner. $-W Warning Level yani olu\u015fabilecek hatalar vs ile ilgili 0, 1 ya da 2.seviyede uyar\u0131 mesajlar\u0131 g\u00f6stermek i\u00e7in. $LOADED_FEATURES $\" ile ayn\u0131 i\u015fi yapar. $PROGRAM_NAME $0 ile ayn\u0131 i\u015fi yapar.","title":"\u00d6n Tan\u0131ml\u0131 De\u011fi\u015fkenler"},{"location":"bolum-02/03-on-tanimli-degiskenler/#pseudo-gercek-olmayan-degiskenler","text":"De\u011fi\u015fken ( Variable ) gibi g\u00f6r\u00fcnen ama Sabit ( Constant ) gibi davranan ve kesinlikle de\u011fer atamas\u0131 yap\u0131lamayan \u015feylerdir. De\u011fi\u015fken A\u00e7\u0131klama self Al\u0131c\u0131 nesnenin o anki aktif method\u2019u. Yani bu bir Class ise kendisi... nil Tan\u0131m\u0131 olmayan ( Undefined ) \u015feylerin de\u011feri. true Mant\u0131ksal ( Boolean ) i\u015flem, anlayaca\u011f\u0131n\u0131z gibi true yani 1 false true 'nun tersi ( Boolean ) yani 0 __FILE__ \u00c7al\u0131\u015fan kaynak kod dosyas\u0131n\u0131n ad\u0131 __LINE__ \u00c7al\u0131\u015fan kaynak kod dosyas\u0131ndaki, o anki aktif sat\u0131r\u0131n numaras\u0131","title":"Pseudo (Ger\u00e7ek Olmayan) De\u011fi\u015fkenler"},{"location":"bolum-02/04-operatorler/","text":"Operat\u00f6rler Operat\u00f6rler \u00e7e\u015fitli kontrolleri yapmak i\u00e7in kullan\u0131l\u0131r. Hatta baz\u0131lar\u0131 ayn\u0131 zamanda method olarak \u00e7al\u0131\u015f\u0131r. Baz\u0131 operat\u00f6rlerin birden farkl\u0131 i\u015flemi vard\u0131r. \u00d6rne\u011fin + hem matematik i\u015flemi olan toplama i\u00e7in hem de pozitif de\u011fer kontrol\u00fc i\u00e7in kullan\u0131labilir. Operat\u00f6r A\u00e7\u0131klama Method mu? :: \u0130ki tane iki nokta. Scope resolution anlam\u0131ndad\u0131r. Class ve Mod\u00fcl konusunda detaylar\u0131 g\u00f6rece\u011fiz. [] Referans, set Evet []= Referans, set Evet ** \u00dcss\u00fc, kuvveti Evet + Pozitif Evet - Negatif Evet ! Mant\u0131ksal uzla\u015fma ~ Tamamlay\u0131c\u0131 Evet * \u00c7arpma Evet / B\u00f6lme Evet % Mod\u00fclo ( Kalan ) Evet + Ekleme Evet - \u00c7\u0131kartma Evet << Sola kayd\u0131r Evet >> Sa\u011fa kayd\u0131r Evet & Bit seviyesinde and ( Ve ) i\u015flemi Evet | Bit seviyesinde or ( Veya ) i\u015flemi Evet ^ Bit seviyesinde exclusive or ( Veya'n\u0131n tersi gibi ) i\u015flemi Evet > B\u00fcy\u00fckt\u00fcr Evet >= B\u00fcy\u00fck ve e\u015fit Evet < K\u00fc\u00e7\u00fckt\u00fcr Evet <= K\u00fc\u00e7\u00fck ve e\u015fit Evet <=> E\u015fitlik kar\u015f\u0131la\u015ft\u0131rma operat\u00f6r\u00fc ( Spaceship yani uzay gemisi ) Evet == E\u015fitlik Evet === Denklik Evet != E\u015fit de\u011fil !~ Yakalanmayan ( not match ) =~ Yakalanan ( match ) Evet && Mant\u0131ksal ve ( and ) || Mant\u0131ksal veya ( or ) .. Range'i kapsayan Evet ... Range'i kapsamayan ? : Ternary = Atama += Artt\u0131rma ve atama -= Eksiltme ve tama *= \u00c7arpma ve atama /= B\u00f6lme ve atama %= Mod\u00fclo ve atama **= \u00dcss\u00fc ve atama <<= Bit seviyesinde sola kayd\u0131rma ve atama >>= Bit seviyesinde sa\u011fa kayd\u0131rma ve atama &= Bit seviyesinde and ve atma |= Bit seviyesinde or ve atama ^= Bit seviyesinde eor ve atama &&= Mant\u0131ksal and ve atama ||= Varl\u0131k atamas\u0131 ( Existential Operator ) \u0130lk bak\u0131\u015fta insan\u0131n akl\u0131n\u0131 durduran bir s\u00fcr\u00fc garip i\u015faretler bunlar de\u011fil mi? Hemen \u00f6rneklerle peki\u015ftirelim. a = [] a . class # => Array a . length # => 0 []= Kullan\u0131m \u00d6rne\u011fi a = [] # Bu bir dizi / Array a . []= 5 , \"Merhaba\" # 0 indekli, 5.eleman Merhaba olsun p a # [nil, nil, nil, nil, nil, \"Merhaba\"] Unary Operat\u00f6rleri Unary demek, += , -= , *= gibi i\u015flemleri yapt\u0131\u011f\u0131m\u0131z operat\u00f6rler. Yani x+= 5 dedi\u011fimizde ( x'in de\u011ferine 5 ekle ve sonucu tekrar x'e ata ) asl\u0131nda Unary operat\u00f6r\u00fc kullanm\u0131\u015f oluruz. Keza, a\u015fa\u011f\u0131daki \u00f6rnekteki gibi kullan\u0131mlarda ek fayda sa\u011flam\u0131\u015f oluruz: str = \"Merhaba D\u00fcnya\" class String def -@ reverse end end p str # \"Merhaba D\u00fcnya\" p - str # \"ayn\u00fcD abahreM\"","title":"Operat\u00f6rler"},{"location":"bolum-02/04-operatorler/#operatorler","text":"Operat\u00f6rler \u00e7e\u015fitli kontrolleri yapmak i\u00e7in kullan\u0131l\u0131r. Hatta baz\u0131lar\u0131 ayn\u0131 zamanda method olarak \u00e7al\u0131\u015f\u0131r. Baz\u0131 operat\u00f6rlerin birden farkl\u0131 i\u015flemi vard\u0131r. \u00d6rne\u011fin + hem matematik i\u015flemi olan toplama i\u00e7in hem de pozitif de\u011fer kontrol\u00fc i\u00e7in kullan\u0131labilir. Operat\u00f6r A\u00e7\u0131klama Method mu? :: \u0130ki tane iki nokta. Scope resolution anlam\u0131ndad\u0131r. Class ve Mod\u00fcl konusunda detaylar\u0131 g\u00f6rece\u011fiz. [] Referans, set Evet []= Referans, set Evet ** \u00dcss\u00fc, kuvveti Evet + Pozitif Evet - Negatif Evet ! Mant\u0131ksal uzla\u015fma ~ Tamamlay\u0131c\u0131 Evet * \u00c7arpma Evet / B\u00f6lme Evet % Mod\u00fclo ( Kalan ) Evet + Ekleme Evet - \u00c7\u0131kartma Evet << Sola kayd\u0131r Evet >> Sa\u011fa kayd\u0131r Evet & Bit seviyesinde and ( Ve ) i\u015flemi Evet | Bit seviyesinde or ( Veya ) i\u015flemi Evet ^ Bit seviyesinde exclusive or ( Veya'n\u0131n tersi gibi ) i\u015flemi Evet > B\u00fcy\u00fckt\u00fcr Evet >= B\u00fcy\u00fck ve e\u015fit Evet < K\u00fc\u00e7\u00fckt\u00fcr Evet <= K\u00fc\u00e7\u00fck ve e\u015fit Evet <=> E\u015fitlik kar\u015f\u0131la\u015ft\u0131rma operat\u00f6r\u00fc ( Spaceship yani uzay gemisi ) Evet == E\u015fitlik Evet === Denklik Evet != E\u015fit de\u011fil !~ Yakalanmayan ( not match ) =~ Yakalanan ( match ) Evet && Mant\u0131ksal ve ( and ) || Mant\u0131ksal veya ( or ) .. Range'i kapsayan Evet ... Range'i kapsamayan ? : Ternary = Atama += Artt\u0131rma ve atama -= Eksiltme ve tama *= \u00c7arpma ve atama /= B\u00f6lme ve atama %= Mod\u00fclo ve atama **= \u00dcss\u00fc ve atama <<= Bit seviyesinde sola kayd\u0131rma ve atama >>= Bit seviyesinde sa\u011fa kayd\u0131rma ve atama &= Bit seviyesinde and ve atma |= Bit seviyesinde or ve atama ^= Bit seviyesinde eor ve atama &&= Mant\u0131ksal and ve atama ||= Varl\u0131k atamas\u0131 ( Existential Operator ) \u0130lk bak\u0131\u015fta insan\u0131n akl\u0131n\u0131 durduran bir s\u00fcr\u00fc garip i\u015faretler bunlar de\u011fil mi? Hemen \u00f6rneklerle peki\u015ftirelim. a = [] a . class # => Array a . length # => 0","title":"Operat\u00f6rler"},{"location":"bolum-02/04-operatorler/#kullanm-ornegi","text":"a = [] # Bu bir dizi / Array a . []= 5 , \"Merhaba\" # 0 indekli, 5.eleman Merhaba olsun p a # [nil, nil, nil, nil, nil, \"Merhaba\"]","title":"[]= Kullan\u0131m \u00d6rne\u011fi"},{"location":"bolum-02/04-operatorler/#unary-operatorleri","text":"Unary demek, += , -= , *= gibi i\u015flemleri yapt\u0131\u011f\u0131m\u0131z operat\u00f6rler. Yani x+= 5 dedi\u011fimizde ( x'in de\u011ferine 5 ekle ve sonucu tekrar x'e ata ) asl\u0131nda Unary operat\u00f6r\u00fc kullanm\u0131\u015f oluruz. Keza, a\u015fa\u011f\u0131daki \u00f6rnekteki gibi kullan\u0131mlarda ek fayda sa\u011flam\u0131\u015f oluruz: str = \"Merhaba D\u00fcnya\" class String def -@ reverse end end p str # \"Merhaba D\u00fcnya\" p - str # \"ayn\u00fcD abahreM\"","title":"Unary Operat\u00f6rleri"},{"location":"bolum-02/05-global-constants-genel-sabitler/","text":"Global Constants (Genel Sabitler) Ruby, \u00f6n tan\u0131ml\u0131 olarak \u00e7e\u015fitli sabitlerle birlikte geliyor. Ben an itibariyle Mac OSX \u00fczerinde, rbenv ile ruby 2.1.0 kullan\u0131yorum. Bu ba\u011flamda sizin kulland\u0131\u011f\u0131n\u0131z Ruby versiyonuna g\u00f6re de\u011fi\u015fkenlikler olabilir. Sabit De\u011feri TRUE Anla\u015f\u0131laca\u011f\u0131 gibi bu true de\u011feri FALSE Bu da false de\u011feri NIL nil STDIN Standart giri\u015f. $stdin i\u00e7in varsay\u0131lan de\u011fer. STDOUT Standart \u00e7\u0131k\u0131\u015f. $stdout i\u00e7in varsay\u0131lan de\u011fer. STDERR Standart hata. $stderr i\u00e7in varsay\u0131lan de\u011fer. ENV Aktif \u00e7evre de\u011fi\u015fkenlerinin ( Environment Variables ) bulundu\u011fu Hash ARGF $< ile ayn\u0131 i\u015fi yap\u0131yor. ARGV $* ile ayn\u0131 i\u015fi yap\u0131yor. DATA Herhangi bir Ruby script dosyas\u0131nda, __END__ sonras\u0131na yaz\u0131lan \u015feylerin sakland\u0131\u011f\u0131 de\u011fi\u015fken. RUBY_VERSION \"2.1.0\" RUBY_RELEASE_DATE \"2013-12-25\" RUBY_PLATFORM \"x86_64-darwin13.0\" RUBY_COPYRIGHT \"ruby - Copyright (C) 1993-2013 Yukihiro Matsumoto\" RUBY_DESCRIPTION \"ruby 2.1.0p0 (2013-12-25 revision 44422) [x86_64-darwin13.0]\" RUBY_ENGINE \"ruby\" RUBY_PATCHLEVEL \"0\" RUBY_REVISION 44422","title":"Genel Sabitler"},{"location":"bolum-02/05-global-constants-genel-sabitler/#global-constants-genel-sabitler","text":"Ruby, \u00f6n tan\u0131ml\u0131 olarak \u00e7e\u015fitli sabitlerle birlikte geliyor. Ben an itibariyle Mac OSX \u00fczerinde, rbenv ile ruby 2.1.0 kullan\u0131yorum. Bu ba\u011flamda sizin kulland\u0131\u011f\u0131n\u0131z Ruby versiyonuna g\u00f6re de\u011fi\u015fkenlikler olabilir. Sabit De\u011feri TRUE Anla\u015f\u0131laca\u011f\u0131 gibi bu true de\u011feri FALSE Bu da false de\u011feri NIL nil STDIN Standart giri\u015f. $stdin i\u00e7in varsay\u0131lan de\u011fer. STDOUT Standart \u00e7\u0131k\u0131\u015f. $stdout i\u00e7in varsay\u0131lan de\u011fer. STDERR Standart hata. $stderr i\u00e7in varsay\u0131lan de\u011fer. ENV Aktif \u00e7evre de\u011fi\u015fkenlerinin ( Environment Variables ) bulundu\u011fu Hash ARGF $< ile ayn\u0131 i\u015fi yap\u0131yor. ARGV $* ile ayn\u0131 i\u015fi yap\u0131yor. DATA Herhangi bir Ruby script dosyas\u0131nda, __END__ sonras\u0131na yaz\u0131lan \u015feylerin sakland\u0131\u011f\u0131 de\u011fi\u015fken. RUBY_VERSION \"2.1.0\" RUBY_RELEASE_DATE \"2013-12-25\" RUBY_PLATFORM \"x86_64-darwin13.0\" RUBY_COPYRIGHT \"ruby - Copyright (C) 1993-2013 Yukihiro Matsumoto\" RUBY_DESCRIPTION \"ruby 2.1.0p0 (2013-12-25 revision 44422) [x86_64-darwin13.0]\" RUBY_ENGINE \"ruby\" RUBY_PATCHLEVEL \"0\" RUBY_REVISION 44422","title":"Global Constants (Genel Sabitler)"},{"location":"bolum-03/","text":"B\u00f6l\u00fcm 3 Bu b\u00f6l\u00fcmde; Methods (Fonksiyonlar) Blocks (Bloklar) Proc ve Lambda Conditional Statements (Ko\u015fullar)","title":"\u0130ndeks"},{"location":"bolum-03/#bolum-3","text":"Bu b\u00f6l\u00fcmde; Methods (Fonksiyonlar) Blocks (Bloklar) Proc ve Lambda Conditional Statements (Ko\u015fullar)","title":"B\u00f6l\u00fcm 3"},{"location":"bolum-03/01-methods-fonksiyonlar/","text":"Methods (Fonksiyonlar) Programlama par\u00e7ac\u0131klar\u0131n\u0131n ve/veya ifadelerin bir araya topland\u0131\u011f\u0131 \u015feydir method. Asl\u0131nda lise matemati\u011finden hepimiz a\u015finay\u0131z. Bildi\u011finiz matematik fonksiyonu. Bundan b\u00f6yle fonksiyon yerine method kullanaca\u011f\u0131m. \u00c7\u00fcnk\u00fc Ruby demek neredeyse Obje ( Nesne ) ve Method ( Method ) demek. \u00d6nceki konularda g\u00f6rd\u00fc\u011f\u00fcm\u00fcz operat\u00f6rlerin neredeyse hepsi bir method! Hemen Method Definition 'a yani nas\u0131l method tan\u0131mland\u0131\u011f\u0131na bir g\u00f6z atal\u0131m. def merhaba \"Merhaba\" end merhaba # => \"Merhaba\" def ve end anahtar kelimeleri aras\u0131na method\u2019un ad\u0131 geldi. \u00d6nce method\u2019u tan\u0131mlad\u0131k, sonra \u00e7a\u011f\u0131rd\u0131k. Ruby'de her \u015fey mutlaka geriye bir \u015fey d\u00f6ner . Ne demek bu? Prensip olarak method\u2019lar zincir olarak \u00e7al\u0131\u015ft\u0131\u011f\u0131 i\u00e7in, method denen \u015fey de asl\u0131nda bir fonksiyon ve fonksiyon denen \u015fey de bir dizi i\u015flemin yap\u0131l\u0131p geriye sonucun d\u00f6n\u00fcld\u00fc\u011f\u00fc bir ta\u015f\u0131y\u0131c\u0131 asl\u0131nda. Bir \u00f6rnek vermek i\u00e7in hemen irb ye ge\u00e7elim: irb ( main ): 001 : 0 > puts \"Merhaba\" Merhaba => nil irb ( main ): 002 : 0 > puts \"Merhaba\" \u00f6nce i\u015fini yapt\u0131 ve \u00e7\u0131kt\u0131 olarak Merhaba verdi. sonra => nil dikkatinizi \u00e7ekti mi? \u00c7\u00fcnk\u00fc puts method\u2019u i\u015fini yapt\u0131 bitirdi ve geriye nil d\u00f6nd\u00fc! Peki daha \u00f6nceki programlama tecr\u00fcbelerimize dayanak, geriye d\u00f6nd\u00fc i\u015fini hangi komut yapm\u0131\u015f olabilir? Pek \u00e7ok dilde fonksiyondan bir \u015fey geri d\u00f6nmek i\u00e7in return kelimesi kullan\u0131l\u0131r. Ruby'de de kullan\u0131l\u0131r ama zorunlu de\u011fildir. Yukar\u0131daki def merhaba \u00f6rne\u011finde return kullanmamam\u0131za ra\u011fmen geriye Merhaba d\u00f6nebildi. Ruby'de methodlar i\u00e7erisindeki \u00e7al\u0131\u015ft\u0131r\u0131lan en son sat\u0131r\u0131n de\u011ferini d\u00f6nd\u00fcr\u00fcr. Ancak siz daha \u00f6ncesinde \u00f6zellikle return anahtar kelimesi ile bir sonu\u00e7 d\u00f6nmezseniz. Bir \u00f6rnekle konuyu peki\u015ftirelim. def merhabaBir m = \"Merhaba\" n = \"Ornek\" end def merhabaIki m = \"Merhaba\" n = \"Ornek\" return \"Return Ornek\" end puts merhabaBir # Sonu\u00e7 : Ornek puts merhabaIki # Sonu\u00e7 : Return Ornek \u0130\u015fte bu Ruby'nin \u00f6zelli\u011fi. Kodu okurken bunu bilmezsek kafam\u0131z s\u00fcper kar\u0131\u015fabilir. def ile tan\u0131mlanan method\u2019u, undef ile yok edebilirsiniz. def merhaba \"Merhaba\" end merhaba # => \"Merhaba\" undef merhaba merhaba # => # ~> -:9:in `<main>': undefined local variable or method `merhaba' for main:Object (NameError) G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi undefined local variable or method .. Object (NameError) hatas\u0131n\u0131 ald\u0131k. Method\u2019lar arg\u00fcman alabilir. Yani fonksiyona, do\u011fal olarak, parametre ge\u00e7ebilirsiniz. def merhaba ( isim ) \"Merhaba #{ isim } \" end merhaba ( \"vigo\" ) # => \"Merhaba vigo\" ayn\u0131 \u00f6rne\u011fi a\u015fa\u011f\u0131daki gibi de yazabiliriz: def merhaba isim \"Merhaba #{ isim } \" end merhaba \"vigo\" # => \"Merhaba vigo\" Method\u2019u tan\u0131mlarken ve \u00e7a\u011f\u0131r\u0131rken parantez kullanmad\u0131k! Bu al\u0131\u015fman\u0131z gereken \u00f6nemli konulardan birisi. \u015eahsen ben, daha \u00f6nce hi\u00e7bir programlama dilinde b\u00f6yle bir \u015fey g\u00f6rmedim! Baz\u0131 durumlara, arg\u00fcman alan method \u00e7a\u011f\u0131r\u0131rken, arg\u00fcman\u0131n tipine g\u00f6re, e\u011fer parantez kullanmadan \u00e7a\u011f\u0131rma yaparsan\u0131z warning alabilirsiniz! Method Yazma Kurallar\u0131 ( Method Conventions ) Ruby, pek \u00e7ok konuda rahat gibi g\u00f6r\u00fcnse bile baz\u0131 kurallar\u0131 var tabi. \u00d6zellikle method\u2019lar\u0131n son karakteri ile ilgili. E\u011fer bir method\u2019un son karakteri ? ise bu o method\u2019un true ya da false yani Boolean bir de\u011fer d\u00f6nece\u011fini ifade eder. a = \"ali\" b = \"ali\" a . eql? b # => true a . eql? ( b ) # => true .eql? method\u2019u e\u015fitli\u011fi kontrol eder ve mutlaka sonu\u00e7 Boolean d\u00f6ner. E\u011fer method\u2019un son karakteri ! ( \u00dcnlem ) ise; bu, o method\u2019un tehlikeli bir i\u015f yapt\u0131\u011f\u0131n\u0131 anlat\u0131r. Yani ilgili nesnenin kopyalanmadan direk \u00fczerinde de\u011fi\u015fiklik yapaca\u011f\u0131 anlam\u0131na gelir. a = \"deneme\" a . upcase # => \"DENEME\" a # => \"deneme\" a . upcase! # => \"DENEME\" a # => \"DENEME\" a de\u011feri deneme . .upcase ile orijinal de\u011feri de\u011fi\u015ftirmeden uppercase ( B\u00fcy\u00fck harf ) yapt\u0131k. De\u011feri kontrol etti\u011fimizde halen k\u00fc\u00e7\u00fck harf oldu\u011funu g\u00f6rd\u00fck. .upcase! kulland\u0131\u011f\u0131m\u0131z anda de\u011fi\u015fkenin orijinal de\u011ferini de bozduk. E\u011fer bir method = ile bitiyorsa, bu, o method\u2019un bir setter method\u2019u oldu\u011fu anlam\u0131na gelir ve Class ile ilgili bir konudur. class User def email= ( email ) @email = email end end u = User . new u # => #<User:0x007ff7229ed880> u . email = \"vigo@xyz.com\" u # => #<User:0x007ff7229ed880 @email=\"vigo@xyz.com\"> Varsay\u0131lan Arg\u00fcmanlar ( Default Arguments ) Method arg\u00fcmanlar\u0131na varsay\u0131lan de\u011ferler atayabilirsiniz. Bu, e\u011fer methoda g\u00f6nderilmesi beklenen arg\u00fcman gelmemi\u015fse otomatik olarak de\u011fer atama yapmay\u0131 sa\u011flar. def merhaba ( isim = \"insal\u0131k!\" ) \"Merhaba #{ isim } \" end merhaba # => \"Merhaba insal\u0131k!\" merhaba ( \"vigo\" ) # => \"Merhaba vigo\" Parametre ge\u00e7meden \u00e7a\u011f\u0131rd\u0131\u011f\u0131m\u0131zda, tan\u0131mlad\u0131\u011f\u0131m\u0131z varsay\u0131lan ( default ) de\u011fer atand\u0131. De\u011fi\u015fken Say\u0131da Arg\u00fcmanlar ( Variable-Length Arguments ) Baz\u0131 durumlarda method\u2019a de\u011fi\u015fken say\u0131da olarak parametre ge\u00e7mek gerekebilir. Bu durumda arg\u00fcman\u0131n ba\u015f\u0131na * i\u015fareti gelir. Bu sayede o arg\u00fcman art\u0131k bir dizi ( Array ) haline gelir. def merhaba ( * isimler ) \"Merhaba #{ isimler . join ( \" ve \" ) } \" end merhaba ( \"vigo\" ) # => \"Merhaba vigo\" merhaba ( \"vigo\" , \"ye\u015fim\" , \"ezel\" ) # => \"Merhaba vigo ve ye\u015fim ve ezel\" merhaba \"d\u00fcnya\" , \"uzay\" , \"evren\" , \"ay\" # => \"Merhaba d\u00fcnya ve uzay ve evren ve ay\" Keza, \u015fu \u015fekilde de kullan\u0131labilir: def custom_numbers ( first , second , * others ) puts \"ilk say\u0131: #{ first } \" puts \"ikinci say\u0131 : #{ second } \" puts \"di\u011fer say\u0131lar : #{ others . join ( \",\" ) } \" end custom_numbers 1 , 2 , 50 , 100 # => nil # >> ilk say\u0131: 1 # >> ikinci say\u0131 : 2 # >> di\u011fer say\u0131lar : 50,100 Method\u2019a Takma \u0130sim Vermek ( Aliasing ) Varolan bir method\u2019u, ba\u015fka bir isimle \u00e7a\u011f\u0131rmak. Bu asl\u0131nda Class konusuyla \u00e7ok ilintili ama k\u0131saca de\u011finmek istiyorum. def merhaba ( isim ) \"Merhaba! #{ isim } \" end alias naber merhaba merhaba \"U\u011fur\" # => \"Merhaba! U\u011fur\" naber \"U\u011fur\" # => \"Merhaba! U\u011fur\" Form\u00fcl \u015fu: alias TAKMA AD OR\u0130J\u0130NAL yani alias naber merhaba derken, merhaba method\u2019una takma ad olarak naber i tan\u0131mlad\u0131k! Unutma! return kullanmadan method\u2019dan geri d\u00f6n\u00fc\u015f yap\u0131labilir Parantez kullanmadan method tan\u0131mlanabilir Parantez kullanmadan method \u00e7a\u011f\u0131r\u0131l\u0131p parametre ge\u00e7ilebilir. ? ile biten method mutlaka true ya da false d\u00f6ner. ! ile biten orijinal de\u011feri mutlaka de\u011fi\u015ftirir. = ile biten setter 'd\u0131r.","title":"Methods (Fonksiyonlar)"},{"location":"bolum-03/01-methods-fonksiyonlar/#methods-fonksiyonlar","text":"Programlama par\u00e7ac\u0131klar\u0131n\u0131n ve/veya ifadelerin bir araya topland\u0131\u011f\u0131 \u015feydir method. Asl\u0131nda lise matemati\u011finden hepimiz a\u015finay\u0131z. Bildi\u011finiz matematik fonksiyonu. Bundan b\u00f6yle fonksiyon yerine method kullanaca\u011f\u0131m. \u00c7\u00fcnk\u00fc Ruby demek neredeyse Obje ( Nesne ) ve Method ( Method ) demek. \u00d6nceki konularda g\u00f6rd\u00fc\u011f\u00fcm\u00fcz operat\u00f6rlerin neredeyse hepsi bir method! Hemen Method Definition 'a yani nas\u0131l method tan\u0131mland\u0131\u011f\u0131na bir g\u00f6z atal\u0131m. def merhaba \"Merhaba\" end merhaba # => \"Merhaba\" def ve end anahtar kelimeleri aras\u0131na method\u2019un ad\u0131 geldi. \u00d6nce method\u2019u tan\u0131mlad\u0131k, sonra \u00e7a\u011f\u0131rd\u0131k. Ruby'de her \u015fey mutlaka geriye bir \u015fey d\u00f6ner . Ne demek bu? Prensip olarak method\u2019lar zincir olarak \u00e7al\u0131\u015ft\u0131\u011f\u0131 i\u00e7in, method denen \u015fey de asl\u0131nda bir fonksiyon ve fonksiyon denen \u015fey de bir dizi i\u015flemin yap\u0131l\u0131p geriye sonucun d\u00f6n\u00fcld\u00fc\u011f\u00fc bir ta\u015f\u0131y\u0131c\u0131 asl\u0131nda. Bir \u00f6rnek vermek i\u00e7in hemen irb ye ge\u00e7elim: irb ( main ): 001 : 0 > puts \"Merhaba\" Merhaba => nil irb ( main ): 002 : 0 > puts \"Merhaba\" \u00f6nce i\u015fini yapt\u0131 ve \u00e7\u0131kt\u0131 olarak Merhaba verdi. sonra => nil dikkatinizi \u00e7ekti mi? \u00c7\u00fcnk\u00fc puts method\u2019u i\u015fini yapt\u0131 bitirdi ve geriye nil d\u00f6nd\u00fc! Peki daha \u00f6nceki programlama tecr\u00fcbelerimize dayanak, geriye d\u00f6nd\u00fc i\u015fini hangi komut yapm\u0131\u015f olabilir? Pek \u00e7ok dilde fonksiyondan bir \u015fey geri d\u00f6nmek i\u00e7in return kelimesi kullan\u0131l\u0131r. Ruby'de de kullan\u0131l\u0131r ama zorunlu de\u011fildir. Yukar\u0131daki def merhaba \u00f6rne\u011finde return kullanmamam\u0131za ra\u011fmen geriye Merhaba d\u00f6nebildi. Ruby'de methodlar i\u00e7erisindeki \u00e7al\u0131\u015ft\u0131r\u0131lan en son sat\u0131r\u0131n de\u011ferini d\u00f6nd\u00fcr\u00fcr. Ancak siz daha \u00f6ncesinde \u00f6zellikle return anahtar kelimesi ile bir sonu\u00e7 d\u00f6nmezseniz. Bir \u00f6rnekle konuyu peki\u015ftirelim. def merhabaBir m = \"Merhaba\" n = \"Ornek\" end def merhabaIki m = \"Merhaba\" n = \"Ornek\" return \"Return Ornek\" end puts merhabaBir # Sonu\u00e7 : Ornek puts merhabaIki # Sonu\u00e7 : Return Ornek \u0130\u015fte bu Ruby'nin \u00f6zelli\u011fi. Kodu okurken bunu bilmezsek kafam\u0131z s\u00fcper kar\u0131\u015fabilir. def ile tan\u0131mlanan method\u2019u, undef ile yok edebilirsiniz. def merhaba \"Merhaba\" end merhaba # => \"Merhaba\" undef merhaba merhaba # => # ~> -:9:in `<main>': undefined local variable or method `merhaba' for main:Object (NameError) G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi undefined local variable or method .. Object (NameError) hatas\u0131n\u0131 ald\u0131k. Method\u2019lar arg\u00fcman alabilir. Yani fonksiyona, do\u011fal olarak, parametre ge\u00e7ebilirsiniz. def merhaba ( isim ) \"Merhaba #{ isim } \" end merhaba ( \"vigo\" ) # => \"Merhaba vigo\" ayn\u0131 \u00f6rne\u011fi a\u015fa\u011f\u0131daki gibi de yazabiliriz: def merhaba isim \"Merhaba #{ isim } \" end merhaba \"vigo\" # => \"Merhaba vigo\" Method\u2019u tan\u0131mlarken ve \u00e7a\u011f\u0131r\u0131rken parantez kullanmad\u0131k! Bu al\u0131\u015fman\u0131z gereken \u00f6nemli konulardan birisi. \u015eahsen ben, daha \u00f6nce hi\u00e7bir programlama dilinde b\u00f6yle bir \u015fey g\u00f6rmedim! Baz\u0131 durumlara, arg\u00fcman alan method \u00e7a\u011f\u0131r\u0131rken, arg\u00fcman\u0131n tipine g\u00f6re, e\u011fer parantez kullanmadan \u00e7a\u011f\u0131rma yaparsan\u0131z warning alabilirsiniz!","title":"Methods (Fonksiyonlar)"},{"location":"bolum-03/01-methods-fonksiyonlar/#method-yazma-kurallar-method-conventions","text":"Ruby, pek \u00e7ok konuda rahat gibi g\u00f6r\u00fcnse bile baz\u0131 kurallar\u0131 var tabi. \u00d6zellikle method\u2019lar\u0131n son karakteri ile ilgili. E\u011fer bir method\u2019un son karakteri ? ise bu o method\u2019un true ya da false yani Boolean bir de\u011fer d\u00f6nece\u011fini ifade eder. a = \"ali\" b = \"ali\" a . eql? b # => true a . eql? ( b ) # => true .eql? method\u2019u e\u015fitli\u011fi kontrol eder ve mutlaka sonu\u00e7 Boolean d\u00f6ner. E\u011fer method\u2019un son karakteri ! ( \u00dcnlem ) ise; bu, o method\u2019un tehlikeli bir i\u015f yapt\u0131\u011f\u0131n\u0131 anlat\u0131r. Yani ilgili nesnenin kopyalanmadan direk \u00fczerinde de\u011fi\u015fiklik yapaca\u011f\u0131 anlam\u0131na gelir. a = \"deneme\" a . upcase # => \"DENEME\" a # => \"deneme\" a . upcase! # => \"DENEME\" a # => \"DENEME\" a de\u011feri deneme . .upcase ile orijinal de\u011feri de\u011fi\u015ftirmeden uppercase ( B\u00fcy\u00fck harf ) yapt\u0131k. De\u011feri kontrol etti\u011fimizde halen k\u00fc\u00e7\u00fck harf oldu\u011funu g\u00f6rd\u00fck. .upcase! kulland\u0131\u011f\u0131m\u0131z anda de\u011fi\u015fkenin orijinal de\u011ferini de bozduk. E\u011fer bir method = ile bitiyorsa, bu, o method\u2019un bir setter method\u2019u oldu\u011fu anlam\u0131na gelir ve Class ile ilgili bir konudur. class User def email= ( email ) @email = email end end u = User . new u # => #<User:0x007ff7229ed880> u . email = \"vigo@xyz.com\" u # => #<User:0x007ff7229ed880 @email=\"vigo@xyz.com\">","title":"Method Yazma Kurallar\u0131 (Method Conventions)"},{"location":"bolum-03/01-methods-fonksiyonlar/#varsaylan-argumanlar-default-arguments","text":"Method arg\u00fcmanlar\u0131na varsay\u0131lan de\u011ferler atayabilirsiniz. Bu, e\u011fer methoda g\u00f6nderilmesi beklenen arg\u00fcman gelmemi\u015fse otomatik olarak de\u011fer atama yapmay\u0131 sa\u011flar. def merhaba ( isim = \"insal\u0131k!\" ) \"Merhaba #{ isim } \" end merhaba # => \"Merhaba insal\u0131k!\" merhaba ( \"vigo\" ) # => \"Merhaba vigo\" Parametre ge\u00e7meden \u00e7a\u011f\u0131rd\u0131\u011f\u0131m\u0131zda, tan\u0131mlad\u0131\u011f\u0131m\u0131z varsay\u0131lan ( default ) de\u011fer atand\u0131.","title":"Varsay\u0131lan Arg\u00fcmanlar (Default Arguments)"},{"location":"bolum-03/01-methods-fonksiyonlar/#degisken-sayda-argumanlar-variable-length-arguments","text":"Baz\u0131 durumlarda method\u2019a de\u011fi\u015fken say\u0131da olarak parametre ge\u00e7mek gerekebilir. Bu durumda arg\u00fcman\u0131n ba\u015f\u0131na * i\u015fareti gelir. Bu sayede o arg\u00fcman art\u0131k bir dizi ( Array ) haline gelir. def merhaba ( * isimler ) \"Merhaba #{ isimler . join ( \" ve \" ) } \" end merhaba ( \"vigo\" ) # => \"Merhaba vigo\" merhaba ( \"vigo\" , \"ye\u015fim\" , \"ezel\" ) # => \"Merhaba vigo ve ye\u015fim ve ezel\" merhaba \"d\u00fcnya\" , \"uzay\" , \"evren\" , \"ay\" # => \"Merhaba d\u00fcnya ve uzay ve evren ve ay\" Keza, \u015fu \u015fekilde de kullan\u0131labilir: def custom_numbers ( first , second , * others ) puts \"ilk say\u0131: #{ first } \" puts \"ikinci say\u0131 : #{ second } \" puts \"di\u011fer say\u0131lar : #{ others . join ( \",\" ) } \" end custom_numbers 1 , 2 , 50 , 100 # => nil # >> ilk say\u0131: 1 # >> ikinci say\u0131 : 2 # >> di\u011fer say\u0131lar : 50,100","title":"De\u011fi\u015fken Say\u0131da Arg\u00fcmanlar (Variable-Length Arguments)"},{"location":"bolum-03/01-methods-fonksiyonlar/#methoda-takma-isim-vermek-aliasing","text":"Varolan bir method\u2019u, ba\u015fka bir isimle \u00e7a\u011f\u0131rmak. Bu asl\u0131nda Class konusuyla \u00e7ok ilintili ama k\u0131saca de\u011finmek istiyorum. def merhaba ( isim ) \"Merhaba! #{ isim } \" end alias naber merhaba merhaba \"U\u011fur\" # => \"Merhaba! U\u011fur\" naber \"U\u011fur\" # => \"Merhaba! U\u011fur\" Form\u00fcl \u015fu: alias TAKMA AD OR\u0130J\u0130NAL yani alias naber merhaba derken, merhaba method\u2019una takma ad olarak naber i tan\u0131mlad\u0131k!","title":"Method\u2019a Takma \u0130sim Vermek (Aliasing)"},{"location":"bolum-03/01-methods-fonksiyonlar/#unutma","text":"return kullanmadan method\u2019dan geri d\u00f6n\u00fc\u015f yap\u0131labilir Parantez kullanmadan method tan\u0131mlanabilir Parantez kullanmadan method \u00e7a\u011f\u0131r\u0131l\u0131p parametre ge\u00e7ilebilir. ? ile biten method mutlaka true ya da false d\u00f6ner. ! ile biten orijinal de\u011feri mutlaka de\u011fi\u015ftirir. = ile biten setter 'd\u0131r.","title":"Unutma!"},{"location":"bolum-03/02-blocks-bloklar/","text":"Blocks (Bloklar) Blok olay\u0131, bence Ruby'nin en \u00e7\u0131lg\u0131n \u00f6zelliklerinden biri. Asl\u0131nda bu konu, neredeyse ba\u015fl\u0131 ba\u015f\u0131na bir kitap konusu olabilir. Genelde Block, Proc, Lambda \u00fc\u00e7lemesi olarak anlat\u0131l\u0131r. Kitab\u0131m\u0131z 101 yani giri\u015f seviyesinde oldu\u011fu i\u00e7in, kafalar\u0131 minimum kar\u0131\u015ft\u0131rma ad\u0131na basit \u015fekilde de\u011finece\u011fim. Blok'lar, genelde [Closure](http://en.wikipedia.org/wiki/Closure_(computer_programming) ya da Anonim fonksiyonlar olarak tan\u0131mlan\u0131r. Sanki method i\u00e7inde ba\u015fka bir method\u2019u i\u015faret eden ya da de\u011fi\u015fkenleri method\u2019lar aras\u0131nda payla\u015fan kapal\u0131 bir ortam gibidirler. Genelde ya { } ile ya da do/end ile sarmalanm\u0131\u015flard\u0131r. family_members = [ \"Ye\u015fim\" , \"Ezel\" , \"U\u011fur\" , \"\u00d6mer\" ] family_members . each do | member_name | puts member_name end # Ye\u015fim # Ezel # U\u011fur # \u00d6mer Ayn\u0131 kod: family_members = [ \"Ye\u015fim\" , \"Ezel\" , \"U\u011fur\" , \"\u00d6mer\" ] family_members . each { | member_name | puts member_name } # Ye\u015fim # Ezel # U\u011fur # \u00d6mer \u015feklinde de yaz\u0131labilirdi. do/end ya da {} aras\u0131nda kalan k\u0131s\u0131m Block k\u0131sm\u0131d\u0131r. family_members bir Array yani dizidir. E\u011fer puts family_members.class dersek bize Array oldunu s\u00f6yler. Array'in each method\u2019u bize block i\u015fleme \u015fans\u0131n\u0131 sa\u011flar. Komut sat\u0131r\u0131nda ri Array#each dersek bize Array'in each method\u2019uyla ilgili t\u00fcm bilgiler gelir. do komutundan hemen sonra gelen |member_name| bizim kafam\u0131za g\u00f6re tan\u0131mlad\u0131\u011f\u0131m\u0131z bir de\u011fi\u015fkendir ve Array'in her eleman\u0131 bu de\u011fi\u015fkene atan\u0131r. Enumeration b\u00f6l\u00fcm\u00fcnde bunlardan s\u0131k\u00e7a bahsedece\u011fiz. Blocklar\u0131n esas g\u00fcc\u00fc yield olay\u0131ndan gelir. Hemen bir \u00f6rnek verelim: def test_function yield end test_function { puts \"Merhaba\" } # Merhaba test_function do puts \"Ben block i\u00e7inden geliyorum\" end # Ben block i\u00e7inden geliyorum test_function do [ 1 , 2 , 3 , 4 ]. each do | n | puts \"Say\u0131 #{ n } \" end end # Say\u0131 1 # Say\u0131 2 # Say\u0131 3 # Say\u0131 4 test_function ad\u0131nda bir fonksiyonum var ( yani method\u2019um var ) Hi\u00e7 parametre alm\u0131yor! ama Block al\u0131yor. \u0130lkinde curly brace ile ( yani { ve } ), ikincisinde do/end ile, son \u00f6rnekte do/end ile ve i\u00e7 k\u0131s\u0131mda ba\u015fka bir iterasyonla kulland\u0131m. Kabaca, fonksiyona kod blo\u011fu ge\u00e7tim. Peki, ya \u015fu \u015fekilde kullansayd\u0131m test_function ? yani hi\u00e7bir \u015fey ge\u00e7meden? Alaca\u011f\u0131m hata mesaj\u0131: no block given (yield) olacakt\u0131. Demek ki block ge\u00e7ilip ge\u00e7ilmedi\u011fini anlaman\u0131n bir yolu var :) def test_function if block_given? yield else puts \"L\u00fctfen bana block veriniz!\" end end block_given? ile bu kontrol\u00fc yapabiliyoruz. \u015eimdi biraz daha kafa kar\u0131\u015ft\u0131ral\u0131m :) def numerator yield 10 yield 4 yield 8 end numerator do | number | puts \"Ge\u00e7ilen say\u0131 #{ number } \" end \u00d6rnekte, yield block i\u00e7inden gelen kod blo\u011funu bir fonksiyon gibi \u00e7a\u011f\u0131r\u0131yor, \u00e7a\u011f\u0131r\u0131rken de blo\u011fa parametre ge\u00e7iyor. Dikkat ettiyseniz ka\u00e7 tane yield varsa o kadar kez block \u00e7a\u011f\u0131r\u0131ld\u0131 (_call edildi__) def print_users [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" ]. each do | name | yield name end end print_users do | name | puts \"Kullan\u0131c\u0131 Ad\u0131: #{ name } \" end # Kullan\u0131c\u0131 Ad\u0131: U\u011fur # Kullan\u0131c\u0131 Ad\u0131: Ye\u015fim # Kullan\u0131c\u0131 Ad\u0131: Ezel Fonksiyon i\u00e7ine fonksiyon ge\u00e7tik gibi. Enumeration / Number b\u00f6l\u00fcm\u00fcnde de g\u00f6rece\u011fiz ama hemen h\u0131zl\u0131 bir-iki \u00f6rnek vermek istiyorum blok kullan\u0131m\u0131yla ili\u015fkili. 5 . times { puts \"Merhaba\" } 5 . times { | i | puts \"Say\u0131 #{ i } \" } 5 . times do | i | puts \"Say\u0131 #{ i } \" end Not: Asl\u0131nda times say\u0131lara ait bir method ve yukar\u0131daki \u00f6rneklerde g\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi blok ge\u00e7ebiliyoruz kendisine.","title":"Blocks (Bloklar)"},{"location":"bolum-03/02-blocks-bloklar/#blocks-bloklar","text":"Blok olay\u0131, bence Ruby'nin en \u00e7\u0131lg\u0131n \u00f6zelliklerinden biri. Asl\u0131nda bu konu, neredeyse ba\u015fl\u0131 ba\u015f\u0131na bir kitap konusu olabilir. Genelde Block, Proc, Lambda \u00fc\u00e7lemesi olarak anlat\u0131l\u0131r. Kitab\u0131m\u0131z 101 yani giri\u015f seviyesinde oldu\u011fu i\u00e7in, kafalar\u0131 minimum kar\u0131\u015ft\u0131rma ad\u0131na basit \u015fekilde de\u011finece\u011fim. Blok'lar, genelde [Closure](http://en.wikipedia.org/wiki/Closure_(computer_programming) ya da Anonim fonksiyonlar olarak tan\u0131mlan\u0131r. Sanki method i\u00e7inde ba\u015fka bir method\u2019u i\u015faret eden ya da de\u011fi\u015fkenleri method\u2019lar aras\u0131nda payla\u015fan kapal\u0131 bir ortam gibidirler. Genelde ya { } ile ya da do/end ile sarmalanm\u0131\u015flard\u0131r. family_members = [ \"Ye\u015fim\" , \"Ezel\" , \"U\u011fur\" , \"\u00d6mer\" ] family_members . each do | member_name | puts member_name end # Ye\u015fim # Ezel # U\u011fur # \u00d6mer Ayn\u0131 kod: family_members = [ \"Ye\u015fim\" , \"Ezel\" , \"U\u011fur\" , \"\u00d6mer\" ] family_members . each { | member_name | puts member_name } # Ye\u015fim # Ezel # U\u011fur # \u00d6mer \u015feklinde de yaz\u0131labilirdi. do/end ya da {} aras\u0131nda kalan k\u0131s\u0131m Block k\u0131sm\u0131d\u0131r. family_members bir Array yani dizidir. E\u011fer puts family_members.class dersek bize Array oldunu s\u00f6yler. Array'in each method\u2019u bize block i\u015fleme \u015fans\u0131n\u0131 sa\u011flar. Komut sat\u0131r\u0131nda ri Array#each dersek bize Array'in each method\u2019uyla ilgili t\u00fcm bilgiler gelir. do komutundan hemen sonra gelen |member_name| bizim kafam\u0131za g\u00f6re tan\u0131mlad\u0131\u011f\u0131m\u0131z bir de\u011fi\u015fkendir ve Array'in her eleman\u0131 bu de\u011fi\u015fkene atan\u0131r. Enumeration b\u00f6l\u00fcm\u00fcnde bunlardan s\u0131k\u00e7a bahsedece\u011fiz. Blocklar\u0131n esas g\u00fcc\u00fc yield olay\u0131ndan gelir. Hemen bir \u00f6rnek verelim: def test_function yield end test_function { puts \"Merhaba\" } # Merhaba test_function do puts \"Ben block i\u00e7inden geliyorum\" end # Ben block i\u00e7inden geliyorum test_function do [ 1 , 2 , 3 , 4 ]. each do | n | puts \"Say\u0131 #{ n } \" end end # Say\u0131 1 # Say\u0131 2 # Say\u0131 3 # Say\u0131 4 test_function ad\u0131nda bir fonksiyonum var ( yani method\u2019um var ) Hi\u00e7 parametre alm\u0131yor! ama Block al\u0131yor. \u0130lkinde curly brace ile ( yani { ve } ), ikincisinde do/end ile, son \u00f6rnekte do/end ile ve i\u00e7 k\u0131s\u0131mda ba\u015fka bir iterasyonla kulland\u0131m. Kabaca, fonksiyona kod blo\u011fu ge\u00e7tim. Peki, ya \u015fu \u015fekilde kullansayd\u0131m test_function ? yani hi\u00e7bir \u015fey ge\u00e7meden? Alaca\u011f\u0131m hata mesaj\u0131: no block given (yield) olacakt\u0131. Demek ki block ge\u00e7ilip ge\u00e7ilmedi\u011fini anlaman\u0131n bir yolu var :) def test_function if block_given? yield else puts \"L\u00fctfen bana block veriniz!\" end end block_given? ile bu kontrol\u00fc yapabiliyoruz. \u015eimdi biraz daha kafa kar\u0131\u015ft\u0131ral\u0131m :) def numerator yield 10 yield 4 yield 8 end numerator do | number | puts \"Ge\u00e7ilen say\u0131 #{ number } \" end \u00d6rnekte, yield block i\u00e7inden gelen kod blo\u011funu bir fonksiyon gibi \u00e7a\u011f\u0131r\u0131yor, \u00e7a\u011f\u0131r\u0131rken de blo\u011fa parametre ge\u00e7iyor. Dikkat ettiyseniz ka\u00e7 tane yield varsa o kadar kez block \u00e7a\u011f\u0131r\u0131ld\u0131 (_call edildi__) def print_users [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" ]. each do | name | yield name end end print_users do | name | puts \"Kullan\u0131c\u0131 Ad\u0131: #{ name } \" end # Kullan\u0131c\u0131 Ad\u0131: U\u011fur # Kullan\u0131c\u0131 Ad\u0131: Ye\u015fim # Kullan\u0131c\u0131 Ad\u0131: Ezel Fonksiyon i\u00e7ine fonksiyon ge\u00e7tik gibi. Enumeration / Number b\u00f6l\u00fcm\u00fcnde de g\u00f6rece\u011fiz ama hemen h\u0131zl\u0131 bir-iki \u00f6rnek vermek istiyorum blok kullan\u0131m\u0131yla ili\u015fkili. 5 . times { puts \"Merhaba\" } 5 . times { | i | puts \"Say\u0131 #{ i } \" } 5 . times do | i | puts \"Say\u0131 #{ i } \" end Not: Asl\u0131nda times say\u0131lara ait bir method ve yukar\u0131daki \u00f6rneklerde g\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi blok ge\u00e7ebiliyoruz kendisine.","title":"Blocks (Bloklar)"},{"location":"bolum-03/03-proc-ve-lambda/","text":"Proc ve Lambda Block kullan\u0131m\u0131n\u0131 daha dinamik ve programatik hale getirmek i\u00e7in Procedures ya da genel ad\u0131yla Procs , object-oriented Ruby'nin vazge\u00e7ilmezlerindendir. Bazen, her seferinde ayn\u0131 blo\u011fu s\u00fcrekli ge\u00e7mek gerekti\u011finde imdad\u0131m\u0131za Proc yeti\u015fiyor. Nas\u0131l m\u0131? D\u00fc\u015f\u00fcn\u00fcn ki bir method'unuz ( fonksiyonunuz ) olsun, ve bu method\u2019u dinamik olarak programlayabilseniz? def multiplier ( with ) return Proc . new { | number | number * with } end \u00c7arpma yapt\u0131ran dinamik bir fonksiyon. Say\u0131y\u0131 ka\u00e7 ile \u00e7arpacaksak with e o say\u0131y\u0131 ge\u00e7iyoruz. multiply_with_5 = multiplier ( 5 ) Elimizde ge\u00e7ti\u011fimiz say\u0131y\u0131 5 ile \u00e7arpacak, fonksiyondan t\u00fcremi\u015f bir fonksiyon olu\u015ftu. E\u011fer multiply_with_5 acaba neymi\u015f dersek? puts multiply_with_5 # #<Proc:0x007fcc9c94a938@/Users/vigo/Desktop/ruby101_book_tests.rb:2> puts multiply_with_5 . class # Proc G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi elimizde bir adet Proc objesi var!. Haydi kullanal\u0131m! puts multiply_with_5 . call ( 5 ) # 25 puts multiply_with_5 . call ( 10 ) # 50 Bu kadar kasmadan, basit bir method ile yapsayd\u0131k: def multiplier ( number , with ) return number * with end puts multiplier 5 , 5 # 25 \u015feklinde olurdu. Benzer bir \u00f6rnek daha yapal\u0131m: multiplier = Proc . new { |* number | number . collect { | n | n ** 2 } } multiplier . call ( 1 ) # => [1] multiplier . call ( 2 , 4 , 6 ) # => [4, 16, 36] multiplier [ 2 , 4 , 6 ]. class # => Array Az ileride Array konusunda g\u00f6rece\u011fimiz collect method'unu kulland\u0131k. Bu method ile Array'in her eleman\u0131n\u0131 okuyor ve karesini n ** 2 al\u0131yoruz. * i\u015fareti yine Array'de g\u00f6rece\u011fimiz splat \u00f6zelli\u011fi. Yani ge\u00e7ilen parametre grubunu Array olarak de\u011ferlendir diyoruz. Lambda Python'la u\u011fra\u015fan okurlar\u0131m\u0131z Lambda 'ya a\u015fina olabilirler. Proc ile ilk g\u00f6ze \u00e7arpan fark, arg\u00fcman olarak ge\u00e7ilen parametrelerin say\u0131s\u0131 \u00f6nemlidir Lambda'da. Ayn\u0131 Proc gibi \u00e7al\u0131\u015f\u0131r. custom_print = lambda { | txt | puts txt } custom_print . call ( \"Hello\" ) # Hello E\u011fer 2 parametre ge\u00e7seydik: custom_print = lambda { | txt | puts txt } custom_print . call ( \"Hello\" , \"World\" ) # ArgumentError: wrong number of arguments (2 for 1) Ya da; l = lambda { \"Merhaba\" } puts l . call # Merhaba Ba\u015fka bir kullan\u0131m; l = lambda do | user_name | if user_name == \"vigo\" \"Selam vigo! nas\u0131ls\u0131n?\" else \"Selam sana #{ user_name } \" end end puts l . call ( \"vigo\" ) # Selam vigo! nas\u0131ls\u0131n? puts l . call ( \"u\u011fur\" ) # Selam sana u\u011fur Proc ve Lambda Fark\u0131 def arguments ( input ) one , two = 1 , 2 input . call ( one , two ) end puts arguments ( Proc . new { | a , b , c | puts \" #{ a } ve #{ b } ve #{ c . class } \" }) # 1 ve 2 ve NilClass puts arguments ( lambda { | a , b , c | puts \" #{ a } ve #{ b } ve #{ c . class } \" }) # ArgumentError: wrong number of arguments (2 for 3) Ayn\u0131 kodu kulland\u0131k, Lambda yeterli parametre almad\u0131\u011f\u0131 i\u00e7in hata verdi. Proc'u Block'a \u00e7evirmek Elimizdeki Array elemanlar\u0131n\u0131n her birini bir fonksiyona tabii tutsak? Dizinin her eleman\u0131n\u0131 ekrana yazd\u0131ran bir \u015fey? items = [ \"Bu bir\" , \"bu iki\" , \"bu \u00fc\u00e7\" ] print_each_element = lambda { | item | puts item } items . each ( & print_each_element ) Bu \u00f6rnekte items.each(&print_each_element) sat\u0131r\u0131 Proc'u Block'a \u00e7evirdi\u011fimiz yer. & i\u015fin s\u0131rr\u0131. each 'den gelen eleman, sanki method \u00e7a\u011f\u0131r\u0131r gibi print_each_element e pas ediliyor, kar\u015f\u0131layan da { } i\u00e7inde tan\u0131ml\u0131 kod blo\u011funu \u00e7al\u0131\u015ft\u0131r\u0131yor. Keza ayn\u0131 i\u015fi; items = [ \"Bu bir\" , \"bu iki\" , \"bu \u00fc\u00e7\" ] def print_each_element ( item ) puts item end items . each ( & method ( :print_each_element )) \u015feklinde de yapabilirdik!","title":"Proc ve Lambda"},{"location":"bolum-03/03-proc-ve-lambda/#proc-ve-lambda","text":"Block kullan\u0131m\u0131n\u0131 daha dinamik ve programatik hale getirmek i\u00e7in Procedures ya da genel ad\u0131yla Procs , object-oriented Ruby'nin vazge\u00e7ilmezlerindendir. Bazen, her seferinde ayn\u0131 blo\u011fu s\u00fcrekli ge\u00e7mek gerekti\u011finde imdad\u0131m\u0131za Proc yeti\u015fiyor. Nas\u0131l m\u0131? D\u00fc\u015f\u00fcn\u00fcn ki bir method'unuz ( fonksiyonunuz ) olsun, ve bu method\u2019u dinamik olarak programlayabilseniz? def multiplier ( with ) return Proc . new { | number | number * with } end \u00c7arpma yapt\u0131ran dinamik bir fonksiyon. Say\u0131y\u0131 ka\u00e7 ile \u00e7arpacaksak with e o say\u0131y\u0131 ge\u00e7iyoruz. multiply_with_5 = multiplier ( 5 ) Elimizde ge\u00e7ti\u011fimiz say\u0131y\u0131 5 ile \u00e7arpacak, fonksiyondan t\u00fcremi\u015f bir fonksiyon olu\u015ftu. E\u011fer multiply_with_5 acaba neymi\u015f dersek? puts multiply_with_5 # #<Proc:0x007fcc9c94a938@/Users/vigo/Desktop/ruby101_book_tests.rb:2> puts multiply_with_5 . class # Proc G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi elimizde bir adet Proc objesi var!. Haydi kullanal\u0131m! puts multiply_with_5 . call ( 5 ) # 25 puts multiply_with_5 . call ( 10 ) # 50 Bu kadar kasmadan, basit bir method ile yapsayd\u0131k: def multiplier ( number , with ) return number * with end puts multiplier 5 , 5 # 25 \u015feklinde olurdu. Benzer bir \u00f6rnek daha yapal\u0131m: multiplier = Proc . new { |* number | number . collect { | n | n ** 2 } } multiplier . call ( 1 ) # => [1] multiplier . call ( 2 , 4 , 6 ) # => [4, 16, 36] multiplier [ 2 , 4 , 6 ]. class # => Array Az ileride Array konusunda g\u00f6rece\u011fimiz collect method'unu kulland\u0131k. Bu method ile Array'in her eleman\u0131n\u0131 okuyor ve karesini n ** 2 al\u0131yoruz. * i\u015fareti yine Array'de g\u00f6rece\u011fimiz splat \u00f6zelli\u011fi. Yani ge\u00e7ilen parametre grubunu Array olarak de\u011ferlendir diyoruz.","title":"Proc ve Lambda"},{"location":"bolum-03/03-proc-ve-lambda/#lambda","text":"Python'la u\u011fra\u015fan okurlar\u0131m\u0131z Lambda 'ya a\u015fina olabilirler. Proc ile ilk g\u00f6ze \u00e7arpan fark, arg\u00fcman olarak ge\u00e7ilen parametrelerin say\u0131s\u0131 \u00f6nemlidir Lambda'da. Ayn\u0131 Proc gibi \u00e7al\u0131\u015f\u0131r. custom_print = lambda { | txt | puts txt } custom_print . call ( \"Hello\" ) # Hello E\u011fer 2 parametre ge\u00e7seydik: custom_print = lambda { | txt | puts txt } custom_print . call ( \"Hello\" , \"World\" ) # ArgumentError: wrong number of arguments (2 for 1) Ya da; l = lambda { \"Merhaba\" } puts l . call # Merhaba Ba\u015fka bir kullan\u0131m; l = lambda do | user_name | if user_name == \"vigo\" \"Selam vigo! nas\u0131ls\u0131n?\" else \"Selam sana #{ user_name } \" end end puts l . call ( \"vigo\" ) # Selam vigo! nas\u0131ls\u0131n? puts l . call ( \"u\u011fur\" ) # Selam sana u\u011fur","title":"Lambda"},{"location":"bolum-03/03-proc-ve-lambda/#proc-ve-lambda-fark","text":"def arguments ( input ) one , two = 1 , 2 input . call ( one , two ) end puts arguments ( Proc . new { | a , b , c | puts \" #{ a } ve #{ b } ve #{ c . class } \" }) # 1 ve 2 ve NilClass puts arguments ( lambda { | a , b , c | puts \" #{ a } ve #{ b } ve #{ c . class } \" }) # ArgumentError: wrong number of arguments (2 for 3) Ayn\u0131 kodu kulland\u0131k, Lambda yeterli parametre almad\u0131\u011f\u0131 i\u00e7in hata verdi.","title":"Proc ve Lambda Fark\u0131"},{"location":"bolum-03/03-proc-ve-lambda/#procu-blocka-cevirmek","text":"Elimizdeki Array elemanlar\u0131n\u0131n her birini bir fonksiyona tabii tutsak? Dizinin her eleman\u0131n\u0131 ekrana yazd\u0131ran bir \u015fey? items = [ \"Bu bir\" , \"bu iki\" , \"bu \u00fc\u00e7\" ] print_each_element = lambda { | item | puts item } items . each ( & print_each_element ) Bu \u00f6rnekte items.each(&print_each_element) sat\u0131r\u0131 Proc'u Block'a \u00e7evirdi\u011fimiz yer. & i\u015fin s\u0131rr\u0131. each 'den gelen eleman, sanki method \u00e7a\u011f\u0131r\u0131r gibi print_each_element e pas ediliyor, kar\u015f\u0131layan da { } i\u00e7inde tan\u0131ml\u0131 kod blo\u011funu \u00e7al\u0131\u015ft\u0131r\u0131yor. Keza ayn\u0131 i\u015fi; items = [ \"Bu bir\" , \"bu iki\" , \"bu \u00fc\u00e7\" ] def print_each_element ( item ) puts item end items . each ( & method ( :print_each_element )) \u015feklinde de yapabilirdik!","title":"Proc'u Block'a \u00e7evirmek"},{"location":"bolum-03/04-conditional-statements-kosullar/","text":"Conditional Statements (Ko\u015fullar) Verilen ifadenin do\u011fru ya da yanl\u0131\u015f oldu\u011funun testi yap\u0131l\u0131r, ak\u0131\u015f true ya da false durumuna g\u00f6re seyreder. if durumu if a == b then dedi\u011fimizde, E\u011fer \"a, b'ye e\u015fittir\" \u00f6nermesi do\u011fruysa demi\u015f oluruz. if a != b then dedi\u011fimizde, E\u011fer \"a, b'ye e\u015fit de\u011fildir\" \u00f6nermesi do\u011fruysa demi\u015f oluruz. Ayn\u0131 mant\u0131kta, a > b (\"a, b'den b\u00fcy\u00fckt\u00fcr\"), a < b (\"a, b'den k\u00fc\u00e7\u00fckt\u00fcr\"), a >= b (\"a, b'en b\u00fcy\u00fck ya da e\u015fittir\"), a <= b (\"a, b'den k\u00fc\u00e7\u00fck ya da e\u015fitse\") \u015feklinde \u00f6nermeler de kurulabilir. Negatiflik Operat\u00f6r\u00fc ! i\u015fareti \u00f6nermenin sol taraf\u0131nda kullan\u0131l\u0131rsa, negatiflik ya da olumsuzluk kontrol\u00fc oldu\u011fu anlam\u0131ndad\u0131r. if !a == b then puts \"a, b'ye e\u015fit de\u011fil\" end ya da if !a > b then puts \"a, b'den b\u00fcy\u00fck de\u011fil\" end gibi kullan\u0131l\u0131r. \u0130\u00e7erideki \u00f6nermenin tersi do\u011fruysa demektir. if !a == b then \u00f6rne\u011fini daha iyi inceleyecek olursak. \u00d6rnekte \u00f6nerme \"a, b'ye e\u015fittir\" \u00f6nermesinin olumsuzu, yani \"a, b'ye e\u015fit de\u011fildir\"dir. Yani bu if durumu \u015funa kar\u015f\u0131l\u0131k gelmektedir: \"a, b'ye e\u015fit de\u011fildir\" do\u011fru ise \u00c7oklu Kontrol E\u011fer \u00f6nermeler aras\u0131nda and ( ve ), or ( veya ) ya da bunlar\u0131n k\u0131sa yollar\u0131n\u0131 ( and i\u00e7in && , or i\u00e7in || ) kullan\u0131rsak birden fazla \u015feyi kontrol etmi\u015f oluruz. a = 5 b = 10 if a == 5 && b == 10 puts \"\u0130\u015fleme devam edebiliriz!\" end if a == 5 && b == 10 yerine if a == 5 and b == 10 de yazabilirdik. Ruby'nin konu\u015fma diline yak\u0131n olmas\u0131 sebebiyle, \u00e7ok daha anla\u015f\u0131l\u0131r kontrol sat\u0131rlar\u0131 yazmak m\u00fcmk\u00fcn. \u00d6rne\u011fin, E\u011fer, a, 5'e e\u015fitse Merhaba Yaz demek i\u00e7in ilk akla gelen y\u00f6ntem: if a == 5 puts \"Merhaba\" end ama bunu \u00e7ok daha basit hale getirebiliriz: puts \"Merhaba\" if a == 5 Tek sat\u0131rda, if i ko\u015ful sonucunda olacak \u015feyin sa\u011f\u0131na yazmak yeterlidir. elsif Programlama mant\u0131\u011f\u0131nda pek de sevmedi\u011fim ( daha d\u00fczg\u00fcn y\u00f6ntemleri var ) ama bazen mecbur kald\u0131\u011f\u0131m\u0131z bir durumdur. if a == b puts \"a, b'ye e\u015fit\" elsif a < b puts \"a, b'den k\u00fc\u00e7\u00fck\" else puts \"a, b'ten b\u00fcy\u00fck\" end \u0130lk olarak a == b kontrol\u00fc yap\u0131l\u0131r, e\u011fer sonu\u00e7 false ise, a < b kontrol edilir, o da false ise en sondaki else devreye giriyor ve \u00e7\u0131kt\u0131 olarak \"a, b'ten b\u00fcy\u00fck\" yazd\u0131r\u0131l\u0131yor. unless Bu, asl\u0131nda if in tersi gibi. Daha do\u011frusu if not anlam\u0131nda. E\u011fer a, b'ye e\u015fit de\u011filse demek i\u00e7in; unless a == b puts \"E\u015fit de\u011fil\" end Ayn\u0131 mant\u0131kta puts \"E\u015fit de\u011fil\" unless a == b \u015feklinde de yazabiliriz. Semantik olarak olumsuzluk kontrol\u00fc yaparken unless kullan\u0131lmas\u0131 \u00f6nerilir. Kodu okuma ve anlama a\u00e7\u0131s\u0131ndan kolay olmas\u0131 i\u00e7in. while , break , until D\u00f6ng\u00fcleri Tan\u0131mlanan \u00f6nerme true oldu\u011fu s\u00fcrece loop yani d\u00f6ng\u00fc \u00e7al\u0131\u015ft\u0131rma kontrol\u00fcd\u00fcr. i = 0 while i < 5 do puts \"i = #{ i } \" i += 1 end E\u011fer i += 1 yani i yi bir artt\u0131r, demezsek sonsuz d\u00f6ng\u00fcye gireriz. E\u011fer belli bir anda d\u00f6ng\u00fcy\u00fc k\u0131rmak istersek, i = 0 while i < 5 do puts \"i = #{ i } \" break if i == 3 i += 1 end i 3 oldu\u011funda loop devre d\u0131\u015f\u0131 kal\u0131r... Ayn\u0131 unless mant\u0131\u011f\u0131nda, until kullan\u0131l\u0131r loop'larda. i = 0 until i == 10 do puts \"i = #{ i } \" i += 1 end Yani i 10 'a e\u015fit olmad\u0131\u011f\u0131 s\u00fcrece bu loop \u00e7al\u0131\u015f\u0131r. case , when Yap\u0131s\u0131 elsif yerine kullan\u0131lmas\u0131 muhtemel, daha anla\u015f\u0131l\u0131r kontrol mekanizmas\u0131d\u0131r. Hemen \u00f6rne\u011fe bakal\u0131m: computer = \"c64\" year = case computer when \"c64\" then \"1982\" when \"c16\" then \"1984\" when \"amiga\" then \"1985\" else \"Tarih bilinmiyor\" end puts \" #{ computer } \u00e7\u0131k\u0131\u015f y\u0131l\u0131 #{ year } \" # c64 \u00e7\u0131k\u0131\u015f y\u0131l\u0131 1982 Yukar\u0131daki kodu bir ton if , elsif ile yapmak yerine, when ve then ile daha anla\u015f\u0131l\u0131r hale getirdi\u011fimizi d\u00fc\u015f\u00fcn\u00fcyorum. when kullan\u0131rken range ( aral\u0131k ) belirmesi de yapma \u015fans\u0131 var. student_grade = 8 case student_grade when 0 puts \"\u00c7ok k\u00f6t\u00fc\" when 1 .. 4 puts \"Ba\u015far\u0131s\u0131z\" when 5 .. 7 puts \"\u0130yi\" when 8 .. 9 puts \"\u00c7ok \u0130yi\" when 10 puts \"S\u00fcper\" end E\u011fer not 1 ile 4 aral\u0131\u011f\u0131ndaysa (ve dahil ise) ya da 5 ile 7 aral\u0131\u011f\u0131ndaysa gibi bir kontrol ekledik. for D\u00f6ng\u00fcs\u00fc 1 'den 10 'a kadar (1 ve 10 dahil) bir d\u00f6ng\u00fc yapal\u0131m: for i in 1 .. 10 puts \"i = #{ i } \" end # i = 1 # i = 2 # i = 3 # i = 4 # i = 5 # i = 6 # i = 7 # i = 8 # i = 9 # i = 10 Ayn\u0131 i\u015fi \u00e7ok daha kolay yapman\u0131n yolunu 5.B\u00f6l\u00fcm 'de Iteration k\u0131sm\u0131nda g\u00f6rece\u011fiz! Ternary Operat\u00f6r\u00fc K\u0131salt\u0131lm\u0131\u015f if yap\u0131s\u0131d\u0131r. Hemen hemen pek \u00e7ok dilde kullan\u0131lan, E\u011fer \u015fu do\u011fru ise bu de\u011filse bu ifadesi i\u00e7in kullan\u0131l\u0131r. amount = 2 pluralize = amount == 1 ? \"apple\" : \"apples\" puts \" #{ amount } #{ pluralize } .\" Bu \u00f6rnekte Ternary olarak amount == 1 ? \"apple\" : \"apples\" kullan\u0131lm\u0131\u015f, e\u011fer amount 1 ise \"apple\" d\u00f6necek, de\u011fil ise \"apples\" d\u00f6necek. Yani pluralize de\u011fi\u015fkenine kontrolden d\u00f6nen atan\u0131yor. BEGIN ve END Ruby'de ilgin\u00e7 bir \u00f6zellik de, kodun \u00e7al\u0131\u015fmas\u0131ndan \u00f6nceye ve sonraya bir ek takabiliyoruz. A\u015fa\u011f\u0131daki \u00f6rnekte BEGIN block'undaki kodlar program ba\u015flad\u0131\u011f\u0131nda, END block'undaki kodlar program bitmeden hemen \u00f6nce \u00e7al\u0131\u015facakt\u0131r. BEGIN { puts \"Kodun ba\u015flama saati #{ Time . now . to_s } \" } END { puts \"Kodun bitme saati #{ Time . now . to_s } \" } def say_hello ( username ) \"Merhaba #{ username } \" end puts say_hello \"U\u011fur\" sleep 5 # zaman fark\u0131 i\u00e7in 5 saniye bekle # Kodun ba\u015flama saati 2014-08-04 09:30:24 +0300 # Merhaba U\u011fur # Kodun bitme saati 2014-08-04 09:30:29 +0300","title":"Conditional Statements (Ko\u015fullar)"},{"location":"bolum-03/04-conditional-statements-kosullar/#conditional-statements-kosullar","text":"Verilen ifadenin do\u011fru ya da yanl\u0131\u015f oldu\u011funun testi yap\u0131l\u0131r, ak\u0131\u015f true ya da false durumuna g\u00f6re seyreder.","title":"Conditional Statements (Ko\u015fullar)"},{"location":"bolum-03/04-conditional-statements-kosullar/#if-durumu","text":"if a == b then dedi\u011fimizde, E\u011fer \"a, b'ye e\u015fittir\" \u00f6nermesi do\u011fruysa demi\u015f oluruz. if a != b then dedi\u011fimizde, E\u011fer \"a, b'ye e\u015fit de\u011fildir\" \u00f6nermesi do\u011fruysa demi\u015f oluruz. Ayn\u0131 mant\u0131kta, a > b (\"a, b'den b\u00fcy\u00fckt\u00fcr\"), a < b (\"a, b'den k\u00fc\u00e7\u00fckt\u00fcr\"), a >= b (\"a, b'en b\u00fcy\u00fck ya da e\u015fittir\"), a <= b (\"a, b'den k\u00fc\u00e7\u00fck ya da e\u015fitse\") \u015feklinde \u00f6nermeler de kurulabilir.","title":"if durumu"},{"location":"bolum-03/04-conditional-statements-kosullar/#negatiflik-operatoru","text":"! i\u015fareti \u00f6nermenin sol taraf\u0131nda kullan\u0131l\u0131rsa, negatiflik ya da olumsuzluk kontrol\u00fc oldu\u011fu anlam\u0131ndad\u0131r. if !a == b then puts \"a, b'ye e\u015fit de\u011fil\" end ya da if !a > b then puts \"a, b'den b\u00fcy\u00fck de\u011fil\" end gibi kullan\u0131l\u0131r. \u0130\u00e7erideki \u00f6nermenin tersi do\u011fruysa demektir. if !a == b then \u00f6rne\u011fini daha iyi inceleyecek olursak. \u00d6rnekte \u00f6nerme \"a, b'ye e\u015fittir\" \u00f6nermesinin olumsuzu, yani \"a, b'ye e\u015fit de\u011fildir\"dir. Yani bu if durumu \u015funa kar\u015f\u0131l\u0131k gelmektedir: \"a, b'ye e\u015fit de\u011fildir\" do\u011fru ise","title":"Negatiflik Operat\u00f6r\u00fc"},{"location":"bolum-03/04-conditional-statements-kosullar/#coklu-kontrol","text":"E\u011fer \u00f6nermeler aras\u0131nda and ( ve ), or ( veya ) ya da bunlar\u0131n k\u0131sa yollar\u0131n\u0131 ( and i\u00e7in && , or i\u00e7in || ) kullan\u0131rsak birden fazla \u015feyi kontrol etmi\u015f oluruz. a = 5 b = 10 if a == 5 && b == 10 puts \"\u0130\u015fleme devam edebiliriz!\" end if a == 5 && b == 10 yerine if a == 5 and b == 10 de yazabilirdik. Ruby'nin konu\u015fma diline yak\u0131n olmas\u0131 sebebiyle, \u00e7ok daha anla\u015f\u0131l\u0131r kontrol sat\u0131rlar\u0131 yazmak m\u00fcmk\u00fcn. \u00d6rne\u011fin, E\u011fer, a, 5'e e\u015fitse Merhaba Yaz demek i\u00e7in ilk akla gelen y\u00f6ntem: if a == 5 puts \"Merhaba\" end ama bunu \u00e7ok daha basit hale getirebiliriz: puts \"Merhaba\" if a == 5 Tek sat\u0131rda, if i ko\u015ful sonucunda olacak \u015feyin sa\u011f\u0131na yazmak yeterlidir.","title":"\u00c7oklu Kontrol"},{"location":"bolum-03/04-conditional-statements-kosullar/#elsif","text":"Programlama mant\u0131\u011f\u0131nda pek de sevmedi\u011fim ( daha d\u00fczg\u00fcn y\u00f6ntemleri var ) ama bazen mecbur kald\u0131\u011f\u0131m\u0131z bir durumdur. if a == b puts \"a, b'ye e\u015fit\" elsif a < b puts \"a, b'den k\u00fc\u00e7\u00fck\" else puts \"a, b'ten b\u00fcy\u00fck\" end \u0130lk olarak a == b kontrol\u00fc yap\u0131l\u0131r, e\u011fer sonu\u00e7 false ise, a < b kontrol edilir, o da false ise en sondaki else devreye giriyor ve \u00e7\u0131kt\u0131 olarak \"a, b'ten b\u00fcy\u00fck\" yazd\u0131r\u0131l\u0131yor.","title":"elsif"},{"location":"bolum-03/04-conditional-statements-kosullar/#unless","text":"Bu, asl\u0131nda if in tersi gibi. Daha do\u011frusu if not anlam\u0131nda. E\u011fer a, b'ye e\u015fit de\u011filse demek i\u00e7in; unless a == b puts \"E\u015fit de\u011fil\" end Ayn\u0131 mant\u0131kta puts \"E\u015fit de\u011fil\" unless a == b \u015feklinde de yazabiliriz. Semantik olarak olumsuzluk kontrol\u00fc yaparken unless kullan\u0131lmas\u0131 \u00f6nerilir. Kodu okuma ve anlama a\u00e7\u0131s\u0131ndan kolay olmas\u0131 i\u00e7in.","title":"unless"},{"location":"bolum-03/04-conditional-statements-kosullar/#while-break-until-donguleri","text":"Tan\u0131mlanan \u00f6nerme true oldu\u011fu s\u00fcrece loop yani d\u00f6ng\u00fc \u00e7al\u0131\u015ft\u0131rma kontrol\u00fcd\u00fcr. i = 0 while i < 5 do puts \"i = #{ i } \" i += 1 end E\u011fer i += 1 yani i yi bir artt\u0131r, demezsek sonsuz d\u00f6ng\u00fcye gireriz. E\u011fer belli bir anda d\u00f6ng\u00fcy\u00fc k\u0131rmak istersek, i = 0 while i < 5 do puts \"i = #{ i } \" break if i == 3 i += 1 end i 3 oldu\u011funda loop devre d\u0131\u015f\u0131 kal\u0131r... Ayn\u0131 unless mant\u0131\u011f\u0131nda, until kullan\u0131l\u0131r loop'larda. i = 0 until i == 10 do puts \"i = #{ i } \" i += 1 end Yani i 10 'a e\u015fit olmad\u0131\u011f\u0131 s\u00fcrece bu loop \u00e7al\u0131\u015f\u0131r.","title":"while, break, until D\u00f6ng\u00fcleri"},{"location":"bolum-03/04-conditional-statements-kosullar/#case-when-yaps","text":"elsif yerine kullan\u0131lmas\u0131 muhtemel, daha anla\u015f\u0131l\u0131r kontrol mekanizmas\u0131d\u0131r. Hemen \u00f6rne\u011fe bakal\u0131m: computer = \"c64\" year = case computer when \"c64\" then \"1982\" when \"c16\" then \"1984\" when \"amiga\" then \"1985\" else \"Tarih bilinmiyor\" end puts \" #{ computer } \u00e7\u0131k\u0131\u015f y\u0131l\u0131 #{ year } \" # c64 \u00e7\u0131k\u0131\u015f y\u0131l\u0131 1982 Yukar\u0131daki kodu bir ton if , elsif ile yapmak yerine, when ve then ile daha anla\u015f\u0131l\u0131r hale getirdi\u011fimizi d\u00fc\u015f\u00fcn\u00fcyorum. when kullan\u0131rken range ( aral\u0131k ) belirmesi de yapma \u015fans\u0131 var. student_grade = 8 case student_grade when 0 puts \"\u00c7ok k\u00f6t\u00fc\" when 1 .. 4 puts \"Ba\u015far\u0131s\u0131z\" when 5 .. 7 puts \"\u0130yi\" when 8 .. 9 puts \"\u00c7ok \u0130yi\" when 10 puts \"S\u00fcper\" end E\u011fer not 1 ile 4 aral\u0131\u011f\u0131ndaysa (ve dahil ise) ya da 5 ile 7 aral\u0131\u011f\u0131ndaysa gibi bir kontrol ekledik.","title":"case, when Yap\u0131s\u0131"},{"location":"bolum-03/04-conditional-statements-kosullar/#for-dongusu","text":"1 'den 10 'a kadar (1 ve 10 dahil) bir d\u00f6ng\u00fc yapal\u0131m: for i in 1 .. 10 puts \"i = #{ i } \" end # i = 1 # i = 2 # i = 3 # i = 4 # i = 5 # i = 6 # i = 7 # i = 8 # i = 9 # i = 10 Ayn\u0131 i\u015fi \u00e7ok daha kolay yapman\u0131n yolunu 5.B\u00f6l\u00fcm 'de Iteration k\u0131sm\u0131nda g\u00f6rece\u011fiz!","title":"for D\u00f6ng\u00fcs\u00fc"},{"location":"bolum-03/04-conditional-statements-kosullar/#ternary-operatoru","text":"K\u0131salt\u0131lm\u0131\u015f if yap\u0131s\u0131d\u0131r. Hemen hemen pek \u00e7ok dilde kullan\u0131lan, E\u011fer \u015fu do\u011fru ise bu de\u011filse bu ifadesi i\u00e7in kullan\u0131l\u0131r. amount = 2 pluralize = amount == 1 ? \"apple\" : \"apples\" puts \" #{ amount } #{ pluralize } .\" Bu \u00f6rnekte Ternary olarak amount == 1 ? \"apple\" : \"apples\" kullan\u0131lm\u0131\u015f, e\u011fer amount 1 ise \"apple\" d\u00f6necek, de\u011fil ise \"apples\" d\u00f6necek. Yani pluralize de\u011fi\u015fkenine kontrolden d\u00f6nen atan\u0131yor.","title":"Ternary Operat\u00f6r\u00fc"},{"location":"bolum-03/04-conditional-statements-kosullar/#begin-ve-end","text":"Ruby'de ilgin\u00e7 bir \u00f6zellik de, kodun \u00e7al\u0131\u015fmas\u0131ndan \u00f6nceye ve sonraya bir ek takabiliyoruz. A\u015fa\u011f\u0131daki \u00f6rnekte BEGIN block'undaki kodlar program ba\u015flad\u0131\u011f\u0131nda, END block'undaki kodlar program bitmeden hemen \u00f6nce \u00e7al\u0131\u015facakt\u0131r. BEGIN { puts \"Kodun ba\u015flama saati #{ Time . now . to_s } \" } END { puts \"Kodun bitme saati #{ Time . now . to_s } \" } def say_hello ( username ) \"Merhaba #{ username } \" end puts say_hello \"U\u011fur\" sleep 5 # zaman fark\u0131 i\u00e7in 5 saniye bekle # Kodun ba\u015flama saati 2014-08-04 09:30:24 +0300 # Merhaba U\u011fur # Kodun bitme saati 2014-08-04 09:30:29 +0300","title":"BEGIN ve END"},{"location":"bolum-04/","text":"B\u00f6l\u00fcm 4 Bu b\u00f6l\u00fcmde Ruby'deki veri tipleri yani Data Types '\u0131 inceleyece\u011fiz. Object Number String Array Hash Symbol Class Module","title":"\u0130ndeks"},{"location":"bolum-04/#bolum-4","text":"Bu b\u00f6l\u00fcmde Ruby'deki veri tipleri yani Data Types '\u0131 inceleyece\u011fiz. Object Number String Array Hash Symbol Class Module","title":"B\u00f6l\u00fcm 4"},{"location":"bolum-04/01-object/","text":"Object (Nesne) Ruby, Object Oriented Programming 'in dibidir :) Her \u015fey nesnelerden olu\u015fur. Nas\u0131l m\u0131? hemen basit bir de\u011fi\u015fken olu\u015fturup i\u00e7ine bir tekst yazal\u0131m. mesaj = \"Merhaba\" mesaj de\u011fi\u015fkeninin t\u00fcr\u00fc ne? mesaj . class # => String Bu de\u011fi\u015fken String nesnesinden t\u00fcremi\u015f. Peki, String nereden geliyor? mesaj . class . superclass # => Object Dikkat ettiyseniz burada superclass kulland\u0131k. Yani bu hiyerar\u015fideki bir \u00fcst s\u0131n\u0131f\u0131 ar\u0131yoruz. Kar\u015f\u0131m\u0131za ne \u00e7\u0131kt\u0131? Object . Peki acaba Object nereden t\u00fcremi\u015f? mesaj . class . superclass . superclass # => BasicObject Hmmm.. Peki BasicObject nereden geliyor? mesaj . class . superclass . superclass . superclass # => nil \u0130\u015fte \u015fu anda dibi bulduk :) Demek ki hiyerar\u015fi; BasicObject > Object > String \u015feklinde bir hiyerar\u015fi s\u00f6z konusu. Peki, say\u0131larda durum ne? numara = 1 numara . class # => Fixnum numara . class . superclass # => Integer numara . class . superclass . superclass # => Numeric numara . class . superclass . superclass . superclass # => Object numara . class . superclass . superclass . superclass . superclass # => BasicObject numara . class . superclass . superclass . superclass . superclass . superclass # => nil Ufff... bir an i\u00e7in bitmeyecek sand\u0131m :) \u00c7ok basit bir say\u0131 tan\u0131mlas\u0131 yapt\u0131\u011f\u0131m\u0131zda bile, arka plandaki i\u015fleyi\u015f yukar\u0131daki gibi oluyor. Yani BasicObject > Object > Numeric > Integer > Fixnum \u015feklinde yine ana nesne BasicObject olmak ko\u015fuluyla uzun bir hiyerar\u015fi s\u00f6z konusu. Her \u015fey BasicObject den t\u00fcr\u00fcyor, bu y\u00fczden de asl\u0131nda her \u015fey bir Class dolay\u0131s\u0131yla bu durum dile \u00e7ok ciddi esneklik kazand\u0131r\u0131yor. Nesne Metodlar\u0131 (Object Instance Methods) \u015eimdi bo\u015f bir nesne olu\u015ftural\u0131m. Class b\u00f6l\u00fcm\u00fcnde daha detayl\u0131 g\u00f6rece\u011fimiz instantiate i\u015flemiyle new methodunu kullanarak; o = Object . new # => #<Object:0x007fe552099a68> o . __id__ # => 70311450299700 yapt\u0131\u011f\u0131m\u0131zda, olu\u015fan nesnenin haf\u0131zada unique ( yani bundan sadece bir tane ) bir identifier '\u0131 ( kabaca buna kimlik diyelim ) yani ID 'si oldu\u011funu g\u00f6r\u00fcr\u00fcz. __id__ yerine object_id yani o.object_id \u015feklinde de kullanabiliriz. E\u011fer hash method\u2019unu \u00e7a\u011f\u0131r\u0131rsak, Ruby bize ilgili objenin Fixnum t\u00fcr\u00fcnde say\u0131sal de\u011ferini \u00fcretir ve verir. o = Object . new # => #<Object:0x007f8c3b0a3420> o . __id__ # => 70120131336720 o . object_id # => 70120131336720 o . hash # => -229260864779029724 Neticede String de bir nesne ve; t = String . new ( \"Hello\" ) # => \"Hello\" t . __id__ # => 70170408456140 t . methods # => [:<=>, :==, :===, :eql?, :hash, :casecmp, :+, :*, :%, :[], :[]=, :insert, :length, :size, :bytesize, :empty?, :=~, :match, :succ, :succ!, :next, :next!, :upto, :index, :rindex, :replace, :clear, :chr, :getbyte, :setbyte, :byteslice, :scrub, :scrub!, :freeze, :to_i, :to_f, :to_s, :to_str, :inspect, :dump, :upcase, :downcase, :capitalize, :swapcase, :upcase!, :downcase!, :capitalize!, :swapcase!, :hex, :oct, :split, :lines, :bytes, :chars, :codepoints, :reverse, :reverse!, :concat, :<<, :prepend, :crypt, :intern, :to_sym, :ord, :include?, :start_with?, :end_with?, :scan, :ljust, :rjust, :center, :sub, :gsub, :chop, :chomp, :strip, :lstrip, :rstrip, :sub!, :gsub!, :chop!, :chomp!, :strip!, :lstrip!, :rstrip!, :tr, :tr_s, :delete, :squeeze, :count, :tr!, :tr_s!, :delete!, :squeeze!, :each_line, :each_byte, :each_char, :each_codepoint, :sum, :slice, :slice!, :partition, :rpartition, :encoding, :force_encoding, :b, :valid_encoding?, :ascii_only?, :unpack, :encode, :encode!, :to_r, :to_c, :>, :>=, :<, :<=, :between?, :nil?, :!~, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :singleton_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__] t . method ( :upcase ) . call # => \"HELLO\" t.methods ise String 'den t\u00fcreyen t ye ait t\u00fcm method\u2019lar\u0131 listeledik. Sonu\u00e7 Array ( Dizi ) olarak geldi ve bu dizinin t\u00fcm elemanlar\u0131 : i\u015faretiyle ba\u015fl\u0131yor. \u00c7\u00fcnk\u00fc bu elemanlar birer Symbol . t.method(:upcase).call da ise, t 'nin :upcase method\u2019unu call ile \u00e7a\u011f\u0131rd\u0131r. Asl\u0131nda yapt\u0131\u011f\u0131m\u0131z i\u015f: \"hello\".upcase ile birebir ayn\u0131. Acaba bu nesne ne? t.is_a?(String) # => true is_a? method\u2019u ile nesnenin t\u00fcr\u00fcn\u00fc kontrol edebiliriz. Di\u011fer dillerin pek \u00e7o\u011funda ( \u00f6zellikle Python ) bir i\u015fi yapman\u0131n bir ya da en fazla iki yolu varken, Ruby bu konuda \u00e7ok rahatt\u0131r. Bir i\u015fi yapman\u0131n her zaman birden fazla yolu olur ve bunlar\u0131n neredeyse hepsi do\u011frudur. ( Kullan\u0131ld\u0131\u011f\u0131 yere ve amaca ba\u011fl\u0131 olarak ) is_a? yerine kind_of? da kullanabiliriz! Bir nesneye ait hangi method'lar\u0131n oldu\u011funu; o = Object . new o . methods # => [:nil?, :===, :=~, :!~, :eql?, :hash, :<=>, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :to_s, :inspect, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :singleton_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__] o . public_methods # => [:nil?, :===, :=~, :!~, :eql?, :hash, :<=>, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :to_s, :inspect, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :singleton_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__] o . private_methods # => [:initialize_copy, :initialize_dup, :initialize_clone, :sprintf, :format, :Integer, :Float, :String, :Array, :Hash, :warn, :raise, :fail, :global_variables, :__method__, :__callee__, :__dir__, :eval, :local_variables, :iterator?, :block_given?, :catch, :throw, :loop, :respond_to_missing?, :trace_var, :untrace_var, :at_exit, :syscall, :open, :printf, :print, :putc, :puts, :gets, :readline, :select, :readlines, :`, :p, :test, :srand, :rand, :trap, :exec, :fork, :exit!, :system, :spawn, :sleep, :exit, :abort, :load, :require, :require_relative, :autoload, :autoload?, :proc, :lambda, :binding, :caller, :caller_locations, :Rational, :Complex, :set_trace_func, :gem, :gem_original_require, :initialize, :singleton_method_added, :singleton_method_removed, :singleton_method_undefined, :method_missing] o . protected_methods # => [] o . public_methods ( false ) # => [] public_methods default olarak public_methods(all=true) \u015feklinde \u00e7al\u0131\u015f\u0131r. E\u011fer parametre olarak false ge\u00e7ersek ve bu bizim olu\u015fturdu\u011fumuz bir nesne ise, sadece ilgili nesnenin public_method 'lar\u0131 geri d\u00f6ner. Ba\u015fta belirtti\u011fimiz gibi, basit bir nesne bile Object 'den t\u00fcredi\u011fi i\u00e7in ve default olarak bu t\u00fcreme esnas\u0131nda t\u00fcm \u00f6zellikler di\u011ferine ge\u00e7ti\u011fi i\u00e7in, sadece sizin method'lar\u0131n\u0131z\u0131 g\u00f6r\u00fcnt\u00fclemek a\u00e7\u0131s\u0131ndan false olay\u0131 \u00e7ok i\u015fe yarar. Method Missing Bence Ruby'nin en s\u00fcper \u00f6zelliklerinden biridir. Olmayan bir method'u \u00e7a\u011f\u0131rd\u0131\u011f\u0131n\u0131z zaman tetiklenen method method_missing method'udur. Ruby on Rails framework'\u00fc neredeyse bu mekanizma \u00fczerine kurulmu\u015ftur. 3 parametre al\u0131r; \u00e7a\u011f\u0131r\u0131lan method, e\u011fer parametre ge\u00e7ilmi\u015fse parametreler, e\u011fer block ge\u00e7ilmi\u015fse block. class User def method_missing ( method_name , * args , & block ) if method_name == :show_user_info \"This user has no information\" else \"You've called #{ method_name } , You've passed: #{ args } \" end end end u = User . new u . show_user_info # => \"This user has no information\" u . show_user_age # => \"You've called show_user_age, You've passed: []\" User ad\u0131nda bir Class'\u0131m\u0131z var. \u0130\u00e7inde hi\u00e7bir method tan\u0131ml\u0131 de\u011fil. u.show_user_info sat\u0131r\u0131nda, olmayan bir method'u \u00e7a\u011f\u0131r\u0131yoruz. Tan\u0131mlad\u0131\u011f\u0131m\u0131z method_missing method'u ile olmayan method \u00e7a\u011f\u0131r\u0131lmas\u0131n\u0131 yakal\u0131yoruz. E\u011fer show_user_info diye bir method \u00e7a\u011fr\u0131l\u0131rsa yakal\u0131yoruz, bunun d\u0131\u015f\u0131nda bir \u015fey olursa da method ad\u0131n\u0131 ve ge\u00e7ilen parametreleri g\u00f6steriyoruz. Bu sayede NoMethodError hatas\u0131 almadan i\u015fimize devam edebiliyoruz. Anlamak a\u00e7\u0131s\u0131ndan, Roman rakamlar\u0131 i\u00e7in bir s\u0131n\u0131f yapt\u0131\u011f\u0131n\u0131z\u0131 d\u00fc\u015f\u00fcn\u00fcn. Sadece \u00f6rnek olmas\u0131 i\u00e7in g\u00f6steriyorum, C,X ve M i\u00e7in; class Roman def roman_to_str ( str ) case str when \"x\" , \"X\" 10 when \"c\" , \"C\" 100 when \"m\" , \"M\" 1000 end end def method_missing ( method ) roman_to_str method . id2name end end r = Roman . new r . x # => 10 r . X # => 10 r . C # => 100 r . M # => 1000 Bunu geli\u015ftirip \"MMCX\" ya da \"III\" gibi ger\u00e7ek d\u00f6n\u00fc\u015ft\u00fcrme i\u015fini yapabilirsiniz. respond_to_missing? Yukar\u0131daki \u00f6rnekte, olmayan method'lar\u0131 \u00fcrettik. Peki, acaba bu olmayan method'lar\u0131 nas\u0131l \u00e7a\u011f\u0131rabilir ya da kontrol edebiliriz? Normalde, bir Class'\u0131n hangi method'u oldu\u011funu respond_to? ile \u00f6\u011freniyorduk. \u00d6rne\u011fe uygulayal\u0131m; r.C derken asl\u0131nda :C method'unu \u00e7a\u011f\u0131r\u0131yoruz. Peki b\u00f6yle bir method var m\u0131? r . method ( :C ) # => `method': undefined method `C' for class `Roman' (NameError) Nas\u0131l yani? peki kontrol edelim? r . respond_to? ( :C ) # => false \u00c7\u00fcnk\u00fc biz :C yi dinamik olarak \u00fcrettik ama \u00f6ylece ortada b\u0131rakt\u0131k. Yapmam\u0131z gereken respond_to_missing? ile gereken cevab\u0131 vermekti: class Roman def roman_to_str ( str ) case str when \"x\" , \"X\" 10 when \"c\" , \"C\" 100 when \"m\" , \"M\" 1000 end end def method_missing ( method ) roman_to_str method . id2name end def respond_to_missing? ( method_name , include_private = false ) [ :x , :X , :c , :C , :m , :M ]. include? ( method_name ) || super end end r . method ( :C ) # => #<Method: Roman#C> r . respond_to? ( :C ) # => true r . respond_to? ( :Q ) # => false # olmayan method","title":"Object"},{"location":"bolum-04/01-object/#object-nesne","text":"Ruby, Object Oriented Programming 'in dibidir :) Her \u015fey nesnelerden olu\u015fur. Nas\u0131l m\u0131? hemen basit bir de\u011fi\u015fken olu\u015fturup i\u00e7ine bir tekst yazal\u0131m. mesaj = \"Merhaba\" mesaj de\u011fi\u015fkeninin t\u00fcr\u00fc ne? mesaj . class # => String Bu de\u011fi\u015fken String nesnesinden t\u00fcremi\u015f. Peki, String nereden geliyor? mesaj . class . superclass # => Object Dikkat ettiyseniz burada superclass kulland\u0131k. Yani bu hiyerar\u015fideki bir \u00fcst s\u0131n\u0131f\u0131 ar\u0131yoruz. Kar\u015f\u0131m\u0131za ne \u00e7\u0131kt\u0131? Object . Peki acaba Object nereden t\u00fcremi\u015f? mesaj . class . superclass . superclass # => BasicObject Hmmm.. Peki BasicObject nereden geliyor? mesaj . class . superclass . superclass . superclass # => nil \u0130\u015fte \u015fu anda dibi bulduk :) Demek ki hiyerar\u015fi; BasicObject > Object > String \u015feklinde bir hiyerar\u015fi s\u00f6z konusu. Peki, say\u0131larda durum ne? numara = 1 numara . class # => Fixnum numara . class . superclass # => Integer numara . class . superclass . superclass # => Numeric numara . class . superclass . superclass . superclass # => Object numara . class . superclass . superclass . superclass . superclass # => BasicObject numara . class . superclass . superclass . superclass . superclass . superclass # => nil Ufff... bir an i\u00e7in bitmeyecek sand\u0131m :) \u00c7ok basit bir say\u0131 tan\u0131mlas\u0131 yapt\u0131\u011f\u0131m\u0131zda bile, arka plandaki i\u015fleyi\u015f yukar\u0131daki gibi oluyor. Yani BasicObject > Object > Numeric > Integer > Fixnum \u015feklinde yine ana nesne BasicObject olmak ko\u015fuluyla uzun bir hiyerar\u015fi s\u00f6z konusu. Her \u015fey BasicObject den t\u00fcr\u00fcyor, bu y\u00fczden de asl\u0131nda her \u015fey bir Class dolay\u0131s\u0131yla bu durum dile \u00e7ok ciddi esneklik kazand\u0131r\u0131yor.","title":"Object (Nesne)"},{"location":"bolum-04/01-object/#nesne-metodlar-object-instance-methods","text":"\u015eimdi bo\u015f bir nesne olu\u015ftural\u0131m. Class b\u00f6l\u00fcm\u00fcnde daha detayl\u0131 g\u00f6rece\u011fimiz instantiate i\u015flemiyle new methodunu kullanarak; o = Object . new # => #<Object:0x007fe552099a68> o . __id__ # => 70311450299700 yapt\u0131\u011f\u0131m\u0131zda, olu\u015fan nesnenin haf\u0131zada unique ( yani bundan sadece bir tane ) bir identifier '\u0131 ( kabaca buna kimlik diyelim ) yani ID 'si oldu\u011funu g\u00f6r\u00fcr\u00fcz. __id__ yerine object_id yani o.object_id \u015feklinde de kullanabiliriz. E\u011fer hash method\u2019unu \u00e7a\u011f\u0131r\u0131rsak, Ruby bize ilgili objenin Fixnum t\u00fcr\u00fcnde say\u0131sal de\u011ferini \u00fcretir ve verir. o = Object . new # => #<Object:0x007f8c3b0a3420> o . __id__ # => 70120131336720 o . object_id # => 70120131336720 o . hash # => -229260864779029724 Neticede String de bir nesne ve; t = String . new ( \"Hello\" ) # => \"Hello\" t . __id__ # => 70170408456140 t . methods # => [:<=>, :==, :===, :eql?, :hash, :casecmp, :+, :*, :%, :[], :[]=, :insert, :length, :size, :bytesize, :empty?, :=~, :match, :succ, :succ!, :next, :next!, :upto, :index, :rindex, :replace, :clear, :chr, :getbyte, :setbyte, :byteslice, :scrub, :scrub!, :freeze, :to_i, :to_f, :to_s, :to_str, :inspect, :dump, :upcase, :downcase, :capitalize, :swapcase, :upcase!, :downcase!, :capitalize!, :swapcase!, :hex, :oct, :split, :lines, :bytes, :chars, :codepoints, :reverse, :reverse!, :concat, :<<, :prepend, :crypt, :intern, :to_sym, :ord, :include?, :start_with?, :end_with?, :scan, :ljust, :rjust, :center, :sub, :gsub, :chop, :chomp, :strip, :lstrip, :rstrip, :sub!, :gsub!, :chop!, :chomp!, :strip!, :lstrip!, :rstrip!, :tr, :tr_s, :delete, :squeeze, :count, :tr!, :tr_s!, :delete!, :squeeze!, :each_line, :each_byte, :each_char, :each_codepoint, :sum, :slice, :slice!, :partition, :rpartition, :encoding, :force_encoding, :b, :valid_encoding?, :ascii_only?, :unpack, :encode, :encode!, :to_r, :to_c, :>, :>=, :<, :<=, :between?, :nil?, :!~, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :singleton_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__] t . method ( :upcase ) . call # => \"HELLO\" t.methods ise String 'den t\u00fcreyen t ye ait t\u00fcm method\u2019lar\u0131 listeledik. Sonu\u00e7 Array ( Dizi ) olarak geldi ve bu dizinin t\u00fcm elemanlar\u0131 : i\u015faretiyle ba\u015fl\u0131yor. \u00c7\u00fcnk\u00fc bu elemanlar birer Symbol . t.method(:upcase).call da ise, t 'nin :upcase method\u2019unu call ile \u00e7a\u011f\u0131rd\u0131r. Asl\u0131nda yapt\u0131\u011f\u0131m\u0131z i\u015f: \"hello\".upcase ile birebir ayn\u0131. Acaba bu nesne ne? t.is_a?(String) # => true is_a? method\u2019u ile nesnenin t\u00fcr\u00fcn\u00fc kontrol edebiliriz. Di\u011fer dillerin pek \u00e7o\u011funda ( \u00f6zellikle Python ) bir i\u015fi yapman\u0131n bir ya da en fazla iki yolu varken, Ruby bu konuda \u00e7ok rahatt\u0131r. Bir i\u015fi yapman\u0131n her zaman birden fazla yolu olur ve bunlar\u0131n neredeyse hepsi do\u011frudur. ( Kullan\u0131ld\u0131\u011f\u0131 yere ve amaca ba\u011fl\u0131 olarak ) is_a? yerine kind_of? da kullanabiliriz! Bir nesneye ait hangi method'lar\u0131n oldu\u011funu; o = Object . new o . methods # => [:nil?, :===, :=~, :!~, :eql?, :hash, :<=>, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :to_s, :inspect, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :singleton_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__] o . public_methods # => [:nil?, :===, :=~, :!~, :eql?, :hash, :<=>, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :to_s, :inspect, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :singleton_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__] o . private_methods # => [:initialize_copy, :initialize_dup, :initialize_clone, :sprintf, :format, :Integer, :Float, :String, :Array, :Hash, :warn, :raise, :fail, :global_variables, :__method__, :__callee__, :__dir__, :eval, :local_variables, :iterator?, :block_given?, :catch, :throw, :loop, :respond_to_missing?, :trace_var, :untrace_var, :at_exit, :syscall, :open, :printf, :print, :putc, :puts, :gets, :readline, :select, :readlines, :`, :p, :test, :srand, :rand, :trap, :exec, :fork, :exit!, :system, :spawn, :sleep, :exit, :abort, :load, :require, :require_relative, :autoload, :autoload?, :proc, :lambda, :binding, :caller, :caller_locations, :Rational, :Complex, :set_trace_func, :gem, :gem_original_require, :initialize, :singleton_method_added, :singleton_method_removed, :singleton_method_undefined, :method_missing] o . protected_methods # => [] o . public_methods ( false ) # => [] public_methods default olarak public_methods(all=true) \u015feklinde \u00e7al\u0131\u015f\u0131r. E\u011fer parametre olarak false ge\u00e7ersek ve bu bizim olu\u015fturdu\u011fumuz bir nesne ise, sadece ilgili nesnenin public_method 'lar\u0131 geri d\u00f6ner. Ba\u015fta belirtti\u011fimiz gibi, basit bir nesne bile Object 'den t\u00fcredi\u011fi i\u00e7in ve default olarak bu t\u00fcreme esnas\u0131nda t\u00fcm \u00f6zellikler di\u011ferine ge\u00e7ti\u011fi i\u00e7in, sadece sizin method'lar\u0131n\u0131z\u0131 g\u00f6r\u00fcnt\u00fclemek a\u00e7\u0131s\u0131ndan false olay\u0131 \u00e7ok i\u015fe yarar.","title":"Nesne Metodlar\u0131 (Object Instance Methods)"},{"location":"bolum-04/01-object/#method-missing","text":"Bence Ruby'nin en s\u00fcper \u00f6zelliklerinden biridir. Olmayan bir method'u \u00e7a\u011f\u0131rd\u0131\u011f\u0131n\u0131z zaman tetiklenen method method_missing method'udur. Ruby on Rails framework'\u00fc neredeyse bu mekanizma \u00fczerine kurulmu\u015ftur. 3 parametre al\u0131r; \u00e7a\u011f\u0131r\u0131lan method, e\u011fer parametre ge\u00e7ilmi\u015fse parametreler, e\u011fer block ge\u00e7ilmi\u015fse block. class User def method_missing ( method_name , * args , & block ) if method_name == :show_user_info \"This user has no information\" else \"You've called #{ method_name } , You've passed: #{ args } \" end end end u = User . new u . show_user_info # => \"This user has no information\" u . show_user_age # => \"You've called show_user_age, You've passed: []\" User ad\u0131nda bir Class'\u0131m\u0131z var. \u0130\u00e7inde hi\u00e7bir method tan\u0131ml\u0131 de\u011fil. u.show_user_info sat\u0131r\u0131nda, olmayan bir method'u \u00e7a\u011f\u0131r\u0131yoruz. Tan\u0131mlad\u0131\u011f\u0131m\u0131z method_missing method'u ile olmayan method \u00e7a\u011f\u0131r\u0131lmas\u0131n\u0131 yakal\u0131yoruz. E\u011fer show_user_info diye bir method \u00e7a\u011fr\u0131l\u0131rsa yakal\u0131yoruz, bunun d\u0131\u015f\u0131nda bir \u015fey olursa da method ad\u0131n\u0131 ve ge\u00e7ilen parametreleri g\u00f6steriyoruz. Bu sayede NoMethodError hatas\u0131 almadan i\u015fimize devam edebiliyoruz. Anlamak a\u00e7\u0131s\u0131ndan, Roman rakamlar\u0131 i\u00e7in bir s\u0131n\u0131f yapt\u0131\u011f\u0131n\u0131z\u0131 d\u00fc\u015f\u00fcn\u00fcn. Sadece \u00f6rnek olmas\u0131 i\u00e7in g\u00f6steriyorum, C,X ve M i\u00e7in; class Roman def roman_to_str ( str ) case str when \"x\" , \"X\" 10 when \"c\" , \"C\" 100 when \"m\" , \"M\" 1000 end end def method_missing ( method ) roman_to_str method . id2name end end r = Roman . new r . x # => 10 r . X # => 10 r . C # => 100 r . M # => 1000 Bunu geli\u015ftirip \"MMCX\" ya da \"III\" gibi ger\u00e7ek d\u00f6n\u00fc\u015ft\u00fcrme i\u015fini yapabilirsiniz. respond_to_missing? Yukar\u0131daki \u00f6rnekte, olmayan method'lar\u0131 \u00fcrettik. Peki, acaba bu olmayan method'lar\u0131 nas\u0131l \u00e7a\u011f\u0131rabilir ya da kontrol edebiliriz? Normalde, bir Class'\u0131n hangi method'u oldu\u011funu respond_to? ile \u00f6\u011freniyorduk. \u00d6rne\u011fe uygulayal\u0131m; r.C derken asl\u0131nda :C method'unu \u00e7a\u011f\u0131r\u0131yoruz. Peki b\u00f6yle bir method var m\u0131? r . method ( :C ) # => `method': undefined method `C' for class `Roman' (NameError) Nas\u0131l yani? peki kontrol edelim? r . respond_to? ( :C ) # => false \u00c7\u00fcnk\u00fc biz :C yi dinamik olarak \u00fcrettik ama \u00f6ylece ortada b\u0131rakt\u0131k. Yapmam\u0131z gereken respond_to_missing? ile gereken cevab\u0131 vermekti: class Roman def roman_to_str ( str ) case str when \"x\" , \"X\" 10 when \"c\" , \"C\" 100 when \"m\" , \"M\" 1000 end end def method_missing ( method ) roman_to_str method . id2name end def respond_to_missing? ( method_name , include_private = false ) [ :x , :X , :c , :C , :m , :M ]. include? ( method_name ) || super end end r . method ( :C ) # => #<Method: Roman#C> r . respond_to? ( :C ) # => true r . respond_to? ( :Q ) # => false # olmayan method","title":"Method Missing"},{"location":"bolum-04/02-number/","text":"Number (Say\u0131lar) Say\u0131lar, temel \u00f6\u011fe olmay\u0131p, direk nesneden t\u00fcremi\u015flerdir. T\u00fcredikleri nesne de Ruby'nin say\u0131lar i\u00e7in olan base class '\u0131d\u0131r. \u00d6rne\u011fin 3 say\u0131s\u0131na bakal\u0131m: 3 . class # => Fixnum 3 . class . superclass # => Integer 3 . class . superclass . superclass # => Numeric 3 . class . superclass . superclass . superclass # => Object Numeric s\u0131n\u0131f\u0131d\u0131r as\u0131l olan. \u0130lk t\u00fcredi\u011fi s\u0131n\u0131f\u0131 Fixnum d\u0131r. \u00d6rnekte g\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi; Fixnum > Integer > Numeric \u015feklinde bir hiyera\u015fi s\u00f6z konusudur. 2014 . class # => Fixnum 2_014 . class # => Fixnum 201 . 4 . class # => Float 1 . 2 e3 . class # => Float 7 e4 . class # => Float 7 E - 4 . class # => Float 0664 . class # => Fixnum 0xfff . class # => Fixnum 0b1111 . class # => Fixnum 45678327041234321312 . class # => Bignum Ruby'de say\u0131 i\u015flerinde _ hi\u00e7bir etki yapmaz. Bir \u015fekilde okumay\u0131 kolayla\u015ft\u0131rmak i\u00e7in kullan\u0131l\u0131r. \u00d6rnekteki 2014 ile 2_014 ayn\u0131 \u015feydir. B\u00fcy\u00fck say\u0131lar\u0131 yazarken; 1_345_201 gibi bir ifade 1345201 'dir asl\u0131nda. Ondal\u0131k say\u0131larda . kullan\u0131l\u0131r. Octal yani 8'lik say\u0131 sistemi i\u00e7in direk 0 ile 0664 gibi kullan\u0131l\u0131r. 16'l\u0131k yani Hexadecimal say\u0131 sistemi i\u00e7in, css d\u00fcnyas\u0131ndan tan\u0131d\u0131\u011f\u0131n\u0131z beyaz rengini ifade etmek i\u00e7in $fff yerine 0xfff \u015feklinde bir kullan\u0131m mevcut. 2'lik yani Binary say\u0131 sistemi i\u00e7in 0b ile ba\u015flamak yeterlidir. Scientific Notation ifadeleri i\u00e7in de 1.2e3 ya da 7e4 gibi kullan\u0131mlar m\u00fcmk\u00fcnd\u00fcr. Number Method'lar\u0131 5 say\u0131s\u0131 Fixnum s\u0131n\u0131f\u0131ndand\u0131r ve neticede \u00fcst s\u0131n\u0131flar\u0131; Numeric -> Integer -> Fixnum \u015feklinde oldu\u011fu i\u00e7in ( en \u00fcsttte Numeric ) ilgili \u00fcst s\u0131n\u0131flar\u0131n method'lar\u0131 da Fixnum taraf\u0131ndan kullan\u0131labilir durumdad\u0131r. Her zamanki gibi, acaba bu s\u0131n\u0131fa ait methodlar neymi\u015f? dedi\u011fimiz an bir ton method gelir kar\u015f\u0131m\u0131za; 5 . methods # => [ :to_s , :inspect , :-@ , :+ , :- , :* , :/ , :div , :% , :modulo , :divmod , :fdiv , :** , :abs , :magnitude , :== , :=== , :<=> , :> , :>= , :< , :< = , :~ , :& , :| , :^ , :[] , :<< , :>> , :to_f , :size , :bit_length , :zero? , :odd? , :even? , :succ , :integer? , :upto , :downto , :times , :next , :pred , :chr , :ord , :to_i , :to_int , :floor , :ceil , :truncate , :round , :gcd , :lcm , :gcdlcm , :numerator , :denominator , :to_r , :rationalize , :singleton_method_added , :coerce , :i , :+@ , :eql? , :remainder , :real? , :nonzero? , :step , :quo , :to_c , :real , :imaginary , :imag , :abs2 , :arg , :angle , :phase , :rectangular , :rect , :polar , :conjugate , :conj , :between? , :nil? , : =~ , : !~ , :hash , :class , :singleton_class , :clone , :dup , :taint , :tainted? , :untaint , :untrust , :untrusted? , :trust , :freeze , :frozen? , :methods , :singleton_methods , :protected_methods , :private_methods , :public_methods , :instance_variables , :instance_variable_get , :instance_variable_set , :instance_variable_defined? , :remove_instance_variable , :instance_of? , :kind_of? , :is_a? , :tap , :send , :public_send , :respond_to? , :extend , :display , :method , :public_method , :singleton_method , :define_singleton_method , :object_id , :to_enum , :enum_for , :equal? , : ! , : != , :instance_eval , :instance_exec , :__send__ , :__id__ , ] Bunlar\u0131n i\u00e7inden en s\u0131k kullan\u0131lanlara ve kullan\u0131m \u015fekillerine de\u011finece\u011fim. 5 . to_s # => \"5\" # Say\u0131sal de\u011feri String'e \u00e7evirdik - 5 . abs # => 5 # Mutlak de\u011fer 5 . zero? # => false # S\u0131f\u0131r m\u0131? 5 . even? # => false # \u00c7ift say\u0131 m\u0131? 5 . odd? # => true # Tek say\u0131 m\u0131? 5 . next # => 6 # Sonraki say\u0131? 5 . pred # => 4 # \u00d6nceki say\u0131? 3 . 14 . floor # => 3 # Taban de\u011feri 3 . 14 . ceil # => 4 # Tavan de\u011feri 1 . 49 . round # => 1 1 . 51 . round # => 2 # Yuvarlama 1 . bit_length # => 1 15 . bit_length # => 4 255 . bit_length # => 8 # Bit cinsinden uzunlu\u011fu/boyu 1 . size # => 8 10 . size # => 8 10242048 . size # => 8 1024204810242048102420481024 . size # => 12 # Byte cinsinden kaplad\u0131\u011f\u0131 yer upto , downto gibi iterasyonla ilgili olanlar\u0131 Enumeration ve Iteration b\u00f6l\u00fcm\u00fcnde g\u00f6rece\u011fiz!","title":"Number"},{"location":"bolum-04/02-number/#number-saylar","text":"Say\u0131lar, temel \u00f6\u011fe olmay\u0131p, direk nesneden t\u00fcremi\u015flerdir. T\u00fcredikleri nesne de Ruby'nin say\u0131lar i\u00e7in olan base class '\u0131d\u0131r. \u00d6rne\u011fin 3 say\u0131s\u0131na bakal\u0131m: 3 . class # => Fixnum 3 . class . superclass # => Integer 3 . class . superclass . superclass # => Numeric 3 . class . superclass . superclass . superclass # => Object Numeric s\u0131n\u0131f\u0131d\u0131r as\u0131l olan. \u0130lk t\u00fcredi\u011fi s\u0131n\u0131f\u0131 Fixnum d\u0131r. \u00d6rnekte g\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi; Fixnum > Integer > Numeric \u015feklinde bir hiyera\u015fi s\u00f6z konusudur. 2014 . class # => Fixnum 2_014 . class # => Fixnum 201 . 4 . class # => Float 1 . 2 e3 . class # => Float 7 e4 . class # => Float 7 E - 4 . class # => Float 0664 . class # => Fixnum 0xfff . class # => Fixnum 0b1111 . class # => Fixnum 45678327041234321312 . class # => Bignum Ruby'de say\u0131 i\u015flerinde _ hi\u00e7bir etki yapmaz. Bir \u015fekilde okumay\u0131 kolayla\u015ft\u0131rmak i\u00e7in kullan\u0131l\u0131r. \u00d6rnekteki 2014 ile 2_014 ayn\u0131 \u015feydir. B\u00fcy\u00fck say\u0131lar\u0131 yazarken; 1_345_201 gibi bir ifade 1345201 'dir asl\u0131nda. Ondal\u0131k say\u0131larda . kullan\u0131l\u0131r. Octal yani 8'lik say\u0131 sistemi i\u00e7in direk 0 ile 0664 gibi kullan\u0131l\u0131r. 16'l\u0131k yani Hexadecimal say\u0131 sistemi i\u00e7in, css d\u00fcnyas\u0131ndan tan\u0131d\u0131\u011f\u0131n\u0131z beyaz rengini ifade etmek i\u00e7in $fff yerine 0xfff \u015feklinde bir kullan\u0131m mevcut. 2'lik yani Binary say\u0131 sistemi i\u00e7in 0b ile ba\u015flamak yeterlidir. Scientific Notation ifadeleri i\u00e7in de 1.2e3 ya da 7e4 gibi kullan\u0131mlar m\u00fcmk\u00fcnd\u00fcr.","title":"Number (Say\u0131lar)"},{"location":"bolum-04/02-number/#number-methodlar","text":"5 say\u0131s\u0131 Fixnum s\u0131n\u0131f\u0131ndand\u0131r ve neticede \u00fcst s\u0131n\u0131flar\u0131; Numeric -> Integer -> Fixnum \u015feklinde oldu\u011fu i\u00e7in ( en \u00fcsttte Numeric ) ilgili \u00fcst s\u0131n\u0131flar\u0131n method'lar\u0131 da Fixnum taraf\u0131ndan kullan\u0131labilir durumdad\u0131r. Her zamanki gibi, acaba bu s\u0131n\u0131fa ait methodlar neymi\u015f? dedi\u011fimiz an bir ton method gelir kar\u015f\u0131m\u0131za; 5 . methods # => [ :to_s , :inspect , :-@ , :+ , :- , :* , :/ , :div , :% , :modulo , :divmod , :fdiv , :** , :abs , :magnitude , :== , :=== , :<=> , :> , :>= , :< , :< = , :~ , :& , :| , :^ , :[] , :<< , :>> , :to_f , :size , :bit_length , :zero? , :odd? , :even? , :succ , :integer? , :upto , :downto , :times , :next , :pred , :chr , :ord , :to_i , :to_int , :floor , :ceil , :truncate , :round , :gcd , :lcm , :gcdlcm , :numerator , :denominator , :to_r , :rationalize , :singleton_method_added , :coerce , :i , :+@ , :eql? , :remainder , :real? , :nonzero? , :step , :quo , :to_c , :real , :imaginary , :imag , :abs2 , :arg , :angle , :phase , :rectangular , :rect , :polar , :conjugate , :conj , :between? , :nil? , : =~ , : !~ , :hash , :class , :singleton_class , :clone , :dup , :taint , :tainted? , :untaint , :untrust , :untrusted? , :trust , :freeze , :frozen? , :methods , :singleton_methods , :protected_methods , :private_methods , :public_methods , :instance_variables , :instance_variable_get , :instance_variable_set , :instance_variable_defined? , :remove_instance_variable , :instance_of? , :kind_of? , :is_a? , :tap , :send , :public_send , :respond_to? , :extend , :display , :method , :public_method , :singleton_method , :define_singleton_method , :object_id , :to_enum , :enum_for , :equal? , : ! , : != , :instance_eval , :instance_exec , :__send__ , :__id__ , ] Bunlar\u0131n i\u00e7inden en s\u0131k kullan\u0131lanlara ve kullan\u0131m \u015fekillerine de\u011finece\u011fim. 5 . to_s # => \"5\" # Say\u0131sal de\u011feri String'e \u00e7evirdik - 5 . abs # => 5 # Mutlak de\u011fer 5 . zero? # => false # S\u0131f\u0131r m\u0131? 5 . even? # => false # \u00c7ift say\u0131 m\u0131? 5 . odd? # => true # Tek say\u0131 m\u0131? 5 . next # => 6 # Sonraki say\u0131? 5 . pred # => 4 # \u00d6nceki say\u0131? 3 . 14 . floor # => 3 # Taban de\u011feri 3 . 14 . ceil # => 4 # Tavan de\u011feri 1 . 49 . round # => 1 1 . 51 . round # => 2 # Yuvarlama 1 . bit_length # => 1 15 . bit_length # => 4 255 . bit_length # => 8 # Bit cinsinden uzunlu\u011fu/boyu 1 . size # => 8 10 . size # => 8 10242048 . size # => 8 1024204810242048102420481024 . size # => 12 # Byte cinsinden kaplad\u0131\u011f\u0131 yer upto , downto gibi iterasyonla ilgili olanlar\u0131 Enumeration ve Iteration b\u00f6l\u00fcm\u00fcnde g\u00f6rece\u011fiz!","title":"Number Method'lar\u0131"},{"location":"bolum-04/03-string/","text":"String Kabaca, insanlar\u0131n anlayaca\u011f\u0131 \u015fekilde tekst / metin bilgisi i\u00e7eren nesnelerdir. \u00d6rne\u011fin; m = \"Merhaba\" m . class # => String \u015feklindedir. Tan\u0131mlama yaparken tek ya da \u00e7ift t\u0131rnak kullan\u0131labilir ama aralar\u0131nda fark vard\u0131r. Expression Substitution ya da String Interpolation olarak ge\u00e7en, String i\u00e7inde de\u011fi\u015fken kullan\u0131m\u0131 esnas\u0131nda \u00e7ift t\u0131rnak kullanman\u0131z gerekir. m = \"Merhaba\" puts \" #{ m } U\u011fur\" # Merhaba U\u011fur puts ' #{ m } U\u011fur' # #{m} U\u011fur Tek t\u0131rnak kulland\u0131\u011f\u0131m\u0131z \u00f6rnekte #{m} de\u011fi\u015fkeni i\u015flenmeden oldu\u011fu gibi \u00e7\u0131kt\u0131 vermi\u015ftir. Ayn\u0131 \u015fekilde escape codes yani g\u00f6r\u00fcnmeyen \u00f6zel karakterleri de sadece \u00e7ift t\u0131rnak i\u00e7inde kullanmak m\u00fcmk\u00fcnd\u00fcr. \u00c7ift t\u0131rnak i\u00e7inde kullan\u0131lan #{BURAYA RUBY KODU GEL\u0130R} \u00e7ok i\u015fe yarar. { ve } aras\u0131nda kod \u00e7al\u0131\u015ft\u0131rmam\u0131z\u0131 sa\u011flar. puts \"Saat: #{ Time . now } \" # Saat: 2014-08-12 10:37:22 +0300 dedi\u011fimizde; Ruby Kernel'dan Time nesnesinin now method'unu \u00e7al\u0131\u015ft\u0131rm\u0131\u015f oluruz. puts \"Merhaba \\n D\u00fcnya\" # Merhaba # D\u00fcnya \\n New Line ya da Line Feed ya da yeni sat\u0131ra ge\u00e7me karakteri \u00e7ift t\u0131rnakta \u00e7al\u0131\u015f\u0131r. Escape Kod Anlam\u0131 \\n Yeni sat\u0131r (0x0a) \\s Bo\u015fluk (0x20) \\r Sat\u0131r Ba\u015f\u0131 (0x0d) \\t Tab Karakteri (0x09) \\v Dikey Tab (0x0b) \\f Formfeed (0x0c) \\b Backspace (Bir geri) (0x08) \\a Bell/Alert (Uyar\u0131) (0x07) \\e Escape (0x1b) \\nnn Octal, 8'lik de\u011fer \\xnn Hexadecimal, 16'l\u0131k de\u011fer \\unnnn Unicode: U+nnnn (Ruby 1.9+) \\cx Control-x \\C-x Control-x \\M-x Meta-x \\M-\\C-x Meta-Control-x \\x x'in kendisi (\\\" \u00e7ift t\u0131rnak demektir.) String'ler byte array 'lerden olu\u015fur yani elemanlar\u0131 byte cinsinden dizidir asl\u0131nda. m = \"\" m << 65 puts m # A m bo\u015f bir String, diziye eleman ekler gibi ( << diziye eleman ekler, az sonra g\u00f6rece\u011fiz ) i\u00e7ine 65 ekledik. Bu A harfinin 10'luk say\u0131 sistemindeki ASCII de\u011feridir. Asl\u0131nda m = \"A\" yapt\u0131k :) E\u011fer 65 in karakter setindeki de\u011feri neydi? dersek put 65.chr yapt\u0131\u011f\u0131m\u0131zda bize A d\u00f6ner. 0 ile 255 aras\u0131 de\u011ferlerdir bunlar. Daha ilgin\u00e7 bir olay; puts \"\u00f6z\" \"y\u0131l\" \"maz\" \"el\" # \u00f6zy\u0131lmazel yani \"tekst\" \"tekst\" \"tekst\" \u015fekinde bir kullan\u0131m mevcuttur. String Literals (String Kal\u0131plar\u0131) Ruby'de, yine di\u011fer dillerde olmayan ilgin\u00e7 bir \u00f6zellik. % i\u015fareti ve sonras\u0131nda gelen baz\u0131 karakterler yard\u0131m\u0131yla enteresan \u015feyler yapmak m\u00fcmk\u00fcn: % S\u00fcsl\u00fc parantezler aras\u0131nda kalan her \u015fey concat ( yani toplanarak ) edilir ve String olarak \u00e7\u0131kt\u0131 verir ve t\u0131rnaklar\u0131 escape eder. %{Merhaba D\u00fcnya Ben vigo nas\u0131ls\u0131n\u0131z?} # => \"Merhaba D\u00fcnya Ben vigo nas\u0131ls\u0131n\u0131z?\" %{Bu i\u015flemlerin %80'i \"uydurma\"} # => \"Bu i\u015flemlerin %80'i \\\"uydurma\\\"\" ayn\u0131 i\u015fi; %|Merhaba D\u00fcnya Ben vigo nas\u0131ls\u0131n\u0131z?| s\u00fcsl\u00fc parantez yerine pipe | kullanarak da yapabilirsiniz! %w H\u0131zl\u0131ca Array \u00fcretmeyi sa\u011flar: %w{foo bar baz} # => [\"foo\", \"bar\", \"baz\"] %w{foo bar baz} . class # => Array %i \u0130\u00e7inde Symbol olan Array \u00fcretir: % i { foo bar baz } # => [:foo, :bar, :baz] %q ve %Q q tek t\u0131rnak, Q \u00e7ift t\u0131rnakla sarmalam\u0131\u015f gibi yapar: person = \"U\u011fur\" %q{Merhaba #{person}} # => \"Merhaba \\#{person}\" %Q{Merhaba #{ person } } # => \"Merhaba U\u011fur\" %s Symbol 'e \u00e7evirir: %s{my_variable} # => :my_variable %s{email} # => :email %r Regular Expression 'a \u00e7evirir: %r{(.*)hello}i # => /(.*)hello/i %x Ruby'de back tick kullanarak shell komutu \u00e7al\u0131\u015ft\u0131rabilirsiniz. Yani Linux ve Mac kullanan okuyucular Terminal ile ha\u015f\u0131r-ne\u015fir olmu\u015flard\u0131r. \u00d6rne\u011fin, bulundu\u011funuz dizindeki dosya listesini almak i\u00e7in ls komutunu kullan\u0131rs\u0131n\u0131z. \u00d6rne\u011fin kendi home dizinimde ls yapt\u0131\u011f\u0131mda ( OSX kullan\u0131yorum ) $ ls -1 # alt alta listemelek i\u00e7in Applications Desktop Development Documents Dotfiles Downloads Library VirtualBox VMs Works bin gibi bir liste al\u0131yorum. Yapaca\u011f\u0131m bir Ruby uygulamas\u0131nda; %x{ls -1 $HOME} # => \"Applications\\nDesktop\\nDevelopment\\nDocuments\\nDotfiles\\nDownloads\\nLibrary\\nVirtualBox VMs\\nWorks\\nbin\\n\" T\u00fcm liste tek bir String olarak geldi ve \\n karakteri ile birle\u015fti \u00e7\u00fcnki sonu\u00e7 alt alta sat\u0131r sat\u0131r geldi. E\u011fer; %x{ls -1 $HOME} . split ( \" \\n \" ) deseydim sonu\u00e7 bana dizi olarak gelecekti! # [\"Applications\", \"Desktop\", \"Development\", \"Documents\", \"Dotfiles\", \"Downloads\", \"Library\", \"VirtualBox VMs\", \"Works\", \"bin\"] %x{ruby --copyright} # => \"ruby - Copyright (C) 1993-2014 Yukihiro Matsumoto\\n\" Here Document Kullan\u0131m\u0131 Uzun metin kullan\u0131mlar\u0131nda \u00e7ok i\u015fe yarar: mesaj = << END Merhaba nas\u0131ls\u0131n\u0131z? Biz de \u00e7ok iyiyiz G\u00f6r\u00fc\u015f\u00fcr\u00fcz! END puts mesaj # Merhaba nas\u0131ls\u0131n\u0131z? # Biz de \u00e7ok iyiyiz # G\u00f6r\u00fc\u015f\u00fcr\u00fcz! Bu \u00f6rnekte mesaj = <<END ile END kelimesini g\u00f6rene kadar i\u00e7inde ne varsa kullan diyoruz! Daha da \u00e7\u0131lg\u0131n bir kullan\u0131m \u015fekli; mesaj = [<< B\u0130R , << \u0130 K\u0130 , << \u00dc\u00c7 ] Bu Bir B\u0130R Bu iki .... \u0130 K\u0130 Bu da \u00fc\u00fc\u00fc\u00fc\u00fc\u00fc\u00fc\u00fc\u00e7 \u00dc\u00c7 puts mesaj # - Bu Bir # - Bu iki.... # - Bu da \u00fc\u00fc\u00fc\u00fc\u00fc\u00fc\u00fc\u00fc\u00e7 String Method'lar\u0131 String % arg\u00fcman -> yeni String \"Merhaba %s\" % \"U\u011fur\" # => \"Merhaba U\u011fur\" \"Say\u0131: %010d\" % 2014 # => \"Say\u0131: 0000002014\" \"Kullan\u0131c\u0131 Ad\u0131: %s, E-Posta: %s\" % [ \"vigo\" , \"vigo@foo.com\" ] # => \"Kullan\u0131c\u0131 Ad\u0131: vigo, E-Posta: vigo@foo.com\" \"Merhaba %{username}!\" % { :username => 'vigo' } # => \"Merhaba vigo!\" Keza bu method, printf , sprintf gibi, String Format mant\u0131\u011f\u0131nda \u00e7al\u0131\u015f\u0131r. \"Say\u0131: %010d\" % 2014 \u00f6rne\u011finde %010d asl\u0131nda 10 basamakl\u0131, 0 ile pad edilmi\u015f \u015fekilde g\u00f6ster anlam\u0131ndad\u0131r. 2014 4 basamakl\u0131d\u0131r, solunda 6 tane s\u0131f\u0131r gelmi\u015ftir. String * say\u0131 -> yeni String String ile say\u0131y\u0131 \u00e7arpmak m\u00fcmk\u00fcn! \"Merhaba!\" * 3 # => \"Merhaba!Merhaba!Merhaba!\" \"Merhaba!\" * 0 # => \"\" String + String -> yeni String \"Merhaba\" + \" \" + \"D\u00fcnya\" # => \"Merhaba D\u00fcnya\" String << say\u0131 -> String / String << nesne -> String a = \"Merhaba\" a << \" d\u00fcnya\" # => \"Merhaba d\u00fcnya\" a # => \"Merhaba d\u00fcnya\" a . concat ( 33 ) # => \"Merhaba d\u00fcnya!\" a << 33 # => \"Merhaba d\u00fcnya!!\" String <=> ba\u015fka string \u2192 -1, 0, +1 ya da nil <=> Ruby d\u00fcnyas\u0131nda Spaceship operat\u00f6r\u00fc olarak ge\u00e7er. Ayn\u0131 cins nesneleri kar\u015f\u0131la\u015ft\u0131rmak i\u00e7in kullan\u0131l\u0131r. \"vigo\" <=> \"vigo\" # => 0 # e\u015fit \"vigo\" <=> \"vig\" # => 1 # vigo b\u00fcy\u00fck \"vigo\" <=> \"vigoo\" # => -1 # vigo k\u00fc\u00e7\u00fck \"vigo\" <=> 3 # => nil # alakas\u0131z iki \u015fey casecmp ile ayn\u0131 i\u015fi yapar String =~ Nesne -> Fixnum ya da nil \"Saat tam 4'de bulu\u015fal\u0131m\" =~ /\\d/ # => 9 # \\d say\u0131 yakalad\u0131 ve indeksi d\u00f6nd\u00fc \"Saat tam 4'de bulu\u015fal\u0131m\" [ 9 ] # => \"4\" String i\u00e7inde hareket String asl\u0131nda karakterlerden olu\u015fan bir dizi oldu\u011fu i\u00e7in a\u015fa\u011f\u0131daki gibi atraksiyonlar yapmak m\u00fcmk\u00fcn. String [ indeks ] -> yeni string ya da nil String [ ba\u015flang\u0131\u00e7, uzunluk ] -> yeni string ya da nil String [ range ] -> yeni string ya da nil String [ regexp ] -> yeni string ya da nil String [ regexp, yakalan ] -> yeni string ya da nil String [ metinni_bul ] -> yeni string ya da nil \u00f6rnek olarak; m = \"Merhaba D\u00fcnya\" m [ 0 ] # => \"M\" # 0.karakter m [ 0 , 2 ] # => \"Me\" # 0'dan itibaren 2 karakter m [ 0 .. 4 ] # => \"Merha\" # range, 0'dan 4 dahil m [- 1 , ] # => \"a\" # son karakter m [- 13 ..- 1 ] # => \"Merhaba D\u00fcnya\" # sondan ba\u015fa m [ 15 , 1 ] # => nil # olmayan indeks m [ /(?<sesli>[aeiou])/ , \"sesli\" ] # => \"e\" # regexp m [ \"Merhaba\" ] # => \"Merhaba\" # metni bul m [ \"vigo\" ] # => nil # olmayan metin ayn\u0131 i\u015fi slice ile de yapabilirsiniz. m = \"merhaba\" m . slice ( 2 , 5 ) # => \"rhaba\" gibi... Yard\u0131mc\u0131 Methodlar S\u0131k\u00e7a kullan\u0131lanlar aras\u0131nda; capitalize , center , chars , chomp , chop , clear , count , size , length , delete , ljust , rjust , reverse , upcase , downcase , swapcase , reverse , index , hex , rindex , insert gibi methodlar'dan \u00f6rnekler ekledim. Her zaman oldu\u011fu gibi, hangi method'lar\u0131n oldu\u011funu g\u00f6rmek i\u00e7in; String . new . methods # => [:<=>, :==, :===, :eql?, :hash, :casecmp, :+, :*, :%, :[], :[]=, :insert, :length, :size, :bytesize, :empty?, :=~, :match, :succ, :succ!, :next, :next!, :upto, :index, :rindex, :replace, :clear, :chr, :getbyte, :setbyte, :byteslice, :scrub, :scrub!, :freeze, :to_i, :to_f, :to_s, :to_str, :inspect, :dump, :upcase, :downcase, :capitalize, :swapcase, :upcase!, :downcase!, :capitalize!, :swapcase!, :hex, :oct, :split, :lines, :bytes, :chars, :codepoints, :reverse, :reverse!, :concat, :<<, :prepend, :crypt, :intern, :to_sym, :ord, :include?, :start_with?, :end_with?, :scan, :ljust, :rjust, :center, :sub, :gsub, :chop, :chomp, :strip, :lstrip, :rstrip, :sub!, :gsub!, :chop!, :chomp!, :strip!, :lstrip!, :rstrip!, :tr, :tr_s, :delete, :squeeze, :count, :tr!, :tr_s!, :delete!, :squeeze!, :each_line, :each_byte, :each_char, :each_codepoint, :sum, :slice, :slice!, :partition, :rpartition, :encoding, :force_encoding, :b, :valid_encoding?, :ascii_only?, :unpack, :encode, :encode!, :to_r, :to_c, :>, :>=, :<, :<=, :between?, :nil?, :!~, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :singleton_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__] kullanabiliriz! m = \"merhaba\" m . capitalize # => \"Merhaba\" m # => \"merhaba\" m . capitalize! # => \"Merhaba\" # m'in de\u011feri art\u0131k de\u011fi\u015fti! m # => \"Merhaba\" \"vigo\" . center ( 12 ) # => \" vigo \" \"vigo\" . center ( 12 , \"*\" ) # => \"****vigo****\" \"merhaba\" . chars # => [\"m\", \"e\", \"r\", \"h\", \"a\", \"b\", \"a\"] \"merhaba \\n \" . chomp # => \"merhaba\" \"merhaba d\u00fcnya\" . chomp ( \" d\u00fcnya\" ) # => \"merhaba\" \"merhaba vigo\" . chop # => \"merhaba vig\" \"merhaba vigo \\n \" . chomp # => \"merhaba vigo\" \"a\" . chr # => \"a\" x = \"Merhaba\" x . clear # => \"\" \"Merhaba D\u00fcnya\" . count ( \"a\" ) # => 3 # 3 adet a \"Merhaba D\u00fcnya\" . count ( \"ab\" ) # => 4 # a ve b toplam 4 tane \"Merhaba D\u00fcnya\" . count ( \"e\" ) # => 1 # e'den 1 tane \"Merhaba D\u00fcnya\" . delete ( \"e\" ) # => \"Mrhaba D\u00fcnya\" \"Merhaba D\u00fcnya\" . delete ( \"a\" , \"ba\" ) # => \"Merhb D\u00fcny\" \"MERHABA\" . downcase # => \"merhaba\" \"merhaba\" . upcase # => \"MERHABA\" \"Merhaba\" . swapcase # => \"mERHABA\" \"merhaba\" . size # => 7 \"merhaba\" . length # => 7 \"merhaba\" . ljust ( 20 ) # => \"merhaba \" \"merhaba\" . ljust ( 20 , \"*\" ) # => \"merhaba*************\" \"merhaba\" . rjust ( 20 ) # => \" merhaba\" \"merhaba\" . rjust ( 20 , \"*\" ) # => \"*************merhaba\" \" merhaba \" . strip # => \"merhaba\" \" merhaba\" . lstrip # => \"merhaba\" \"merhaba \" . rstrip # => \"merhaba\" \"merhaba\" . index ( \"m\" ) # => 0 \"merhaba\" . index ( \"ba\" ) # => 5 \"merhaba\" . rindex ( \"m\" ) # => 0 \"merhaba\" . rindex ( \"h\" ) # => 3 \"a\" . next # => \"b\" \"abcd\" . next # => \"abce\" # d'den sonra e geldi... \"b\" . succ # => \"c\" # ba\u015f, ayra\u00e7, son \"merhaba\" . partition ( \"r\" ) # => [\"me\", \"r\", \"haba\"] \"merhaba\" . partition ( \"a\" ) # => [\"merh\", \"a\", \"ba\"] \"merhaba\" . partition ( \"x\" ) # => [\"\", \"\", \"merhaba\"] \"merhaba d\u00fcnya\" . reverse # => \"ayn\u00fcd abahrem\" \"hey seeeeeeeeeeeeeeen! aloooooooo\" . squeeze # => \"hey sen! alo\" \"Merhaba\" . dump # => \"\\\"Merhaba\\\"\" \"merhaba\" . getbyte ( 0 ) # => 109 # m'in ascii de\u011feri \"0x0f\" . hex # => 15 \"0x0fff\" . hex # => 4095 \"merhaba\" . insert ( 0 , \"X\" ) # => \"Xmerhaba\" \"merhaba\" . insert ( 3 , \"A\" ) # => \"merAhaba\" \"merhaba\" . insert ( - 1 , \".\" ) # => \"merhaba.\" \"123\" . oct # => 83 # Octal'e \u00e7evirdi (8'lik) \"A\" . ord # => 65 # Ascii de\u011feri \"a\" . ord # => 97 # Ascii de\u011feri \"d\u00fcnya\" . prepend ( \"Merhaba \" ) # => \"Merhaba d\u00fcnya\" # \u00f6ne ekledi # transform \"merhaba hello\" . tr ( \"el\" , \"ip\" ) # => \"mirhaba hippo\" # e=>i, l => p oldu \"ArkAdA\u015flar nas\u0131ls\u0131n\u0131z?\" . tr ( \"A\" , \"a\" ) # => \"arkada\u015flar nas\u0131ls\u0131n\u0131z?\" # a'dan e'y kadar X ile transform yap \"merhaba d\u00fcnya\" . tr ( \"a-e\" , \"X\" ) # => \"mXrhXXX X\u00fcnyX\" Convert Method'lar\u0131 Tip de\u011fi\u015ftirmek i\u00e7in kullan\u0131l\u0131r. to_i , to_f , to_s , to_str , to_sym , to_r , to_c , to_enum method'lar\u0131na bakal\u0131m: \"merhaba\" . to_i # => 0 # integer'a \u00e7evirdi \"merhaba\" . to_f # => 0.0 # float'a \u00e7evirdi \"5\" . to_i # => 5 \"1.5\" . to_f # => 1.5 \"merhaba\" . to_s # => \"merhaba\" # string \"merhaba\" . to_str # => \"merhaba\" # string \"merhaba\" . to_sym # => :merhaba # symbol \"merhaba\" . to_r # => (0/1) # Rasyonel say\u0131 \"0.2\" . to_r # => (1/5) # Rasyonel say\u0131 \"merhaba\" . to_c # => (0+0i) # Kompleks say\u0131 \"1234\" . to_c # => (1234+0i) \"merhaba\" . to_enum # => #<Enumerator: \"merhaba\":each> # Enumerat\u00f6r'e \u00e7evirdi Kontrol Method'lar\u0131 Method ad\u0131 ? ilen bitiyor demek, bir kontrol oldu\u011fu ve sonucun Boolean yan\u0131 true ya da false d\u00f6nd\u00fc\u011f\u00fc anlam\u0131nda oldu\u011funu s\u00f6ylemi\u015ftik. \"merhaba\" . start_with? ( \"m\" ) # => true \"merhaba\" . start_with? ( \"mer\" ) # => true \"merhaba\" . start_with? ( \"f\" ) # => false \"merhaba\" . end_with? ( \"a\" ) # => true \"merhaba\" . end_with? ( \"haba\" ) # => true \"merhaba\" . end_with? ( \"zoo\" ) # => false \"merhaba\" . eql? ( \"Merhaba\" ) # => false \"merhaba\" . eql? ( \"merhaba\" ) # => true \"merhaba d\u00fcnya\" . include? ( \"d\u00fcnya\" ) # => true \"merhaba\" . empty? # => false \"\" . empty? # => true \"kedi\" . between? ( \"at\" , \"bal\u0131k\" ) # => false # ba\u015flang\u0131\u00e7 harfi a ve b aras\u0131ndam\u0131? gibi d\u00fc\u015f\u00fcn\u00fcn \"kedi\" . between? ( \"fare\" , \"sinek\" ) # => true Array ve Block ile \u0130li\u015fkili Methodlar split Metni par\u00e7alara b\u00f6ler, varsay\u0131lan delimiter ( ay\u0131r\u0131c\u0131 ) bo\u015fuk karakteridir. \"Selam millet nas\u0131l s\u0131n\u0131z?\" . split # => [\"Selam\", \"millet\", \"nas\u0131l\", \"s\u0131n\u0131z?\"] \"Selam millet-nas\u0131l s\u0131n\u0131z?\" . split ( \"-\" ) # => [\"Selam millet\", \"nas\u0131l s\u0131n\u0131z?\"] \"A tak\u0131m\u0131: 65 B tak\u0131m\u0131: 120\" . split ( / +\\d+ ?/ ) # => [\"A tak\u0131m\u0131:\", \"B tak\u0131m\u0131:\"] \"1,2,3,4,5\" . split ( \",\" ) # => [\"1\", \"2\", \"3\", \"4\", \"5\"] each_byte \"merhaba\" . each_byte { | c | puts c } # 109 (m) # 101 (e) # 114 (r) # 104 (h) # 97 (a) # 98 (b) # 97 (a) each_char \"merhaba\" . each_char { | c | puts c } # m # e # r # h # a # b # a each_line \"Merhaba \\n D\u00fcnya \\n Nas\u0131l s\u0131n?\" . each_line { | l | puts l } # Merhaba # D\u00fcnya # Nas\u0131l s\u0131n? \"Merhaba@@D\u00fcnya@@Nas\u0131l s\u0131n?\" . each_line ( \"@@\" ) { | l | puts l } # Merhaba@@ # D\u00fcnya@@ # Nas\u0131l s\u0131n? upto \"a1\" . upto ( \"b1\" ){ | t | puts t } # a1 # a2 # a3 # a4 # a5 # a6 # a7 # a8 # a9 # b0 # b1 Pattern Yakalama (Regexp) Daha kapsaml\u0131 olarak 6.B\u00f6l\u00fcm 'de de de\u011finece\u011fimiz Regular Expression konusu, String'lerle \u00e7ok ili\u015fkili. Hemen ilgili method'lara bakal\u0131m gsub ve sub sub ile gsub aras\u0131ndaki fark, sub ilk buldu\u011funu i\u015fler, gsub Global anlam\u0131ndad\u0131r. \"merhaba d\u00fcnya, merhaba uzay\" . sub ( \"merhaba\" , \"olaa\" ) # => \"olaa d\u00fcnya, merhaba uzay\" \"merhaba d\u00fcnya, merhaba uzay\" . gsub ( \"merhaba\" , \"olaa\" ) # => \"olaa d\u00fcnya, olaa uzay\" \"Merhaba D\u00fcnya\" . gsub ( /[aeiou]/ , \"x\" ) # => \"Mxrhxbx D\u00fcnyx\" \"Merhaba D\u00fcnya\" . gsub ( /([aeiou])/ , '( \\1 )' ) # => \"M(e)rh(a)b(a) D\u00fcny(a)\" \"Merhaba d\u00fcnya, merhaba uzay, merhaba evren\" . gsub ( /((m|M)erhaba)/ ){ | c | c . upcase } # => \"MERHABA d\u00fcnya, MERHABA uzay, MERHABA evren\" \"Merhaba D\u00fcnya\" . gsub ( /(?<sesli_harf>[aeiou])/ , '{\\k<sesli_harf>}' ) # => \"M{e}rh{a}b{a} D\u00fcny{a}\" \"Merhaba D\u00fcnya\" . gsub ( /[ea]/ , 'e' => 1 , 'a' => 'X' ) # => \"M1rhXbX D\u00fcnyX\" match \"merhaba\" . match ( \"a\" ) # => #<MatchData \"a\"> \"merhaba\" . match ( \"(a)\" ) # => #<MatchData \"a\" 1:\"a\"> # 1 tane yakalad\u0131, (a) ve Array geldi \"merhaba\" . match ( \"(a)\" ) [ 0 ] # => \"a\" # yakalanan \"merhaba 2014\" . match ( /\\d/ ) # => #<MatchData \"2\"> \"merhaba 2014\" . match ( /(\\d)/ ) # => #<MatchData \"2\" 1:\"2\"> \"merhaba 2014\" . match ( /(\\d+)/ ) # => #<MatchData \"2014\" 1:\"2014\"> \"merhaba 2014\" . match ( /(\\d+)/ ) [ 0 ] # => \"2014\" \"merhaba 2014\" . match ( /(\\d+)/ ) [ 0 ]. to_i # => 2014 scan Match gibi, metin \u00fczerinde bir nevi arama yap\u0131yoruz: \"Merhaba millet!\" . scan ( /\\w+/ ) # => [\"Merhaba\", \"millet\"] \"Merhaba millet!\" . scan ( /./ ) # => [\"M\", \"e\", \"r\", \"h\", \"a\", \"b\", \"a\", \" \", \"m\", \"i\", \"l\", \"l\", \"e\", \"t\", \"!\"] \"Merhaba millet! Saat 10'da bulu\u015fal\u0131m\" . scan ( /Saat \\d+/ ) # => [\"Saat 10\"]","title":"String"},{"location":"bolum-04/03-string/#string","text":"Kabaca, insanlar\u0131n anlayaca\u011f\u0131 \u015fekilde tekst / metin bilgisi i\u00e7eren nesnelerdir. \u00d6rne\u011fin; m = \"Merhaba\" m . class # => String \u015feklindedir. Tan\u0131mlama yaparken tek ya da \u00e7ift t\u0131rnak kullan\u0131labilir ama aralar\u0131nda fark vard\u0131r. Expression Substitution ya da String Interpolation olarak ge\u00e7en, String i\u00e7inde de\u011fi\u015fken kullan\u0131m\u0131 esnas\u0131nda \u00e7ift t\u0131rnak kullanman\u0131z gerekir. m = \"Merhaba\" puts \" #{ m } U\u011fur\" # Merhaba U\u011fur puts ' #{ m } U\u011fur' # #{m} U\u011fur Tek t\u0131rnak kulland\u0131\u011f\u0131m\u0131z \u00f6rnekte #{m} de\u011fi\u015fkeni i\u015flenmeden oldu\u011fu gibi \u00e7\u0131kt\u0131 vermi\u015ftir. Ayn\u0131 \u015fekilde escape codes yani g\u00f6r\u00fcnmeyen \u00f6zel karakterleri de sadece \u00e7ift t\u0131rnak i\u00e7inde kullanmak m\u00fcmk\u00fcnd\u00fcr. \u00c7ift t\u0131rnak i\u00e7inde kullan\u0131lan #{BURAYA RUBY KODU GEL\u0130R} \u00e7ok i\u015fe yarar. { ve } aras\u0131nda kod \u00e7al\u0131\u015ft\u0131rmam\u0131z\u0131 sa\u011flar. puts \"Saat: #{ Time . now } \" # Saat: 2014-08-12 10:37:22 +0300 dedi\u011fimizde; Ruby Kernel'dan Time nesnesinin now method'unu \u00e7al\u0131\u015ft\u0131rm\u0131\u015f oluruz. puts \"Merhaba \\n D\u00fcnya\" # Merhaba # D\u00fcnya \\n New Line ya da Line Feed ya da yeni sat\u0131ra ge\u00e7me karakteri \u00e7ift t\u0131rnakta \u00e7al\u0131\u015f\u0131r. Escape Kod Anlam\u0131 \\n Yeni sat\u0131r (0x0a) \\s Bo\u015fluk (0x20) \\r Sat\u0131r Ba\u015f\u0131 (0x0d) \\t Tab Karakteri (0x09) \\v Dikey Tab (0x0b) \\f Formfeed (0x0c) \\b Backspace (Bir geri) (0x08) \\a Bell/Alert (Uyar\u0131) (0x07) \\e Escape (0x1b) \\nnn Octal, 8'lik de\u011fer \\xnn Hexadecimal, 16'l\u0131k de\u011fer \\unnnn Unicode: U+nnnn (Ruby 1.9+) \\cx Control-x \\C-x Control-x \\M-x Meta-x \\M-\\C-x Meta-Control-x \\x x'in kendisi (\\\" \u00e7ift t\u0131rnak demektir.) String'ler byte array 'lerden olu\u015fur yani elemanlar\u0131 byte cinsinden dizidir asl\u0131nda. m = \"\" m << 65 puts m # A m bo\u015f bir String, diziye eleman ekler gibi ( << diziye eleman ekler, az sonra g\u00f6rece\u011fiz ) i\u00e7ine 65 ekledik. Bu A harfinin 10'luk say\u0131 sistemindeki ASCII de\u011feridir. Asl\u0131nda m = \"A\" yapt\u0131k :) E\u011fer 65 in karakter setindeki de\u011feri neydi? dersek put 65.chr yapt\u0131\u011f\u0131m\u0131zda bize A d\u00f6ner. 0 ile 255 aras\u0131 de\u011ferlerdir bunlar. Daha ilgin\u00e7 bir olay; puts \"\u00f6z\" \"y\u0131l\" \"maz\" \"el\" # \u00f6zy\u0131lmazel yani \"tekst\" \"tekst\" \"tekst\" \u015fekinde bir kullan\u0131m mevcuttur.","title":"String"},{"location":"bolum-04/03-string/#string-literals-string-kalplar","text":"Ruby'de, yine di\u011fer dillerde olmayan ilgin\u00e7 bir \u00f6zellik. % i\u015fareti ve sonras\u0131nda gelen baz\u0131 karakterler yard\u0131m\u0131yla enteresan \u015feyler yapmak m\u00fcmk\u00fcn:","title":"String Literals (String Kal\u0131plar\u0131)"},{"location":"bolum-04/03-string/#_1","text":"S\u00fcsl\u00fc parantezler aras\u0131nda kalan her \u015fey concat ( yani toplanarak ) edilir ve String olarak \u00e7\u0131kt\u0131 verir ve t\u0131rnaklar\u0131 escape eder. %{Merhaba D\u00fcnya Ben vigo nas\u0131ls\u0131n\u0131z?} # => \"Merhaba D\u00fcnya Ben vigo nas\u0131ls\u0131n\u0131z?\" %{Bu i\u015flemlerin %80'i \"uydurma\"} # => \"Bu i\u015flemlerin %80'i \\\"uydurma\\\"\" ayn\u0131 i\u015fi; %|Merhaba D\u00fcnya Ben vigo nas\u0131ls\u0131n\u0131z?| s\u00fcsl\u00fc parantez yerine pipe | kullanarak da yapabilirsiniz!","title":"%"},{"location":"bolum-04/03-string/#w","text":"H\u0131zl\u0131ca Array \u00fcretmeyi sa\u011flar: %w{foo bar baz} # => [\"foo\", \"bar\", \"baz\"] %w{foo bar baz} . class # => Array","title":"%w"},{"location":"bolum-04/03-string/#i","text":"\u0130\u00e7inde Symbol olan Array \u00fcretir: % i { foo bar baz } # => [:foo, :bar, :baz]","title":"%i"},{"location":"bolum-04/03-string/#q-ve-q","text":"q tek t\u0131rnak, Q \u00e7ift t\u0131rnakla sarmalam\u0131\u015f gibi yapar: person = \"U\u011fur\" %q{Merhaba #{person}} # => \"Merhaba \\#{person}\" %Q{Merhaba #{ person } } # => \"Merhaba U\u011fur\"","title":"%q ve %Q"},{"location":"bolum-04/03-string/#s","text":"Symbol 'e \u00e7evirir: %s{my_variable} # => :my_variable %s{email} # => :email","title":"%s"},{"location":"bolum-04/03-string/#r","text":"Regular Expression 'a \u00e7evirir: %r{(.*)hello}i # => /(.*)hello/i","title":"%r"},{"location":"bolum-04/03-string/#x","text":"Ruby'de back tick kullanarak shell komutu \u00e7al\u0131\u015ft\u0131rabilirsiniz. Yani Linux ve Mac kullanan okuyucular Terminal ile ha\u015f\u0131r-ne\u015fir olmu\u015flard\u0131r. \u00d6rne\u011fin, bulundu\u011funuz dizindeki dosya listesini almak i\u00e7in ls komutunu kullan\u0131rs\u0131n\u0131z. \u00d6rne\u011fin kendi home dizinimde ls yapt\u0131\u011f\u0131mda ( OSX kullan\u0131yorum ) $ ls -1 # alt alta listemelek i\u00e7in Applications Desktop Development Documents Dotfiles Downloads Library VirtualBox VMs Works bin gibi bir liste al\u0131yorum. Yapaca\u011f\u0131m bir Ruby uygulamas\u0131nda; %x{ls -1 $HOME} # => \"Applications\\nDesktop\\nDevelopment\\nDocuments\\nDotfiles\\nDownloads\\nLibrary\\nVirtualBox VMs\\nWorks\\nbin\\n\" T\u00fcm liste tek bir String olarak geldi ve \\n karakteri ile birle\u015fti \u00e7\u00fcnki sonu\u00e7 alt alta sat\u0131r sat\u0131r geldi. E\u011fer; %x{ls -1 $HOME} . split ( \" \\n \" ) deseydim sonu\u00e7 bana dizi olarak gelecekti! # [\"Applications\", \"Desktop\", \"Development\", \"Documents\", \"Dotfiles\", \"Downloads\", \"Library\", \"VirtualBox VMs\", \"Works\", \"bin\"] %x{ruby --copyright} # => \"ruby - Copyright (C) 1993-2014 Yukihiro Matsumoto\\n\"","title":"%x"},{"location":"bolum-04/03-string/#here-document-kullanm","text":"Uzun metin kullan\u0131mlar\u0131nda \u00e7ok i\u015fe yarar: mesaj = << END Merhaba nas\u0131ls\u0131n\u0131z? Biz de \u00e7ok iyiyiz G\u00f6r\u00fc\u015f\u00fcr\u00fcz! END puts mesaj # Merhaba nas\u0131ls\u0131n\u0131z? # Biz de \u00e7ok iyiyiz # G\u00f6r\u00fc\u015f\u00fcr\u00fcz! Bu \u00f6rnekte mesaj = <<END ile END kelimesini g\u00f6rene kadar i\u00e7inde ne varsa kullan diyoruz! Daha da \u00e7\u0131lg\u0131n bir kullan\u0131m \u015fekli; mesaj = [<< B\u0130R , << \u0130 K\u0130 , << \u00dc\u00c7 ] Bu Bir B\u0130R Bu iki .... \u0130 K\u0130 Bu da \u00fc\u00fc\u00fc\u00fc\u00fc\u00fc\u00fc\u00fc\u00e7 \u00dc\u00c7 puts mesaj # - Bu Bir # - Bu iki.... # - Bu da \u00fc\u00fc\u00fc\u00fc\u00fc\u00fc\u00fc\u00fc\u00e7","title":"Here Document Kullan\u0131m\u0131"},{"location":"bolum-04/03-string/#string-methodlar","text":"","title":"String Method'lar\u0131"},{"location":"bolum-04/03-string/#string-arguman-yeni-string","text":"\"Merhaba %s\" % \"U\u011fur\" # => \"Merhaba U\u011fur\" \"Say\u0131: %010d\" % 2014 # => \"Say\u0131: 0000002014\" \"Kullan\u0131c\u0131 Ad\u0131: %s, E-Posta: %s\" % [ \"vigo\" , \"vigo@foo.com\" ] # => \"Kullan\u0131c\u0131 Ad\u0131: vigo, E-Posta: vigo@foo.com\" \"Merhaba %{username}!\" % { :username => 'vigo' } # => \"Merhaba vigo!\" Keza bu method, printf , sprintf gibi, String Format mant\u0131\u011f\u0131nda \u00e7al\u0131\u015f\u0131r. \"Say\u0131: %010d\" % 2014 \u00f6rne\u011finde %010d asl\u0131nda 10 basamakl\u0131, 0 ile pad edilmi\u015f \u015fekilde g\u00f6ster anlam\u0131ndad\u0131r. 2014 4 basamakl\u0131d\u0131r, solunda 6 tane s\u0131f\u0131r gelmi\u015ftir.","title":"String % arg\u00fcman -&gt; yeni String"},{"location":"bolum-04/03-string/#string-say-yeni-string","text":"String ile say\u0131y\u0131 \u00e7arpmak m\u00fcmk\u00fcn! \"Merhaba!\" * 3 # => \"Merhaba!Merhaba!Merhaba!\" \"Merhaba!\" * 0 # => \"\"","title":"String * say\u0131 -&gt; yeni String"},{"location":"bolum-04/03-string/#string-string-yeni-string","text":"\"Merhaba\" + \" \" + \"D\u00fcnya\" # => \"Merhaba D\u00fcnya\"","title":"String + String -&gt; yeni String"},{"location":"bolum-04/03-string/#string-say-string-string-nesne-string","text":"a = \"Merhaba\" a << \" d\u00fcnya\" # => \"Merhaba d\u00fcnya\" a # => \"Merhaba d\u00fcnya\" a . concat ( 33 ) # => \"Merhaba d\u00fcnya!\" a << 33 # => \"Merhaba d\u00fcnya!!\"","title":"String &lt;&lt; say\u0131 -&gt; String / String &lt;&lt; nesne -&gt; String"},{"location":"bolum-04/03-string/#string-baska-string-1-0-1-ya-da-nil","text":"<=> Ruby d\u00fcnyas\u0131nda Spaceship operat\u00f6r\u00fc olarak ge\u00e7er. Ayn\u0131 cins nesneleri kar\u015f\u0131la\u015ft\u0131rmak i\u00e7in kullan\u0131l\u0131r. \"vigo\" <=> \"vigo\" # => 0 # e\u015fit \"vigo\" <=> \"vig\" # => 1 # vigo b\u00fcy\u00fck \"vigo\" <=> \"vigoo\" # => -1 # vigo k\u00fc\u00e7\u00fck \"vigo\" <=> 3 # => nil # alakas\u0131z iki \u015fey casecmp ile ayn\u0131 i\u015fi yapar","title":"String &lt;=&gt; ba\u015fka string \u2192 -1, 0, +1 ya da nil"},{"location":"bolum-04/03-string/#string-nesne-fixnum-ya-da-nil","text":"\"Saat tam 4'de bulu\u015fal\u0131m\" =~ /\\d/ # => 9 # \\d say\u0131 yakalad\u0131 ve indeksi d\u00f6nd\u00fc \"Saat tam 4'de bulu\u015fal\u0131m\" [ 9 ] # => \"4\"","title":"String =~ Nesne -&gt; Fixnum ya da nil"},{"location":"bolum-04/03-string/#string-icinde-hareket","text":"String asl\u0131nda karakterlerden olu\u015fan bir dizi oldu\u011fu i\u00e7in a\u015fa\u011f\u0131daki gibi atraksiyonlar yapmak m\u00fcmk\u00fcn. String [ indeks ] -> yeni string ya da nil String [ ba\u015flang\u0131\u00e7, uzunluk ] -> yeni string ya da nil String [ range ] -> yeni string ya da nil String [ regexp ] -> yeni string ya da nil String [ regexp, yakalan ] -> yeni string ya da nil String [ metinni_bul ] -> yeni string ya da nil \u00f6rnek olarak; m = \"Merhaba D\u00fcnya\" m [ 0 ] # => \"M\" # 0.karakter m [ 0 , 2 ] # => \"Me\" # 0'dan itibaren 2 karakter m [ 0 .. 4 ] # => \"Merha\" # range, 0'dan 4 dahil m [- 1 , ] # => \"a\" # son karakter m [- 13 ..- 1 ] # => \"Merhaba D\u00fcnya\" # sondan ba\u015fa m [ 15 , 1 ] # => nil # olmayan indeks m [ /(?<sesli>[aeiou])/ , \"sesli\" ] # => \"e\" # regexp m [ \"Merhaba\" ] # => \"Merhaba\" # metni bul m [ \"vigo\" ] # => nil # olmayan metin ayn\u0131 i\u015fi slice ile de yapabilirsiniz. m = \"merhaba\" m . slice ( 2 , 5 ) # => \"rhaba\" gibi...","title":"String i\u00e7inde hareket"},{"location":"bolum-04/03-string/#yardmc-methodlar","text":"S\u0131k\u00e7a kullan\u0131lanlar aras\u0131nda; capitalize , center , chars , chomp , chop , clear , count , size , length , delete , ljust , rjust , reverse , upcase , downcase , swapcase , reverse , index , hex , rindex , insert gibi methodlar'dan \u00f6rnekler ekledim. Her zaman oldu\u011fu gibi, hangi method'lar\u0131n oldu\u011funu g\u00f6rmek i\u00e7in; String . new . methods # => [:<=>, :==, :===, :eql?, :hash, :casecmp, :+, :*, :%, :[], :[]=, :insert, :length, :size, :bytesize, :empty?, :=~, :match, :succ, :succ!, :next, :next!, :upto, :index, :rindex, :replace, :clear, :chr, :getbyte, :setbyte, :byteslice, :scrub, :scrub!, :freeze, :to_i, :to_f, :to_s, :to_str, :inspect, :dump, :upcase, :downcase, :capitalize, :swapcase, :upcase!, :downcase!, :capitalize!, :swapcase!, :hex, :oct, :split, :lines, :bytes, :chars, :codepoints, :reverse, :reverse!, :concat, :<<, :prepend, :crypt, :intern, :to_sym, :ord, :include?, :start_with?, :end_with?, :scan, :ljust, :rjust, :center, :sub, :gsub, :chop, :chomp, :strip, :lstrip, :rstrip, :sub!, :gsub!, :chop!, :chomp!, :strip!, :lstrip!, :rstrip!, :tr, :tr_s, :delete, :squeeze, :count, :tr!, :tr_s!, :delete!, :squeeze!, :each_line, :each_byte, :each_char, :each_codepoint, :sum, :slice, :slice!, :partition, :rpartition, :encoding, :force_encoding, :b, :valid_encoding?, :ascii_only?, :unpack, :encode, :encode!, :to_r, :to_c, :>, :>=, :<, :<=, :between?, :nil?, :!~, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :singleton_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__] kullanabiliriz! m = \"merhaba\" m . capitalize # => \"Merhaba\" m # => \"merhaba\" m . capitalize! # => \"Merhaba\" # m'in de\u011feri art\u0131k de\u011fi\u015fti! m # => \"Merhaba\" \"vigo\" . center ( 12 ) # => \" vigo \" \"vigo\" . center ( 12 , \"*\" ) # => \"****vigo****\" \"merhaba\" . chars # => [\"m\", \"e\", \"r\", \"h\", \"a\", \"b\", \"a\"] \"merhaba \\n \" . chomp # => \"merhaba\" \"merhaba d\u00fcnya\" . chomp ( \" d\u00fcnya\" ) # => \"merhaba\" \"merhaba vigo\" . chop # => \"merhaba vig\" \"merhaba vigo \\n \" . chomp # => \"merhaba vigo\" \"a\" . chr # => \"a\" x = \"Merhaba\" x . clear # => \"\" \"Merhaba D\u00fcnya\" . count ( \"a\" ) # => 3 # 3 adet a \"Merhaba D\u00fcnya\" . count ( \"ab\" ) # => 4 # a ve b toplam 4 tane \"Merhaba D\u00fcnya\" . count ( \"e\" ) # => 1 # e'den 1 tane \"Merhaba D\u00fcnya\" . delete ( \"e\" ) # => \"Mrhaba D\u00fcnya\" \"Merhaba D\u00fcnya\" . delete ( \"a\" , \"ba\" ) # => \"Merhb D\u00fcny\" \"MERHABA\" . downcase # => \"merhaba\" \"merhaba\" . upcase # => \"MERHABA\" \"Merhaba\" . swapcase # => \"mERHABA\" \"merhaba\" . size # => 7 \"merhaba\" . length # => 7 \"merhaba\" . ljust ( 20 ) # => \"merhaba \" \"merhaba\" . ljust ( 20 , \"*\" ) # => \"merhaba*************\" \"merhaba\" . rjust ( 20 ) # => \" merhaba\" \"merhaba\" . rjust ( 20 , \"*\" ) # => \"*************merhaba\" \" merhaba \" . strip # => \"merhaba\" \" merhaba\" . lstrip # => \"merhaba\" \"merhaba \" . rstrip # => \"merhaba\" \"merhaba\" . index ( \"m\" ) # => 0 \"merhaba\" . index ( \"ba\" ) # => 5 \"merhaba\" . rindex ( \"m\" ) # => 0 \"merhaba\" . rindex ( \"h\" ) # => 3 \"a\" . next # => \"b\" \"abcd\" . next # => \"abce\" # d'den sonra e geldi... \"b\" . succ # => \"c\" # ba\u015f, ayra\u00e7, son \"merhaba\" . partition ( \"r\" ) # => [\"me\", \"r\", \"haba\"] \"merhaba\" . partition ( \"a\" ) # => [\"merh\", \"a\", \"ba\"] \"merhaba\" . partition ( \"x\" ) # => [\"\", \"\", \"merhaba\"] \"merhaba d\u00fcnya\" . reverse # => \"ayn\u00fcd abahrem\" \"hey seeeeeeeeeeeeeeen! aloooooooo\" . squeeze # => \"hey sen! alo\" \"Merhaba\" . dump # => \"\\\"Merhaba\\\"\" \"merhaba\" . getbyte ( 0 ) # => 109 # m'in ascii de\u011feri \"0x0f\" . hex # => 15 \"0x0fff\" . hex # => 4095 \"merhaba\" . insert ( 0 , \"X\" ) # => \"Xmerhaba\" \"merhaba\" . insert ( 3 , \"A\" ) # => \"merAhaba\" \"merhaba\" . insert ( - 1 , \".\" ) # => \"merhaba.\" \"123\" . oct # => 83 # Octal'e \u00e7evirdi (8'lik) \"A\" . ord # => 65 # Ascii de\u011feri \"a\" . ord # => 97 # Ascii de\u011feri \"d\u00fcnya\" . prepend ( \"Merhaba \" ) # => \"Merhaba d\u00fcnya\" # \u00f6ne ekledi # transform \"merhaba hello\" . tr ( \"el\" , \"ip\" ) # => \"mirhaba hippo\" # e=>i, l => p oldu \"ArkAdA\u015flar nas\u0131ls\u0131n\u0131z?\" . tr ( \"A\" , \"a\" ) # => \"arkada\u015flar nas\u0131ls\u0131n\u0131z?\" # a'dan e'y kadar X ile transform yap \"merhaba d\u00fcnya\" . tr ( \"a-e\" , \"X\" ) # => \"mXrhXXX X\u00fcnyX\"","title":"Yard\u0131mc\u0131 Methodlar"},{"location":"bolum-04/03-string/#convert-methodlar","text":"Tip de\u011fi\u015ftirmek i\u00e7in kullan\u0131l\u0131r. to_i , to_f , to_s , to_str , to_sym , to_r , to_c , to_enum method'lar\u0131na bakal\u0131m: \"merhaba\" . to_i # => 0 # integer'a \u00e7evirdi \"merhaba\" . to_f # => 0.0 # float'a \u00e7evirdi \"5\" . to_i # => 5 \"1.5\" . to_f # => 1.5 \"merhaba\" . to_s # => \"merhaba\" # string \"merhaba\" . to_str # => \"merhaba\" # string \"merhaba\" . to_sym # => :merhaba # symbol \"merhaba\" . to_r # => (0/1) # Rasyonel say\u0131 \"0.2\" . to_r # => (1/5) # Rasyonel say\u0131 \"merhaba\" . to_c # => (0+0i) # Kompleks say\u0131 \"1234\" . to_c # => (1234+0i) \"merhaba\" . to_enum # => #<Enumerator: \"merhaba\":each> # Enumerat\u00f6r'e \u00e7evirdi","title":"Convert Method'lar\u0131"},{"location":"bolum-04/03-string/#kontrol-methodlar","text":"Method ad\u0131 ? ilen bitiyor demek, bir kontrol oldu\u011fu ve sonucun Boolean yan\u0131 true ya da false d\u00f6nd\u00fc\u011f\u00fc anlam\u0131nda oldu\u011funu s\u00f6ylemi\u015ftik. \"merhaba\" . start_with? ( \"m\" ) # => true \"merhaba\" . start_with? ( \"mer\" ) # => true \"merhaba\" . start_with? ( \"f\" ) # => false \"merhaba\" . end_with? ( \"a\" ) # => true \"merhaba\" . end_with? ( \"haba\" ) # => true \"merhaba\" . end_with? ( \"zoo\" ) # => false \"merhaba\" . eql? ( \"Merhaba\" ) # => false \"merhaba\" . eql? ( \"merhaba\" ) # => true \"merhaba d\u00fcnya\" . include? ( \"d\u00fcnya\" ) # => true \"merhaba\" . empty? # => false \"\" . empty? # => true \"kedi\" . between? ( \"at\" , \"bal\u0131k\" ) # => false # ba\u015flang\u0131\u00e7 harfi a ve b aras\u0131ndam\u0131? gibi d\u00fc\u015f\u00fcn\u00fcn \"kedi\" . between? ( \"fare\" , \"sinek\" ) # => true","title":"Kontrol Method'lar\u0131"},{"location":"bolum-04/03-string/#array-ve-block-ile-iliskili-methodlar","text":"split Metni par\u00e7alara b\u00f6ler, varsay\u0131lan delimiter ( ay\u0131r\u0131c\u0131 ) bo\u015fuk karakteridir. \"Selam millet nas\u0131l s\u0131n\u0131z?\" . split # => [\"Selam\", \"millet\", \"nas\u0131l\", \"s\u0131n\u0131z?\"] \"Selam millet-nas\u0131l s\u0131n\u0131z?\" . split ( \"-\" ) # => [\"Selam millet\", \"nas\u0131l s\u0131n\u0131z?\"] \"A tak\u0131m\u0131: 65 B tak\u0131m\u0131: 120\" . split ( / +\\d+ ?/ ) # => [\"A tak\u0131m\u0131:\", \"B tak\u0131m\u0131:\"] \"1,2,3,4,5\" . split ( \",\" ) # => [\"1\", \"2\", \"3\", \"4\", \"5\"] each_byte \"merhaba\" . each_byte { | c | puts c } # 109 (m) # 101 (e) # 114 (r) # 104 (h) # 97 (a) # 98 (b) # 97 (a) each_char \"merhaba\" . each_char { | c | puts c } # m # e # r # h # a # b # a each_line \"Merhaba \\n D\u00fcnya \\n Nas\u0131l s\u0131n?\" . each_line { | l | puts l } # Merhaba # D\u00fcnya # Nas\u0131l s\u0131n? \"Merhaba@@D\u00fcnya@@Nas\u0131l s\u0131n?\" . each_line ( \"@@\" ) { | l | puts l } # Merhaba@@ # D\u00fcnya@@ # Nas\u0131l s\u0131n? upto \"a1\" . upto ( \"b1\" ){ | t | puts t } # a1 # a2 # a3 # a4 # a5 # a6 # a7 # a8 # a9 # b0 # b1","title":"Array ve Block ile \u0130li\u015fkili Methodlar"},{"location":"bolum-04/03-string/#pattern-yakalama-regexp","text":"Daha kapsaml\u0131 olarak 6.B\u00f6l\u00fcm 'de de de\u011finece\u011fimiz Regular Expression konusu, String'lerle \u00e7ok ili\u015fkili. Hemen ilgili method'lara bakal\u0131m gsub ve sub sub ile gsub aras\u0131ndaki fark, sub ilk buldu\u011funu i\u015fler, gsub Global anlam\u0131ndad\u0131r. \"merhaba d\u00fcnya, merhaba uzay\" . sub ( \"merhaba\" , \"olaa\" ) # => \"olaa d\u00fcnya, merhaba uzay\" \"merhaba d\u00fcnya, merhaba uzay\" . gsub ( \"merhaba\" , \"olaa\" ) # => \"olaa d\u00fcnya, olaa uzay\" \"Merhaba D\u00fcnya\" . gsub ( /[aeiou]/ , \"x\" ) # => \"Mxrhxbx D\u00fcnyx\" \"Merhaba D\u00fcnya\" . gsub ( /([aeiou])/ , '( \\1 )' ) # => \"M(e)rh(a)b(a) D\u00fcny(a)\" \"Merhaba d\u00fcnya, merhaba uzay, merhaba evren\" . gsub ( /((m|M)erhaba)/ ){ | c | c . upcase } # => \"MERHABA d\u00fcnya, MERHABA uzay, MERHABA evren\" \"Merhaba D\u00fcnya\" . gsub ( /(?<sesli_harf>[aeiou])/ , '{\\k<sesli_harf>}' ) # => \"M{e}rh{a}b{a} D\u00fcny{a}\" \"Merhaba D\u00fcnya\" . gsub ( /[ea]/ , 'e' => 1 , 'a' => 'X' ) # => \"M1rhXbX D\u00fcnyX\" match \"merhaba\" . match ( \"a\" ) # => #<MatchData \"a\"> \"merhaba\" . match ( \"(a)\" ) # => #<MatchData \"a\" 1:\"a\"> # 1 tane yakalad\u0131, (a) ve Array geldi \"merhaba\" . match ( \"(a)\" ) [ 0 ] # => \"a\" # yakalanan \"merhaba 2014\" . match ( /\\d/ ) # => #<MatchData \"2\"> \"merhaba 2014\" . match ( /(\\d)/ ) # => #<MatchData \"2\" 1:\"2\"> \"merhaba 2014\" . match ( /(\\d+)/ ) # => #<MatchData \"2014\" 1:\"2014\"> \"merhaba 2014\" . match ( /(\\d+)/ ) [ 0 ] # => \"2014\" \"merhaba 2014\" . match ( /(\\d+)/ ) [ 0 ]. to_i # => 2014 scan Match gibi, metin \u00fczerinde bir nevi arama yap\u0131yoruz: \"Merhaba millet!\" . scan ( /\\w+/ ) # => [\"Merhaba\", \"millet\"] \"Merhaba millet!\" . scan ( /./ ) # => [\"M\", \"e\", \"r\", \"h\", \"a\", \"b\", \"a\", \" \", \"m\", \"i\", \"l\", \"l\", \"e\", \"t\", \"!\"] \"Merhaba millet! Saat 10'da bulu\u015fal\u0131m\" . scan ( /Saat \\d+/ ) # => [\"Saat 10\"]","title":"Pattern Yakalama (Regexp)"},{"location":"bolum-04/04-array/","text":"Array Kompakt, s\u0131ral\u0131 objeler i\u00e7eren bir t\u00fcr\u00fc ta\u015f\u0131c\u0131y\u0131 nesnedir Array\u2019ler. Neredeyse i\u00e7inde her t\u00fcr Ruby objesini ta\u015f\u0131yabilir. ( String, Integer, Fixnum, Hash, Symbol hatta ba\u015fka Array\u2019ler vs... ) Arka arkaya s\u0131ralanm\u0131\u015f kutucuklar d\u00fc\u015f\u00fcn\u00fcn, her kutucu\u011fun bir index numaras\u0131 oldu\u011funu hayal edin. Bu indeksleme i\u015fi otomatik olarak oluyor. Diziye her eleman ekledi\u011finizde ( E\u011fer kendiniz indeks numaras\u0131 atamad\u0131ysan\u0131z ) yeni indeks bir artarak devam ediyor. Zero Indexed yani ilk eleman 0 .eleman oluyor. Ayn\u0131 String \u2019deki gibi negatif indeks de\u011ferleri ile tersten eri\u015fim sa\u011fl\u0131yorsunuz. Yani ilk eleman array[0] ve son eleman array[-1] gibi... Array olu\u015fturmak i\u00e7in; a = [] # Ya bu \u015fekilde a . class # => Array b = Array . new # => Ya da bu \u015fekilde b . class # => Array kullanabilirsiniz. Keza a = [1, 2, 3] dedi\u011finizde de Array\u2019i hem tan\u0131mlam\u0131\u015f hem de elemanlar\u0131n\u0131 belirlemi\u015f olursunuz. Array\u2019i initialize ederken yani ilk kez olu\u015ftururken b\u00fcy\u00fckl\u00fc\u011f\u00fcn\u00fc de verebilirsiniz. a = Array . new ( 5 ) # i\u00e7inde 5 eleman ta\u015f\u0131yacak Array olu\u015ftur a # => [nil, nil, nil, nil, nil] Hatta, default de\u011fer bile atars\u0131n\u0131z: aylar = Array . new ( 12 , \"ay\" ) # 12 eleman olsun ve hepsi \"ay\" olsun aylar # => [\"ay\", \"ay\", \"ay\", \"ay\", \"ay\", \"ay\", \"ay\", \"ay\", \"ay\", \"ay\", \"ay\", \"ay\"] Ruby\u2019de her nesnenin bir ID \u2019si ve HASH de\u011feri vard\u0131r. [ 1 , 2 , 3 ]. hash # => 3384159031637530117 [ 1 , 2 , 3 ]. __id__ # => 70147646473880 Block kabul etti\u011fi i\u00e7in; dizi = Array . new ( 10 ) { | eleman | eleman = eleman * 4 } dizi # => [0, 4, 8, 12, 16, 20, 24, 28, 32, 36] # ya da ayn\u0131 kodu dizi = Array . new ( 10 ) do | eleman | eleman = eleman * 4 end dizi # => [0, 4, 8, 12, 16, 20, 24, 28, 32, 36] \u015feklinde de kullanabilirsiniz. Neticede Array\u2019in initialize method\u2019una parametre ge\u00e7mi\u015f oluyoruz: aylar = Array . [] ( \"oca\" , \"\u015fub\" , \"mar\" , \"nis\" , \"may\" , \"haz\" , \"tem\" , \"a\u011fu\" , \"eyl\" , \"eki\" , \"kas\" , \"ara\" ) aylar # => [\"oca\", \"\u015fub\", \"mar\", \"nis\", \"may\", \"haz\", \"tem\", \"a\u011fu\", \"eyl\", \"eki\", \"kas\", \"ara\"] Yani: aylar = Array.[](param, param, param) gibi. Ba\u015fka nas\u0131l \u00fcretiriz? Say\u0131lardan olu\u015fan bir dizi laz\u0131m olsa; \u00d6rne\u011fin 1984 ile 2000 aras\u0131ndaki y\u0131llar laz\u0131m olsa; years = Array ( 1984 .. 2000 ) years # => [1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000] Bir Array i\u00e7inde farkl\u0131 t\u00fcrden elemanlar olabilir; a = [ \"Hello\" , :word , 2014 , 3 . 14 ] # i\u00e7inde String, Symbol, Fixnum ve Float var! a # => [\"Hello\", :word, 2014, 3.14] Array i\u00e7indeki elemanlar s\u0131ral\u0131 bir \u015fekilde dururlar. Bu s\u0131raya Index denir. 0 \u2019dan ba\u015flar. Yani ilk eleman demek Array\u2019in 0.eleman\u0131 demektir. \u0130ste\u011fimiz eleman\u0131 almak i\u00e7in ya Array[index] ya da Array.fetch(index) y\u00f6ntemlerini kullanabiliriz. a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a [ 0 ] # => \"U\u011fur\" a . fetch ( 0 ) # => \"U\u011fur\" a [ 4 ] # => nil a . fetch ( 4 , \"Hatal\u0131 Index\" ) # => \"Hatal\u0131 Index\" a = [ 1 , 2 , 3 , 4 ] # \u0130lk N eleman\u0131 al a . take ( 2 ) # => [1, 2] a . drop ( 2 ) # => [3, 4] # take\u2019in tersi... \u0130lk 2 haricini al \u00d6rnekte a[4] dedi\u011fimiz zaman, olmayan index\u2019li eleman\u0131 almaya \u00e7al\u0131\u015f\u0131yor ve eleman olmad\u0131\u011f\u0131 i\u00e7in nil geri al\u0131yoruz. fetch kullanarak hata kontrol\u00fc de yapm\u0131\u015f oluyoruz. nil yerine belirledi\u011fimiz hata mesaj\u0131n\u0131 d\u00f6nm\u00fc\u015f oluyoruz. values_at method\u2019u ile ilgili index ya da index\u2019lerdeki elemanlar\u0131 alabiliriz, keza at de benzer i\u015fe yarar. isimler = [ \"U\u011fur\" , \"\u00d6mer\" , \"Ye\u015fim\" , \"Ezel\" , \"Eren\" ] isimler . values_at ( 0 ) # => [\"U\u011fur\"] isimler . values_at ( 1 , 2 ) # => [\"\u00d6mer\", \"Ye\u015fim\"] [ \"a\" , \"b\" , \"c\" , \"d\" , \"e\" ]. at ( 1 ) # => \"b\" [ \"a\" , \"b\" , \"c\" , \"d\" , \"e\" ]. at ( - 1 ) # => \"e\" rindex ile sa\u011fdan hizal\u0131 index\u2019e g\u00f6re elemana ula\u015f\u0131yoruz: a = [ \"a\" , \"b\" , \"b\" , \"b\" , \"c\" ] a . rindex ( \"b\" ) # => 3 # 3 tane b var, en sa\u011fdaki son b\u2019yi verdi! a . rindex ( \"z\" ) # => nil Keza \"acaba Array\u2019in ne gibi method\u2019lar\u0131 var?\" dersek; hemen methods \u00f6zelli\u011fi ile bakabiliriz. Kar\u0131\u015ft\u0131rmamam\u0131z gereken \u00f6nemli bir konu var. Detay\u0131n\u0131 Class konusunda g\u00f6rece\u011fiz ama yeri gelmi\u015fken, Array\u2019in Class Method \u2019lar\u0131 ve Instance Method \u2019lar\u0131 var. Array.methods dedi\u011fimizde Kernel\u2019dan gelen Array objesinin yani Class \u2019\u0131n\u0131n method\u2019lar\u0131n\u0131 g\u00f6r\u00fcr\u00fcz. E\u011fer Array.new.methods dersek, Array\u2019den t\u00fcretti\u011fimiz instance \u2019a ait method\u2019lar\u0131 g\u00f6r\u00fcr\u00fcz. Yani a = [] dedi\u011fimizde, asl\u0131nda Array \u2019den bir instance \u00e7\u0131kartm\u0131\u015f oluyoruz. Az \u00f6nce Array.[](...) olarak yapt\u0131\u011f\u0131m\u0131z \u015fey de asl\u0131nda Class method\u2019u \u00e7a\u011f\u0131rmak. Class Method\u2019lar\u0131 Array . methods # => [:[], :try_convert, :allocate, :new, :superclass, :freeze, :===, :==, :<=>, :<, :<=, :>, :>=, :to_s, :inspect, :included_modules, :include?, :name, :ancestors, :instance_methods, :public_instance_methods, :protected_instance_methods, :private_instance_methods, :constants, :const_get, :const_set, :const_defined?, :const_missing, :class_variables, :remove_class_variable, :class_variable_get, :class_variable_set, :class_variable_defined?, :public_constant, :private_constant, :singleton_class?, :include, :prepend, :module_exec, :class_exec, :module_eval, :class_eval, :method_defined?, :public_method_defined?, :private_method_defined?, :protected_method_defined?, :public_class_method, :private_class_method, :autoload, :autoload?, :instance_method, :public_instance_method, :nil?, :=~, :!~, :eql?, :hash, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :singleton_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__] Bu method\u2019lar\u0131n bir k\u0131sm\u0131 Enumerable s\u0131n\u0131f\u0131ndan gelen method\u2019lard\u0131r. Ruby, Module yap\u0131s\u0131 kulland\u0131\u011f\u0131 i\u00e7in ortak kullan\u0131lan method\u2019lar mod\u00fcl eklemelerinden gelmektedir. Class konusunda detaylar\u0131 g\u00f6rece\u011fiz. Bu k\u0131s\u0131mdan en fazla kullanaca\u011f\u0131m\u0131z [] ve new method\u2019lar\u0131 olacakt\u0131r. Instance Method\u2019lar\u0131 En \u00e7ok kullanaca\u011f\u0131m\u0131z method\u2019larsa; Array . new . methods # => [:inspect, :to_s, :to_a, :to_h, :to_ary, :frozen?, :==, :eql?, :hash, :[], :[]=, :at, :fetch, :first, :last, :concat, :<<, :push, :pop, :shift, :unshift, :insert, :each, :each_index, :reverse_each, :length, :size, :empty?, :find_index, :index, :rindex, :join, :reverse, :reverse!, :rotate, :rotate!, :sort, :sort!, :sort_by!, :collect, :collect!, :map, :map!, :select, :select!, :keep_if, :values_at, :delete, :delete_at, :delete_if, :reject, :reject!, :zip, :transpose, :replace, :clear, :fill, :include?, :<=>, :slice, :slice!, :assoc, :rassoc, :+, :*, :-, :&, :|, :uniq, :uniq!, :compact, :compact!, :flatten, :flatten!, :count, :shuffle!, :shuffle, :sample, :cycle, :permutation, :combination, :repeated_permutation, :repeated_combination, :product, :take, :take_while, :drop, :drop_while, :bsearch, :pack, :entries, :sort_by, :grep, :find, :detect, :find_all, :flat_map, :collect_concat, :inject, :reduce, :partition, :group_by, :all?, :any?, :one?, :none?, :min, :max, :minmax, :min_by, :max_by, :minmax_by, :member?, :each_with_index, :each_entry, :each_slice, :each_cons, :each_with_object, :chunk, :slice_before, :lazy, :nil?, :===, :=~, :!~, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :singleton_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__] Ayn\u0131 String \u2019deki gibi, \u015fu Array\u2019in bir r\u00f6ntgenini \u00e7ekelim: Array . class # => Class Array . class . superclass # => Module Array . class . superclass . superclass # => Object Array . class . superclass . superclass . superclass # => BasicObject Array . class . superclass . superclass . superclass . superclass # => nil Array\u2019in bir \u00fcst objesi ne? Module Yine Class konusunda g\u00f6rece\u011fiz diyece\u011fim ve siz bana k\u0131zacaks\u0131n\u0131z :) Ruby\u2019de bir Class en fazla ba\u015fka bir Class\u2019dan t\u00fcreyebilir. \u00d6rne\u011fin Python\u2019da bir Class N TANE Class\u2019tan inherit olabilir ( Miras alabilir, t\u00fcreyebilir ) Ruby, bu sorunu Module yap\u0131s\u0131yla \u00e7\u00f6z\u00fcyor. Bu mant\u0131kla asl\u0131nda ortakla\u015fa kullan\u0131lan Kernel mod\u00fclleri yard\u0131m\u0131yla, ortak kullan\u0131lacak method\u2019lar bu mod\u00fcllerin Include edilmesiyle ilgili yerlere da\u011f\u0131t\u0131l\u0131yor. Acaba Array\u2019de hangi mod\u00fcller var? Array . included_modules # => [Enumerable, Kernel] Bu bak\u0131mdan Array, Hash gibi nesnelerde benzer ortak method\u2019lar g\u00f6rmek m\u00fcmk\u00fcn. length veya count Array\u2019in boyu / i\u00e7inde ka\u00e7 eleman oldu\u011fu ile ilgili bilgiyi almak i\u00e7in kullan\u0131l\u0131r. [ 1 , 2 , 3 , 4 ]. length # => 4 [ 1 , 2 , 3 , 4 ]. count # => 4 empty? Array acaba bo\u015fmu? \u0130\u00e7inde hi\u00e7 eleman var m\u0131? [ 1 , 2 , 3 , 4 ]. empty? # => false []. empty? # => true eql? , == , === E\u015fitlik kontrol\u00fc i\u00e7indir. E\u011fer kar\u015f\u0131l\u0131\u011f\u0131 ayn\u0131 cinsse ve birebir ayn\u0131 elemanlara sahipse true d\u00f6ner. a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . eql? ( [ \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" , \"U\u011fur\" ] ) # => false a . eql? ( [] ) # => false a . eql? ( [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] ) # => true == Generic Equality yani genel e\u015fitlik kontrol\u00fc yani hepimizin bildi\u011fi kontrol, === ise Case Equality yani a === b ifadesinde a , b \u2019nin subseti mi? demek olur. \u00d6rnek verelim: 5 . class . superclass # => Integer Integer === 5 # => true # 5, Integer subsetinde... Integer . class # => Class Integer . class . superclass # => Module Integer . class . superclass . superclass # => Object Integer . class . superclass . superclass . superclass # => BasicObject Integer . class . superclass . superclass . superclass . superclass # => nil # Integer, 5\u2019in subsetinde de\u011fil. 5 === Integer # => false include? ve member? Acaba verdi\u011fim eleman Array\u2019in i\u00e7inde mi? Verdi\u011fim eleman bu dizinin \u00fcyesi mi? [ 1 , 2 , 3 , 4 ]. include? ( 3 ) # => true [ 1 , 2 , 3 , 4 ]. member? ( 1 ) # => true [ 1 , 2 , 3 , 4 ]. member? ( 5 ) # => false [ \"U\u011fur\" , \"Ezel\" , \"Ye\u015fim\" ]. include? ( \"U\u011fur\" ) # => true [ \"U\u011fur\" , \"Ezel\" , \"Ye\u015fim\" ]. include? ( \"\u00d6mer\" ) # => false array & ba\u015fka_bir_array \u0130ki dizide de kullan\u0131n ortak elemanlar\u0131 al\u0131r yeni Array d\u00f6ner: a = [ 1 , 2 , 3 , 4 ] b = [ 3 , 1 , 10 , 22 ] a & b # => [1, 3] array * int [ya da] array * str a = [ \"a\" , \"b\" , \"c\" ] a * 5 # => [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\"] a * \"-vigo-\" # => \"a-vigo-b-vigo-c\" **\\*** \u00e7aparak 3 elemanl\u0131 a Array\u2019inden sanki birle\u015ftirilmi\u015f 15 elemanl\u0131 yeni bir Array olu\u015fturduk. String ile \u00e7arp\u0131nca da asl\u0131nda join methodu ile Array\u2019den String yapt\u0131k ve birle\u015ftirici olarak -vigo- metni kulland\u0131k! array + ba\u015fka_array \u0130ki Array\u2019i toplar ve yeni Array d\u00f6ner: a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" ] b = [ \"\u00d6mer\" ] a + b # => [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\"] array - ba\u015fka_array Array\u2019ler aras\u0131ndaki fark\u0131 Array olarak bulmak: a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" ] b = [ \"U\u011fur\" , \"Ye\u015fim\" ] a - b # => [\"Ezel\"] # a\u2019da olab b elemanlar\u0131 kayboldu array | ba\u015fka_array \u0130ki Array\u2019i unique ( tekil ) elemanlar olarak birle\u015ftirdi. Ayn\u0131 eleman varsa bunlardan birini ald\u0131: a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" ] b = [ \"U\u011fur\" , \"\u00d6mer\" ] a | b # => [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\"] array << nesne ya da push Array\u2019in sonuna eleman eklemek i\u00e7in kullan\u0131l\u0131r. a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" ] a << \"\u00d6mer\" # => [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\"] a . push ( \"Eren\" ) # => [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\", \"Eren\"] Keza zincirleme \u00e7a\u011fr\u0131 da yapabilirsiniz: a . push ( \"Tun\u00e7\" ) . push ( \"Suat\" ) # => [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\", \"Eren\", \"Tun\u00e7\", \"Suat\"] concat Array sonuna Array eklemek i\u00e7in kullan\u0131l\u0131r. a = [ 1 , 2 , 3 ] a . concat ( [ 4 , 5 , 6 ] ) a # => [1, 2, 3, 4, 5, 6] join Array elemanlar\u0131n\u0131 birle\u015ftirip String \u2019e \u00e7evirmeye yarar. E\u011fer parametre verirsek aradaki birle\u015ftiriciyi de belirlemi\u015f oluruz. [ \"Commodore 64\" , \"Amiga\" , \"Sinclair\" , \"Amstrad\" ]. join # => \"Commodore 64AmigaSinclairAmstrad\" [ \"Commodore 64\" , \"Amiga\" , \"Sinclair\" , \"Amstrad\" ]. join ( \" , \" ) # => \"Commodore 64 , Amiga , Sinclair , Amstrad\" unshift Array\u2019in ba\u015f\u0131na eleman eklemek i\u00e7in kullan\u0131l\u0131r. a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" ] a . unshift ( \"\u00d6mer\" ) # => [\"\u00d6mer\", \"U\u011fur\", \"Ye\u015fim\", \"Ezel\"] insert Array\u2019de istedi\u011finiz bir noktaya eleman eklemek i\u00e7in kullan\u0131l\u0131r. \u0130lk parametre index di\u011fer parametre/ler de eklenecek eleman/lar. a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" ] a . insert ( 1 , \"\u00d6mer\" ) # => [\"U\u011fur\", \"\u00d6mer\", \"Ye\u015fim\", \"Ezel\"] a . insert ( 1 , \"Ahmet\" , \"Ece\" , \"Eren\" ) # => [\"U\u011fur\", \"Ahmet\", \"Ece\", \"Eren\", \"\u00d6mer\", \"Ye\u015fim\", \"Ezel\"] replace Array\u2019in i\u00e7ini, di\u011fer Array\u2019le de\u011fi\u015ftirir. Asl\u0131nda Array\u2019i ba\u015fka bir Array\u2019e e\u015fitlemek gibidir. Eleman say\u0131s\u0131n\u0131n e\u015fit olup olmamas\u0131 hi\u00e7 \u00f6nemli de\u011fildir. a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . replace ( [ \"Foo\" , \"Bar\" ] ) # => [\"Foo\", \"Bar\"] a # => [\"Foo\", \"Bar\"] array <=> ba\u015fka_array Spaceship operat\u00f6r\u00fcnden bahsetmi\u015ftik. Array\u2019ler aras\u0131nda kar\u015f\u0131la\u015ft\u0131rma yapmay\u0131 sa\u011flar. [ 1 , 2 , 3 , 4 ] <=> [ 1 , 2 , 3 , 4 ] # => 0 # E\u015fit [ 1 , 2 , 3 , 4 ] <=> [ 1 , 2 , 3 ] # => 1 # \u0130lk de\u011fer b\u00fcy\u00fck [ 1 , 2 , 3 ] <=> [ 1 , 2 , 3 , 4 ] # => -1 # \u0130lk de\u011fer k\u00fc\u00e7\u00fck pop , shift , delete , delete_at , delete_if Son eleman\u0131 \u00e7\u0131kartmak i\u00e7in pop ilk eleman\u0131 \u00e7\u0131kartmak i\u00e7in shift kullan\u0131l\u0131r. Herhangi bir eleman\u0131 \u00e7\u0131kartmak i\u00e7in delete , belirli bir index\u2019deki eleman\u0131 \u00e7\u0131kartmak i\u00e7in delete_at kullan\u0131l\u0131r. a = [ \"U\u011fur\" , \"\u00d6mer\" , \"Ye\u015fim\" , \"Ezel\" , \"Eren\" ] a . pop # => \"Eren\" a # => [\"U\u011fur\", \"\u00d6mer\", \"Ye\u015fim\", \"Ezel\"] a . shift # => \"U\u011fur\" a # => [\"\u00d6mer\", \"Ye\u015fim\", \"Ezel\"] a . delete ( \"\u00d6mer\" ) # => \"\u00d6mer\" a # => [\"Ye\u015fim\", \"Ezel\"] a . delete_at ( 1 ) # => \"Ezel\" a # => [\"Ye\u015fim\"] # not 50\u2019den k\u00fc\u00e7\u00fckse sil :) notlar = [ 40 , 45 , 53 , 70 , 99 , 65 ] notlar . delete_if { | notu | notu < 50 } # => [53, 70, 99, 65] pop \u2019a parametre ge\u00e7ersek son n taneyi u\u00e7urmu\u015f oluruz: a = [ \"U\u011fur\" , \"\u00d6mer\" , \"Ye\u015fim\" , \"Ezel\" , \"Eren\" ] a . pop ( 2 ) # => [\"Ezel\", \"Eren\"] a # => [\"U\u011fur\", \"\u00d6mer\", \"Ye\u015fim\"] compact ve uniq nil elemanlar\u0131 u\u00e7urmak i\u00e7in compact , duplike elemanlar\u0131 tekil hale getirmek i\u00e7in uniq kullan\u0131l\u0131r. [ \"a\" , 1 , nil , 2 , nil , \"b\" , 1 , \"a\" ]. compact # => [\"a\", 1, 2, \"b\", 1, \"a\"] [ \"a\" , 1 , nil , 2 , nil , \"b\" , 1 , \"a\" ]. uniq # => [\"a\", 1, nil, 2, \"b\"] [ \"a\" , 1 , nil , 2 , nil , \"b\" , 1 , \"a\" ]. compact . uniq # => [\"a\", 1, 2, \"b\"] array == ba\u015fka_array \u0130ki Array nitelik ve nicelik olarak birbirine e\u015fit mi? [ 1 , 2 , 3 , 4 ] == [ 1 , 2 , 3 , 4 ] # => true [ 1 , 2 , 3 , 4 ] == [ \"1\" , 2 , 3 , 4 ] # => false [ 1 , 2 , 3 , 4 ] == [ 1 , 2 , 3 ] # => false assoc ve rassoc Elemanlar\u0131 Array olan bir Array i\u00e7inde, ilk de\u011fere g\u00f6re yakalama yapmaya yarar. a = [ \"renkler\" , \"k\u0131rm\u0131z\u0131\" , \"sar\u0131\" , \"mavi\" ] b = [ \"harfler\" , \"a\" , \"b\" , \"c\" ] c = \"foo\" t = [ a , b , c ] t # => [[\"renkler\", \"k\u0131rm\u0131z\u0131\", \"sar\u0131\", \"mavi\"], [\"harfler\", \"a\", \"b\", \"c\"], \"foo\"] t . assoc ( \"renkler\" ) # => [\"renkler\", \"k\u0131rm\u0131z\u0131\", \"sar\u0131\", \"mavi\"] t . assoc ( \"foo\" ) # => nil t . rassoc ( \"k\u0131rm\u0131z\u0131\" ) # => [\"renkler\", \"k\u0131rm\u0131z\u0131\", \"sar\u0131\", \"mavi\"] rassoc ise ikinci eleman\u0131na bakar, yani \"renkler\" yerine \"k\u0131r\u0131m\u0131z\u0131\" kullanabiliriz: slice(ba\u015flang\u0131\u00e7, boy) ya da slice(aral\u0131k) Array i\u00e7inden kesip ba\u015fka bir Array olu\u015fturmak i\u00e7in kullan\u0131l\u0131r. ba\u015flangi\u00e7 indeks\u2019indeki eleman dahil olmak \u00fczere, boy ya da aral\u0131k kadar\u0131n\u0131 kes. [ 1 , 2 , 3 , 4 ]. slice ( 0 , 2 ) # => [1, 2] # 0.dan itibaren 2 tane [ 1 , 2 , 3 , 4 ]. slice ( 2 .. 4 ) # => [3, 4] # 2.den itibaren 2 tane first ve last Ad\u0131ndan da anla\u015f\u0131laca\u011f\u0131 gibi, Array\u2019in ilk ve son elemanlar\u0131 i\u00e7in kullan\u0131l\u0131r: a = [ 1 , 2 , 3 , 4 , 5 ] a . first # => 1 a . last # => 5 E\u011fer parametre ge\u00e7ersek, ilk n ya da son n elemanlar\u0131 alabiliriz: a = [ 1 , 2 , 3 , 4 , 5 ] a . first ( 2 ) # => [1, 2] a . last ( 2 ) # => [4, 5] find ( detect ), find_all , index , find_index find ile blok i\u00e7inde ko\u015fula uyan ilk Array eleman\u0131n\u0131, find_all ile t\u00fcm\u00fcn\u00fc al\u0131r\u0131z: [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ]. find { | n | n . length > 3 } # => \"U\u011fur\" [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ]. find_all { | n | n . length > 3 } # => [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\"] detect ile find ayn\u0131 i\u015fi yapar. index , find_index ile eleman\u0131n index\u2019ini buluruz: [ \"a\" , \"b\" , \"c\" , \"d\" , \"e\" ]. index ( \"e\" ) # => 4 [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ]. index ( \"Ezel\" ) # => 2 [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ]. find_index ( \"Ezel\" ) # => 2 clear Array\u2019i temizlemek i\u00e7in kullan\u0131l\u0131r :) a = [ 1 , 2 , 3 ] a . clear # => [] a # => [] reverse Array\u2019i terse \u00e7evir. a = [ 1 , 2 , 3 , 4 , 5 ] a . reverse # => [5, 4, 3, 2, 1] sample Array\u2019den random olarak eleman almaya yarar. E\u011fer parametre ge\u00e7ilirse ge\u00e7ilen adet kadar random eleman d\u00f6ner. a = [ 1 , 2 , 3 , 4 , 5 ] a . sample # => 3 a . sample ( 3 ) # => [5, 1, 3] shuffle Array\u2019in i\u00e7indeki elemanlar\u0131n index\u2019lerini kar\u0131\u015ft\u0131r\u0131r :) a = [ 1 , 2 , 3 , 4 , 5 ] a . shuffle # => [5, 4, 1, 3, 2] a . shuffle # => [1, 2, 3, 5, 4] sort Array i\u00e7indeki elemanlar\u0131 <=> mant\u0131\u011f\u0131yla s\u0131ralar. a = [ 1 , 4 , 2 , 3 , 11 , 5 ] a . sort # => [1, 2, 3, 4, 5, 11] b = [ \"a\" , \"c\" , \"b\" , \"z\" , \"d\" ] b . sort # => [\"a\", \"b\", \"c\", \"d\", \"z\"] fill Array\u2019in i\u00e7ini ilgili de\u011ferle doldurmak i\u00e7in kullan\u0131l\u0131r. \u0130\u015flem sonucunda orijinal Array\u2019in de\u011feri de\u011fi\u015fir. Yani ne ile fill ettiyseniz Array art\u0131k o de\u011ferlerdedir. a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . fill ( \"x\" ) # => [\"x\", \"x\", \"x\", \"x\"] # t\u00fcm elemanlar\u0131 x yapt\u0131 a # => [\"x\", \"x\", \"x\", \"x\"] # art\u0131k a\u2019n\u0131n yeni de\u011feri bu a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . fill ( \"y\" , 2 ) # => [\"U\u011fur\", \"Ye\u015fim\", \"y\", \"y\"] # 2.den itibaren y ile doldur a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] # 2.den itibaren 1 tane doldur a . fill ( \"z\" , 2 , 1 ) # => [\"U\u011fur\", \"Ye\u015fim\", \"z\", \"\u00d6mer\"] Keza; a = [ 1 , 2 , 3 , 4 , 5 ] a . fill { | i | i * 5 } # => [0, 5, 10, 15, 20] a # => [0, 5, 10, 15, 20] \u015feklinde de kullan\u0131l\u0131r. flatten Array i\u00e7inde Array elemanlar\u0131 varsa, tek harekette bunlar\u0131 d\u00fcz tek bir Array haline getirebiliriz. [ 1 , 2 , [ \"a\" , \"b\" , :c ] , [ 66 , [ 5 . 5 , 3 . 1 ]]]. flatten # => [1, 2, \"a\", \"b\", :c, 66, 5.5, 3.1] rotate Array elemanlar\u0131 kendi i\u00e7inde kayd\u0131r\u0131r. a = [ 1 , 2 , 3 , 4 , 5 ] a . rotate # => [2, 3, 4, 5, 1] # 1 kayd\u0131rd\u0131 a . rotate ( 2 ) # => [3, 4, 5, 1, 2] # 2 kayd\u0131rd\u0131, ilk 2 eleman\u0131 sona koydu! Varsay\u0131lan de\u011fer 1 \u2019dir. zip a = [ 4 , 5 , 6 ] b = [ 7 , 8 , 9 ] [ 1 , 2 , 3 ]. zip ( a , b ) # => [[1, 4, 7], [2, 5, 8], [3, 6, 9]] [ 1 , 2 ]. zip ( a , b ) # => [[1, 4, 7], [2, 5, 8]] a . zip ( [ 1 , 2 ] , [ 8 ] ) # => [[4, 1, 8], [5, 2, nil], [6, nil, nil]] [1, 2, 3].zip(a, b) i\u015flemini yaparken, \u00f6nce 0.eleman\u0131 yani 1 \u2019i ald\u0131, sonra a \u2019nun 0.eleman\u0131n\u0131 ald\u0131, sonra da b \u2019nin 0.eleman\u0131n\u0131 ald\u0131 ve paketledi : [1, 4, 7] ayn\u0131 i\u015fi 1. ve 2. elemanlar i\u00e7in yapt\u0131. [1, 2].zip(a, b) yaparken, Array boylar\u0131 e\u015fit olmad\u0131\u011f\u0131 i\u00e7in [1, 2] sadece 2 elemanl\u0131 oldu\u011fu i\u00e7in bu i\u015flemi 0. ve 1. elemanlar i\u00e7in yapt\u0131. Son \u00f6rnekte index\u2019e kar\u015f\u0131l\u0131k gelmedi\u011fi i\u00e7in elemanlar nil geldi! transpose Array i\u00e7indeki Array\u2019leri sat\u0131r gibi d\u00fc\u015f\u00fcn\u00fcp bunlar\u0131 s\u00fctuna \u00e7eviriyor gibi alg\u0131layabilirsiniz. a = [[ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ]] a . transpose # => [[1, 3, 5], [2, 4, 6]] # [ # [1, 2], # [3, 4], # [5, 6] # ] # -> [1, 3, 5], [2, 4, 5] # Tip \u00c7eviricileri to_a ve to_ary kendisini d\u00f6ner, as\u0131l g\u00f6revi e\u011fer alt s\u0131n\u0131ftan \u00e7a\u011fr\u0131lm\u0131\u015fsa, yani Array\u2019den t\u00fcreyen ba\u015fka bir Class\u2019da kullan\u0131ld\u0131\u011f\u0131nda direk Array\u2019e d\u00f6n\u00fc\u015ft\u00fcr\u00fcr. [ \"a\" , 1 , \"b\" , 2 ]. to_a # => [\"a\", 1, \"b\", 2] [ \"a\" , 1 , \"b\" , 2 ]. to_ary # => [\"a\", 1, \"b\", 2] [[ \"a\" , 1 ] , [ \"b\" , 2 ]]. to_h # => {\"a\"=>1, \"b\"=>2} [ \"a\" , 1 , \"b\" , 2 ]. to_s # => \"[\\\"a\\\", 1, \\\"b\\\", 2]\" [ \"a\" , 1 , \"b\" , 2 ]. inspect # => \"[\\\"a\\\", 1, \\\"b\\\", 2]\" entries de aynen to_a gibi \u00e7al\u0131\u015f\u0131r: ( 1 .. 3 ) # => 1..3 ( 1 .. 3 ) . entries # => [1, 2, 3] ( 1 .. 3 ) . to_a # => [1, 2, 3] grep Asl\u0131nda bu konular\u0131 Regular Expressions \u2019da g\u00f6rece\u011fiz ama yeri gelmi\u015fken h\u0131zla de\u011finelim. Array i\u00e7inde elemanlar\u0131 Regex ko\u015fullar\u0131na g\u00f6re filtreleyebiliyoruz: ( 1 .. 10 ) . to_a # => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 2\u2019den 5\u2019e kadar (5 dahil) ( 1 .. 10 ) . grep 2 .. 5 # => [2, 3, 4, 5] # sadece .com olan elemanlar\u0131 al [ \"a\" , \"http://example.com\" , \"b\" , \"foo\" , \"http://webbox.io\" ]. grep ( /^http.+\\.com/ ) # => [\"http://example.com\"] pack Array\u2019in i\u00e7eri\u011fini verilen direktife g\u00f6re Binary String haline getirir. Uzunca bir direktif listesi var. # A: String olarak i\u015fle, space karakteri kullan # 5: Uzunlu\u011fu 5 karakter olsun [ \"a\" , \"b\" , \"c\" ]. pack ( \"A5A5A5\" ) # => \"a b c \" # Uzunlu\u011fu 5\u2019ten b\u00fcy\u00fck olan kesintiye u\u011frad\u0131 [ \"ali\" , \"burak\" , \"cengiz\" ]. pack ( \"A5A5A5\" ) # => \"ali burakcengi\" # a: String olarak i\u015fle, null yani \\x00 karakteri kullan [ \"a\" , \"b\" , \"c\" ]. pack ( \"a3a3a3\" ) # => \"a\\x00\\x00b\\x00\\x00c\\x00\\x00\" \u0130terasyon ve Block Kullan\u0131m\u0131 collect / map { |eleman| blok } \u2192 yeni_array Blok i\u00e7inde gelen kodu her elemana uygular, yeni Array d\u00f6ner: a = [ 1 , 2 , 3 , 4 , 5 ] a . collect { | i | i * 2 } # => [2, 4, 6, 8, 10] a . collect { | i | \"say\u0131 #{ i } \" } # => [\"say\u0131 1\", \"say\u0131 2\", \"say\u0131 3\", \"say\u0131 4\", \"say\u0131 5\"] map de ayn\u0131 i\u015fi yapar: [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ]. map { | isim | \"\u0130sim: #{ isim } \" } # => [\"\u0130sim: U\u011fur\", \"\u0130sim: Ye\u015fim\", \"\u0130sim: Ezel\", \"\u0130sim: \u00d6mer\"] [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ]. collect { | isim | \"\u0130sim: #{ isim } \" } # => [\"\u0130sim: U\u011fur\", \"\u0130sim: Ye\u015fim\", \"\u0130sim: Ezel\", \"\u0130sim: \u00d6mer\"] select Blok i\u00e7inden gelen ifadenin true / false olmas\u0131na g\u00f6re filtre yapar ve yeni Array d\u00f6ner: [ 1 , 2 , 3 , 10 , 15 , 20 ]. select { | n | n % 2 == 0 } # => [2, 10, 20] # 2\u2019ye tam b\u00f6l\u00fcnenler [ 1 , 2 , \"3\" , \"ali\" , 15 , 20 ]. select { | n | n . is_a? ( Fixnum ) } # => [1, 2, 15, 20] # sadece say\u0131lar reject select in tersidir. [ 1 , 2 , 3 , 10 , 15 , 20 ]. reject { | n | n % 2 == 0 } # => [1, 3, 15] # 2\u2019ye tam b\u00f6l\u00fclenleri at [ 1 , 2 , \"3\" , \"ali\" , 15 , 20 ]. reject { | n | n . is_a? ( Fixnum ) } # => [\"3\", \"ali\"] # Say\u0131 olanlar\u0131 at keep_if Blok i\u00e7indeki ifade\u2019den sadece false d\u00f6nenleri atar ve Array\u2019in orjinal de\u011ferini bozar, de\u011fi\u015ftirir. a = [ 1 , 2 , 3 , 10 , 15 , 20 ] a . keep_if { | n | n % 2 == 0 } # => [2, 10, 20] # 2\u2019ye b\u00f6l\u00fcnemeyenler false geldi\u011fi i\u00e7in d\u00fc\u015ft\u00fcler. a # => [2, 10, 20] # a art\u0131k bu! combination(n) { |c| blok } \u2192 array Matematikteki kombinasyon i\u015flemidir. 1, 2 ve 3 say\u0131lar\u0131n\u0131n 2\u2019li kombinasyonu: a = [ 1 , 2 , 3 ] a . combination ( 1 ) . to_a # => [[1], [2], [3]] a . combination ( 2 ) . to_a # => [[1, 2], [1, 3], [2, 3]] a . combination ( 2 ) { | c | puts \"Olas\u0131klar: #{ c . join ( \" ve \" ) } \" } # Olas\u0131klar: 1 ve 2 # Olas\u0131klar: 1 ve 3 # Olas\u0131klar: 2 ve 3 permutation Ayn\u0131 kombinasyon gibi, matematikteki perm\u00fctasyon i\u015flemidir. [ 1 , 2 , 3 ]. permutation . to_a # => [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] E\u011fer parametre ge\u00e7ersek ka\u00e7l\u0131 perm\u00fctasyon oldu\u011funu belirtiriz: [ 1 , 2 , 3 ]. permutation ( 1 ) . to_a # => [[1], [2], [3]] [ 1 , 2 , 3 ]. permutation ( 2 ) . to_a # => [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] repeated_combination , repeated_permutation combination ile repeated_combination aras\u0131ndaki fark\u0131 \u00f6rnekle g\u00f6relim: [ 1 , 2 , 3 ]. combination ( 1 ) . to_a # => [[1], [2], [3]] [ 1 , 2 , 3 ]. repeated_combination ( 1 ) . to_a # => [[1], [2], [3]] [ 1 , 2 , 3 ]. combination ( 2 ) . to_a # => [[1, 2], [1, 3], [2, 3]] [ 1 , 2 , 3 ]. repeated_combination ( 2 ) . to_a # => [[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3]] combination olas\u0131 tekil sonucu, repeated_combination pas edilen say\u0131ya g\u00f6re tekrar da edebilen sonucu d\u00f6ner. Ayn\u0131s\u0131 repeated_permutation i\u00e7in de ge\u00e7erlidir: [ 1 , 2 , 3 ]. permutation ( 1 ) . to_a # => [[1], [2], [3]] [ 1 , 2 , 3 ]. repeated_permutation ( 1 ) . to_a # => [[1], [2], [3]] [ 1 , 2 , 3 ]. permutation ( 2 ) . to_a # => [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] [ 1 , 2 , 3 ]. repeated_permutation ( 2 ) . to_a # => [[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]] product Array ve arg\u00fcman olarak ge\u00e7ilecek di\u011fer Array/lerin elemanlar\u0131yla olu\u015fabilecek t\u00fcm alternatifleri \u00fcretmenizi sa\u011flar. [ 1 , 2 , 3 ]. product # => [[1], [2], [3]] [ 1 , 2 , 3 ]. product ( [ 4 , 5 ] ) # => [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]] [ 1 , 2 , 3 ]. product ( [ 7 , 8 , 9 ] ) # => [[1, 7], [1, 8], [1, 9], [2, 7], [2, 8], [2, 9], [3, 7], [3, 8], [3, 9]] [ 1 , 2 , 3 ]. product ( [ \"a\" , \"b\" ] , [ \"x\" , \"y\" ] ) # => [[1, \"a\", \"x\"], [1, \"a\", \"y\"], [1, \"b\", \"x\"], [1, \"b\", \"y\"], [2, \"a\", \"x\"], [2, \"a\", \"y\"], [2, \"b\", \"x\"], [2, \"b\", \"y\"], [3, \"a\", \"x\"], [3, \"a\", \"y\"], [3, \"b\", \"x\"], [3, \"b\", \"y\"]] count Az \u00f6nce method olarak i\u015fledi\u011fimiz count ile ba\u015fka ilgin\u00e7 i\u015fler de yapabiliyoruz: a = [ 1 , 2 , 3 , 4 , 2 ] a . count # => 5 # eleman say\u0131s\u0131 a . count ( 2 ) # => 2 # ka\u00e7 tane 2 var? a . count { | n | n % 2 == 0 } # => 3 # ka\u00e7 tane 2\u2019ye tam b\u00f6l\u00fcnen var? cycle(n=nil) { |obje| blok } \u2192 nil Pas edilen blok\u2019u n defa tekrar eder. a = [ 1 , 2 , 3 ] a . cycle ( 2 ) . to_a # => [1, 2, 3, 1, 2, 3] # 2 defa a . cycle ( 4 ) . to_a # => [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3] # 3defa a . cycle ( 2 ) { | o | puts \"Say\u0131 #{ o } \" } # Say\u0131 1 # Say\u0131 2 # Say\u0131 3 # Say\u0131 1 # Say\u0131 2 # Say\u0131 3 E\u011fer [1, 2, 3].cycle { |i| puts i } gibi bir i\u015flem yaparsan\u0131z, default olarak nil ge\u00e7mi\u015f olursun ve bu sonsuz d\u00f6ng\u00fcle girer, sonsuza kadar 1, 2, 3, 1, 2, 3 .... \u015feklinde devam eder! drop_while { |array| blok } \u2192 yeni array delete_if ile ayn\u0131 i\u015fi yapar. notlar = [ 40 , 45 , 53 , 70 , 99 , 65 ] notlar . drop_while { | notu | notu < 50 } # => [53, 70, 99, 65] Ko\u015fula g\u00f6re Array\u2019den atar gibi d\u00fc\u015f\u00fcnebilirsiniz. Not 50\u2019den k\u00fc\u00e7\u00fckse b\u0131rak. take_while Ayn\u0131 drop_while gibi \u00e7al\u0131\u015f\u0131r ama tersini yapar: notlar = [ 40 , 45 , 53 , 70 , 99 , 65 ] notlar . take_while { | notu | notu < 50 } # => [40, 45] Ko\u015fula g\u00f6re Array\u2019e ekler gibi d\u00fc\u015f\u00fcnebilirsiniz. Not 50\u2019den k\u00fc\u00e7\u00fckse sepete ekle! :) each , each_index , each_with_index , each_slice , each_cons , each_with_object , reverse_each Array ve hatta Enumator\u2019lerin can damar\u0131d\u0131r. Ruby yazarken siz de g\u00f6receksiniz each en s\u0131k kulland\u0131\u011f\u0131n\u0131z iterasyon ( yineleme / tekrarlama ) y\u00f6ntemi olacak. a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . each # => #<Enumerator: [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\"]:each> a . each { | isim | puts \"\u0130sim: #{ isim } \" } # \u0130sim: U\u011fur # \u0130sim: Ye\u015fim # \u0130sim: Ezel # \u0130sim: \u00d6mer Array ve i\u00e7inde dola\u015f\u0131labilir her nesnede i\u015fe yarar. Birde bunun index \u2019li hali var; a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . each_index # => #<Enumerator: [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\"]:each_index> a . each_index . to_a # => [0, 1, 2, 3] a . each_index { | i | puts \"Index: #{ i } , De\u011feri: #{ a [ i ] } \" } # Index: 0, De\u011feri: U\u011fur # Index: 1, De\u011feri: Ye\u015fim # Index: 2, De\u011feri: Ezel # Index: 3, De\u011feri: \u00d6mer ya da bu i\u015fi; a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . each_with_index { | eleman , index | puts \"index: #{ index } , eleman: #{ eleman } \" } # index: 0, eleman: U\u011fur # index: 1, eleman: Ye\u015fim # index: 2, eleman: Ezel # index: 3, eleman: \u00d6mer each_slice da Array\u2019i gruplamak, par\u00e7alara ay\u0131rmak i\u00e7indir. Ge\u00e7ilen parametre bu i\u015fe yarar: a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . each_slice ( 2 ) # => #<Enumerator: [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\"]:each_slice(2)> a . each_slice ( 2 ) . to_a # => [[\"U\u011fur\", \"Ye\u015fim\"], [\"Ezel\", \"\u00d6mer\"]] a . each_slice ( 2 ) { | ikili_grup | puts \" #{ ikili_grup } \" } # [\"U\u011fur\", \"Ye\u015fim\"] # [\"Ezel\", \"\u00d6mer\"] each_cons ise slice gibi ama mutlaka belirtilen miktarda par\u00e7a \u00fcretir. # 3\u2019l\u00fc \u00fcret [ 1 , 2 , 3 , 4 , 5 , 6 ]. each_cons ( 3 ) . to_a # => [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]] # 4\u2019l\u00fc \u00fcret [ 1 , 2 , 3 , 4 , 5 , 6 ]. each_cons ( 4 ) . to_a # => [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]] each_with_object de ise, iterasyona girerken bir nesne pas edip, o nesneyi doldurabilirsiniz. [ 1 , 2 , 3 , 4 ]. each_with_object ( [] ) { | number , given_object | given_object << number * 2 } # => [2, 4, 6, 8] number Array\u2019den gelen eleman ( 1, 2, 3, 4 gibi ), given_object ise each_with_object([]) method\u2019da ge\u00e7ti\u011fimiz bo\u015f Array [] . reverse_each asl\u0131nda Array\u2019i otomatik olarak ters \u00e7evirir yani reverse eder ve i\u00e7inde dola\u015fman\u0131z\u0131 sa\u011flar: computers = [ \"Commodore 64\" , \"Amiga\" , \"Sinclair\" , \"Amstrad\" ] computers . reverse_each # => #<Enumerator: [\"Commodore 64\", \"Amiga\", \"Sinclair\", \"Amstrad\"]:reverse_each> computers . reverse_each . to_a # => [\"Amstrad\", \"Sinclair\", \"Amiga\", \"Commodore 64\"] computers . reverse_each { | c | puts \"Bilgisayar: #{ c } \" } # Bilgisayar: Amstrad # Bilgisayar: Sinclair # Bilgisayar: Amiga # Bilgisayar: Commodore 64 find_index \u0130ndeks\u2019i ararken blok i\u015fleyebiliriz: computers = [ \"Commodore 64\" , \"Amiga\" , \"Sinclair\" , \"Amstrad\" ] computers . find_index { | c | c == \"Amstrad\" } # => 3 freeze ve frozen? Array\u2019i kitlemek i\u00e7in kullan\u0131l\u0131r. Yani freeze ( dondurulmu\u015f ) bir Array\u2019e yeni eleman eklenemez. Keza Array#sort esnas\u0131nda da otomatik olarak freeze olur sort bitince buz \u00e7\u00f6z\u00fcl\u00fcr! a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . freeze a << \"Fazilet\" # Yeni isim eklemek m\u00fcmk\u00fcn de\u011fildir! RuntimeError : can \u2019 t modify frozen Array Array\u2019de buzlanma var m\u0131 yok mu anlamak i\u00e7in frozen? kullan\u0131r\u0131z: a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . freeze # => [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\"] a . frozen? # => true min , max , minmax , min_by , max_by ve minmax_by min ve max ile Array elemanlar\u0131ndan en k\u00fc\u00e7\u00fck/b\u00fcy\u00fck de\u011feri al\u0131r\u0131z: a = [ 6 , 1 , 8 , 4 , 11 ] a . min # => 1 a . max # => 11 Peki say\u0131 yerine metinler olsa ne olacakt\u0131? m = [ \"a\" , \"ab\" , \"abc\" , \"abcd\" ] m . min # => \"a\" m . max # => \"abcd\" peki, m Array\u2019i \u015f\u00f6yle olsayd\u0131: m = [\"a\", \"ab\", \"abc\", \"abcd\", \"111111111\"] sonu\u00e7 ne olurdu? m = [ \"a\" , \"ab\" , \"abc\" , \"abcd\" , \"111111111\" ] m . min # => \"111111111\" # ? m . max # => \"abcd\" \u00d6nce Comparable m\u0131 diyer bak\u0131l\u0131r, say\u0131lar i\u00e7in \u00e7al\u0131\u015fan bu y\u00f6ntem, String de a <=> b kar\u015f\u0131la\u015ft\u0131rmas\u0131na girer ve Lexicological kar\u015f\u0131la\u015ft\u0131rma yapar. \"111111111\" karakter say\u0131s\u0131 olarak di\u011ferlerine g\u00f6re \u00e7ok olmas\u0131na ra\u011fmen, min de\u011fer olarak gelir. E\u011fer karakter say\u0131na g\u00f6re kar\u015f\u0131la\u015ft\u0131rma yapmak gerekiyorsa; m = [ \"a\" , \"ab\" , \"abc\" , \"abcd\" , \"111111111\" ] m . min { | a , b | a . length <=> b . length } # => \"a\" m . max # => \"abcd\" \u015eeklinde yapmak gerekir. Blok kullanabildi\u011fimiz i\u00e7in ayn\u0131 i\u015f max i\u00e7in de ge\u00e7erlidir. Ya da bu i\u015fleri yapabilmek i\u00e7in min_by ve max_by kullanabiliriz: m = [ \"a\" , \"ab\" , \"abc\" , \"abcd\" , \"111111111\" ] m . min_by { | x | x . length } # => \"a\" m . max_by { | x | x . length } # => \"111111111\" minmax da Array\u2019in minimum ve maximum\u2019unu d\u00f6ner: m = [ \"a\" , \"ab\" , \"abc\" , \"abcd\" ] m . min # => \"a\" m . max # => \"abcd\" m . minmax # => [\"a\", \"abcd\"] Ayn\u0131 mant\u0131kta minmax_by da gerekli \u015farta g\u00f6re min , max d\u00f6ner: m = [ \"a\" , \"ab\" , \"abc\" , \"abcd\" ] m . minmax_by { | x | x . length } # => [\"a\", \"abcd\"] all? , any? , one? , none? Array i\u00e7indeki elemanlar\u0131 belli bir ko\u015fula g\u00f6re kontrol etmek i\u00e7in kullan\u0131l\u0131r. Sonu\u00e7 Boolean yani true ya da false d\u00f6ner. T\u00fcm elemanlar\u0131n kontrol\u00fc ko\u015fula uyuyorsa true uymuyorsa false d\u00f6ner. # acaba hayvanlar dizisindeki isimlerin hepsinin uzunlu\u011fu # en az 2 karakter mi? hayvanlar = [ \"Kedi\" , \"K\u00f6pek\" , \"Ku\u015f\" , \"Kurba\u011fa\" , \"Kaplumba\u011fa\" ] hayvanlar . all? { | hayvan_ismi | hayvan_ismi . length >= 2 } # => true # Acaba ilk karfleri K harfimi? hayvanlar . all? { | hayvan_ismi | hayvan_ismi . start_with? ( \"K\" ) } # => true # Elemanlar\u0131n her biri true mu? [ true , false , nil ]. all? # => false any? de yanl\u0131zca bir tanesi true olsa yeterlidir: # En az\u0131ndan bir hayvan ismi A ile ba\u015fl\u0131yor mu? hayvanlar = [ \"Kedi\" , \"K\u00f6pek\" , \"At\" , \"Y\u0131lan\" , \"Bal\u0131k\" ] hayvanlar . any? { | hayvan_ismi | hayvan_ismi . start_with? ( \"A\" ) } # => true one? da ise sadece bir eleman ko\u015fula uymal\u0131d\u0131r. Yani bir tanesi true d\u00f6nmelidir. E\u011fer birden fazla eleman ko\u015fula true d\u00f6nerse sonu\u00e7 false olur: hayvanlar = [ \"Kedi\" , \"K\u00f6pek\" , \"At\" , \"Y\u0131lan\" , \"Bal\u0131k\" , \"Kaplumba\u011fa\" ] # Sadece bir ismin uzunlu\u011fu 6 karaterten b\u00fcy\u00fck olmal\u0131! hayvanlar . one? { | hayvan_ismi | hayvan_ismi . length > 6 } # => true # Uzunlu\u011fu 3\u2019ten b\u00fcy\u00fck 5 isim oldu\u011fu i\u00e7in false d\u00f6nd\u00fc! hayvanlar . one? { | hayvan_ismi | hayvan_ismi . length > 3 } # => false none? da ise hepsi false olmal\u0131d\u0131r ki sonu\u00e7 true d\u00f6ns\u00fcn: hayvanlar = [ \"Kedi\" , \"K\u00f6pek\" , \"At\" , \"Y\u0131lan\" , \"Bal\u0131k\" , \"Kaplumba\u011fa\" ] # Hi\u00e7bir ismin uzunlu\u011fu 2 karakter olmamal\u0131 ? false. At\u2019\u0131n uzunlu\u011fu 2 hayvanlar . none? { | hayvan_ismi | hayvan_ismi . length == 2 } # => false # C ile ba\u015flayan hayvan ismi olmas\u0131n! true. Hi\u00e7bir isim C ile ba\u015flam\u0131yor hayvanlar . none? { | hayvan_ismi | hayvan_ismi . start_with? ( \"C\" ) } # => true inject , reduce * inject ve reduce ayn\u0131 i\u015fi yaparlar ve bir t\u00fcr ak\u00fcm\u00fclator i\u015flemi yapmaya yararlar. Blok i\u00e7inde 2 paramtre kullan\u0131l\u0131r. Ba\u015flama parametresi de alabilir. \u00d6rne\u011fin Array [1, 2, 3, 4, 5] ve t\u00fcm elemanlar\u0131 birbiriyle toplamak isitiyoruz. [ 1 , 2 , 3 , 4 , 5 ]. inject { | toplam , eleman | toplam + eleman } # => 15 # i\u015flem \u015fu \u015fekilde ilerliyor # toplam: 0, eleman: 1 # toplam: 1, eleman: 2 # toplam: 3, eleman: 3 # toplam: 6, eleman: 4 # toplam: 10, eleman: 5 # sona geldi\u011finde toplam 10, eleman 5 -> 10 + 5 = 15 E\u011fer ba\u015flang\u0131\u00e7 de\u011feri i\u00e7in parametre ge\u00e7seydik, \u00f6rne\u011fin 10 : [ 1 , 2 , 3 , 4 , 5 ]. inject ( 10 ){ | toplam , eleman | toplam + eleman } # => 25 # toplam: 10, eleman: 1 # toplam: 11, eleman: 2 # toplam: 13, eleman: 3 # toplam: 16, eleman: 4 # toplam: 20, eleman: 5 # sona geldi\u011finde toplam 20, eleman 5 -> 20 + 5 = 25 Ayn\u0131 i\u015fi reduce ile de yapabilirdik. [ 1 , 2 , 3 , 4 , 5 ]. reduce ( :+ ) # => 15 \u00d6rnekte her eleman\u0131n + methodu\u2019nu \u00e7a\u011f\u0131r\u0131yoruz ve sanki x = x + 1 mant\u0131\u011f\u0131nda, kendisini ekleye ekleye sonuca var\u0131yoruz. en_uzun_hayvan_ismi = [ \"kedi\" , \"k\u00f6pek\" , \"kamplumba\u011fa\" ]. inject do | buffer , hayvan | buffer . length > hayvan . length ? buffer : hayvan end en_uzun_hayvan_ismi # => \"kamplumba\u011fa\" partition ve group_by partition Array\u2019i 2 par\u00e7aya ay\u0131rmaya yarar. Sonu\u00e7, blok\u2019ta i\u015flenen ifadeye ba\u011fl\u0131 olarak [true_array, false_array] olarak d\u00f6ner. Yani ko\u015fula true cevap verenlerle false cevap verenler ayr\u0131 par\u00e7alar halinde d\u00f6ner :) [ 1 , 2 , 3 , 4 , 5 , 6 ]. partition { | n | n . even? } # => [[2, 4, 6], [1, 3, 5]] # \u00c7ift say\u0131lar, true_array yani ilk par\u00e7a: [2, 4, 6] # Tek say\u0131lar, false_array yani ikinci par\u00e7a: [1, 3, 5] # Sadece \u00e7ift say\u0131lar gelsin: [ 1 , 2 , 3 , 4 , 5 , 6 ]. partition { | n | n . even? } [ 0 ] # => [2, 4, 6] group_by gruplama yapmak i\u00e7in kullan\u0131l\u0131r. Sonu\u00e7 Hash d\u00f6ner, ilk de\u011fer ( key ) blok i\u00e7indeki ifadenin sonucu, ikinci de\u011fer ( value ) ise sonucu verenlerin olu\u015fturdu gruptur. 1\u2019den 6\u2019ya kadar say\u0131lar\u0131 3\u2019e b\u00f6l\u00fcnce ka\u00e7 kald\u0131\u011f\u0131n\u0131 gruplayarak bulal\u0131m: [ 1 , 2 , 3 , 4 , 5 , 6 ]. group_by { | n | n % 3 } # => {1=>[1, 4], 2=>[2, 5], 0=>[3, 6]} # 3\u2019e b\u00f6l\u00fcnce kalan\u0131; # 1 olanlar: [1, 4] # 2 olanlar: [2, 5] # 0 olanlar (tam b\u00f6l\u00fcnenler) : [3, 6] Notu 50\u2019den b\u00fcy\u00fck olanlar: notlar = [ 50 , 20 , 44 , 60 , 80 , 100 , 99 , 81 , 5 ] notlar . group_by { | notu | notu > 40 } [ true ] # => [50, 44, 60, 80, 100, 99, 81] chunk Array elemanlar\u0131 ko\u015fula g\u00f6re gruplar. [ 3 , 1 , 4 , 1 , 5 , 9 , 2 , 6 , 5 , 3 , 5 ]. chunk { | n | n . even? } . to_a # => [ # [false, [3, 1]], # [true, [4]], # [false, [1, 5, 9]], # [true, [2, 6]], # [false, [5, 3, 5]] # ] slice_before Array i\u00e7inde belli bir elemana ya da kurala g\u00f6re par\u00e7alara ay\u0131rmak i\u00e7in kullan\u0131l\u0131r. [ 1 , 2 , 3 , \u2019 a \u2019 , 4 , 5 , 6 , \u2019 a \u2019 , 7 , 8 , 9 , \u2019 a \u2019 , 1 , 3 , 5 ]. slice_before { | i | i == \u2019 a \u2019 } . to_a # => [[1, 2, 3], [\"a\", 4, 5, 6], [\"a\", 7, 8, 9], [\"a\", 1, 3, 5]] flat_map , collect_concat \u0130kisi de ayn\u0131 i\u015fi yapar. \u00d6nce map eder sonra flatten yapar. pos_neg = [ 1 , 2 , 3 , 4 , 5 , 6 ]. map { | n | [ n , - n ] } pos_neg # => [[1, -1], [2, -2], [3, -3], [4, -4], [5, -5], [6, -6]] pos_neg . flatten # => [1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6] # yerine: [ 1 , 2 , 3 , 4 , 5 , 6 ]. flat_map { | n | [ n , - n ] } # => [1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6] sort_by Ayn\u0131 sort gibi \u00e7al\u0131\u015f\u0131r, Blok kullan\u0131r. \u0130fadenin true olmas\u0131na g\u00f6re \u00e7al\u0131\u015f\u0131r: hayvanlar = [ \"kamplumba\u011fa\" , \"at\" , \"e\u015f\u015fek\" , \"kurba\u011fa\" , \"ay\u0131\" ] # isimleri uzunluklar\u0131na g\u00f6re k\u00fc\u00e7\u00fckten b\u00fcy\u00fc\u011fe do\u011fru s\u0131ralayal\u0131m hayvanlar . sort_by { | isim | isim . length } # => [\"at\", \"ay\u0131\", \"e\u015f\u015fek\", \"kurba\u011fa\", \"kamplumba\u011fa\"] # isimleri uzunluklar\u0131na g\u00f6re b\u00fcy\u00fckten k\u00fc\u00e7\u00fc\u011fe do\u011fru s\u0131ralayal\u0131m hayvanlar . sort_by { | isim | - isim . length } # => [\"at\", \"ay\u0131\", \"e\u015f\u015fek\", \"kurba\u011fa\", \"kamplumba\u011fa\"] bsearch Binary arama yapar, O(log n) form\u00fcl\u00fcn\u00fc uygular, buradaki n Array\u2019in boyudur. Find minimum gibidir, yani ko\u015fula ilk uyan\u0131 bul gibi... # 2\u2019den b\u00fcy\u00fck 3, 4 ve 5 olmas\u0131na ra\u011fmen tek sonu\u00e7 [ 1 , 2 , 3 , 4 , 5 ]. bsearch { | n | n > 2 } # => 3 [ 1 , 2 , 3 , 4 , 5 ]. bsearch { | n | n >= 4 } # => 4 Tehlikeli \u0130\u015flemler Ba\u015flarda da bahsetti\u011fimiz gibi method ismi ! ile bitiyorsa bu ilgili nesnede de\u011fi\u015fiklik yap\u0131yor oldu\u011fumuz anlam\u0131na gelir. Array\u2019lerde de bu t\u00fcr method\u2019lar var: [ :reverse! , :rotate! , :sort! , :sort_by! , :collect! , :map! , :select! , :reject! , :slice! , :uniq! , :compact! , :flatten! , :shuffle! ] Bu method\u2019lar orijinal Array\u2019i bozar. Yani; a = [ 1 , 2 , 3 , 4 , 5 ] a . reverse! # => [5, 4, 3, 2, 1] # a art\u0131k reverse edilmi\u015f halde! a # => [5, 4, 3, 2, 1]","title":"Array"},{"location":"bolum-04/04-array/#array","text":"Kompakt, s\u0131ral\u0131 objeler i\u00e7eren bir t\u00fcr\u00fc ta\u015f\u0131c\u0131y\u0131 nesnedir Array\u2019ler. Neredeyse i\u00e7inde her t\u00fcr Ruby objesini ta\u015f\u0131yabilir. ( String, Integer, Fixnum, Hash, Symbol hatta ba\u015fka Array\u2019ler vs... ) Arka arkaya s\u0131ralanm\u0131\u015f kutucuklar d\u00fc\u015f\u00fcn\u00fcn, her kutucu\u011fun bir index numaras\u0131 oldu\u011funu hayal edin. Bu indeksleme i\u015fi otomatik olarak oluyor. Diziye her eleman ekledi\u011finizde ( E\u011fer kendiniz indeks numaras\u0131 atamad\u0131ysan\u0131z ) yeni indeks bir artarak devam ediyor. Zero Indexed yani ilk eleman 0 .eleman oluyor. Ayn\u0131 String \u2019deki gibi negatif indeks de\u011ferleri ile tersten eri\u015fim sa\u011fl\u0131yorsunuz. Yani ilk eleman array[0] ve son eleman array[-1] gibi... Array olu\u015fturmak i\u00e7in; a = [] # Ya bu \u015fekilde a . class # => Array b = Array . new # => Ya da bu \u015fekilde b . class # => Array kullanabilirsiniz. Keza a = [1, 2, 3] dedi\u011finizde de Array\u2019i hem tan\u0131mlam\u0131\u015f hem de elemanlar\u0131n\u0131 belirlemi\u015f olursunuz. Array\u2019i initialize ederken yani ilk kez olu\u015ftururken b\u00fcy\u00fckl\u00fc\u011f\u00fcn\u00fc de verebilirsiniz. a = Array . new ( 5 ) # i\u00e7inde 5 eleman ta\u015f\u0131yacak Array olu\u015ftur a # => [nil, nil, nil, nil, nil] Hatta, default de\u011fer bile atars\u0131n\u0131z: aylar = Array . new ( 12 , \"ay\" ) # 12 eleman olsun ve hepsi \"ay\" olsun aylar # => [\"ay\", \"ay\", \"ay\", \"ay\", \"ay\", \"ay\", \"ay\", \"ay\", \"ay\", \"ay\", \"ay\", \"ay\"] Ruby\u2019de her nesnenin bir ID \u2019si ve HASH de\u011feri vard\u0131r. [ 1 , 2 , 3 ]. hash # => 3384159031637530117 [ 1 , 2 , 3 ]. __id__ # => 70147646473880 Block kabul etti\u011fi i\u00e7in; dizi = Array . new ( 10 ) { | eleman | eleman = eleman * 4 } dizi # => [0, 4, 8, 12, 16, 20, 24, 28, 32, 36] # ya da ayn\u0131 kodu dizi = Array . new ( 10 ) do | eleman | eleman = eleman * 4 end dizi # => [0, 4, 8, 12, 16, 20, 24, 28, 32, 36] \u015feklinde de kullanabilirsiniz. Neticede Array\u2019in initialize method\u2019una parametre ge\u00e7mi\u015f oluyoruz: aylar = Array . [] ( \"oca\" , \"\u015fub\" , \"mar\" , \"nis\" , \"may\" , \"haz\" , \"tem\" , \"a\u011fu\" , \"eyl\" , \"eki\" , \"kas\" , \"ara\" ) aylar # => [\"oca\", \"\u015fub\", \"mar\", \"nis\", \"may\", \"haz\", \"tem\", \"a\u011fu\", \"eyl\", \"eki\", \"kas\", \"ara\"] Yani: aylar = Array.[](param, param, param) gibi. Ba\u015fka nas\u0131l \u00fcretiriz? Say\u0131lardan olu\u015fan bir dizi laz\u0131m olsa; \u00d6rne\u011fin 1984 ile 2000 aras\u0131ndaki y\u0131llar laz\u0131m olsa; years = Array ( 1984 .. 2000 ) years # => [1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000] Bir Array i\u00e7inde farkl\u0131 t\u00fcrden elemanlar olabilir; a = [ \"Hello\" , :word , 2014 , 3 . 14 ] # i\u00e7inde String, Symbol, Fixnum ve Float var! a # => [\"Hello\", :word, 2014, 3.14] Array i\u00e7indeki elemanlar s\u0131ral\u0131 bir \u015fekilde dururlar. Bu s\u0131raya Index denir. 0 \u2019dan ba\u015flar. Yani ilk eleman demek Array\u2019in 0.eleman\u0131 demektir. \u0130ste\u011fimiz eleman\u0131 almak i\u00e7in ya Array[index] ya da Array.fetch(index) y\u00f6ntemlerini kullanabiliriz. a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a [ 0 ] # => \"U\u011fur\" a . fetch ( 0 ) # => \"U\u011fur\" a [ 4 ] # => nil a . fetch ( 4 , \"Hatal\u0131 Index\" ) # => \"Hatal\u0131 Index\" a = [ 1 , 2 , 3 , 4 ] # \u0130lk N eleman\u0131 al a . take ( 2 ) # => [1, 2] a . drop ( 2 ) # => [3, 4] # take\u2019in tersi... \u0130lk 2 haricini al \u00d6rnekte a[4] dedi\u011fimiz zaman, olmayan index\u2019li eleman\u0131 almaya \u00e7al\u0131\u015f\u0131yor ve eleman olmad\u0131\u011f\u0131 i\u00e7in nil geri al\u0131yoruz. fetch kullanarak hata kontrol\u00fc de yapm\u0131\u015f oluyoruz. nil yerine belirledi\u011fimiz hata mesaj\u0131n\u0131 d\u00f6nm\u00fc\u015f oluyoruz. values_at method\u2019u ile ilgili index ya da index\u2019lerdeki elemanlar\u0131 alabiliriz, keza at de benzer i\u015fe yarar. isimler = [ \"U\u011fur\" , \"\u00d6mer\" , \"Ye\u015fim\" , \"Ezel\" , \"Eren\" ] isimler . values_at ( 0 ) # => [\"U\u011fur\"] isimler . values_at ( 1 , 2 ) # => [\"\u00d6mer\", \"Ye\u015fim\"] [ \"a\" , \"b\" , \"c\" , \"d\" , \"e\" ]. at ( 1 ) # => \"b\" [ \"a\" , \"b\" , \"c\" , \"d\" , \"e\" ]. at ( - 1 ) # => \"e\" rindex ile sa\u011fdan hizal\u0131 index\u2019e g\u00f6re elemana ula\u015f\u0131yoruz: a = [ \"a\" , \"b\" , \"b\" , \"b\" , \"c\" ] a . rindex ( \"b\" ) # => 3 # 3 tane b var, en sa\u011fdaki son b\u2019yi verdi! a . rindex ( \"z\" ) # => nil Keza \"acaba Array\u2019in ne gibi method\u2019lar\u0131 var?\" dersek; hemen methods \u00f6zelli\u011fi ile bakabiliriz. Kar\u0131\u015ft\u0131rmamam\u0131z gereken \u00f6nemli bir konu var. Detay\u0131n\u0131 Class konusunda g\u00f6rece\u011fiz ama yeri gelmi\u015fken, Array\u2019in Class Method \u2019lar\u0131 ve Instance Method \u2019lar\u0131 var. Array.methods dedi\u011fimizde Kernel\u2019dan gelen Array objesinin yani Class \u2019\u0131n\u0131n method\u2019lar\u0131n\u0131 g\u00f6r\u00fcr\u00fcz. E\u011fer Array.new.methods dersek, Array\u2019den t\u00fcretti\u011fimiz instance \u2019a ait method\u2019lar\u0131 g\u00f6r\u00fcr\u00fcz. Yani a = [] dedi\u011fimizde, asl\u0131nda Array \u2019den bir instance \u00e7\u0131kartm\u0131\u015f oluyoruz. Az \u00f6nce Array.[](...) olarak yapt\u0131\u011f\u0131m\u0131z \u015fey de asl\u0131nda Class method\u2019u \u00e7a\u011f\u0131rmak.","title":"Array"},{"location":"bolum-04/04-array/#class-methodlar","text":"Array . methods # => [:[], :try_convert, :allocate, :new, :superclass, :freeze, :===, :==, :<=>, :<, :<=, :>, :>=, :to_s, :inspect, :included_modules, :include?, :name, :ancestors, :instance_methods, :public_instance_methods, :protected_instance_methods, :private_instance_methods, :constants, :const_get, :const_set, :const_defined?, :const_missing, :class_variables, :remove_class_variable, :class_variable_get, :class_variable_set, :class_variable_defined?, :public_constant, :private_constant, :singleton_class?, :include, :prepend, :module_exec, :class_exec, :module_eval, :class_eval, :method_defined?, :public_method_defined?, :private_method_defined?, :protected_method_defined?, :public_class_method, :private_class_method, :autoload, :autoload?, :instance_method, :public_instance_method, :nil?, :=~, :!~, :eql?, :hash, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :singleton_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__] Bu method\u2019lar\u0131n bir k\u0131sm\u0131 Enumerable s\u0131n\u0131f\u0131ndan gelen method\u2019lard\u0131r. Ruby, Module yap\u0131s\u0131 kulland\u0131\u011f\u0131 i\u00e7in ortak kullan\u0131lan method\u2019lar mod\u00fcl eklemelerinden gelmektedir. Class konusunda detaylar\u0131 g\u00f6rece\u011fiz. Bu k\u0131s\u0131mdan en fazla kullanaca\u011f\u0131m\u0131z [] ve new method\u2019lar\u0131 olacakt\u0131r.","title":"Class Method\u2019lar\u0131"},{"location":"bolum-04/04-array/#instance-methodlar","text":"En \u00e7ok kullanaca\u011f\u0131m\u0131z method\u2019larsa; Array . new . methods # => [:inspect, :to_s, :to_a, :to_h, :to_ary, :frozen?, :==, :eql?, :hash, :[], :[]=, :at, :fetch, :first, :last, :concat, :<<, :push, :pop, :shift, :unshift, :insert, :each, :each_index, :reverse_each, :length, :size, :empty?, :find_index, :index, :rindex, :join, :reverse, :reverse!, :rotate, :rotate!, :sort, :sort!, :sort_by!, :collect, :collect!, :map, :map!, :select, :select!, :keep_if, :values_at, :delete, :delete_at, :delete_if, :reject, :reject!, :zip, :transpose, :replace, :clear, :fill, :include?, :<=>, :slice, :slice!, :assoc, :rassoc, :+, :*, :-, :&, :|, :uniq, :uniq!, :compact, :compact!, :flatten, :flatten!, :count, :shuffle!, :shuffle, :sample, :cycle, :permutation, :combination, :repeated_permutation, :repeated_combination, :product, :take, :take_while, :drop, :drop_while, :bsearch, :pack, :entries, :sort_by, :grep, :find, :detect, :find_all, :flat_map, :collect_concat, :inject, :reduce, :partition, :group_by, :all?, :any?, :one?, :none?, :min, :max, :minmax, :min_by, :max_by, :minmax_by, :member?, :each_with_index, :each_entry, :each_slice, :each_cons, :each_with_object, :chunk, :slice_before, :lazy, :nil?, :===, :=~, :!~, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :singleton_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__] Ayn\u0131 String \u2019deki gibi, \u015fu Array\u2019in bir r\u00f6ntgenini \u00e7ekelim: Array . class # => Class Array . class . superclass # => Module Array . class . superclass . superclass # => Object Array . class . superclass . superclass . superclass # => BasicObject Array . class . superclass . superclass . superclass . superclass # => nil Array\u2019in bir \u00fcst objesi ne? Module Yine Class konusunda g\u00f6rece\u011fiz diyece\u011fim ve siz bana k\u0131zacaks\u0131n\u0131z :) Ruby\u2019de bir Class en fazla ba\u015fka bir Class\u2019dan t\u00fcreyebilir. \u00d6rne\u011fin Python\u2019da bir Class N TANE Class\u2019tan inherit olabilir ( Miras alabilir, t\u00fcreyebilir ) Ruby, bu sorunu Module yap\u0131s\u0131yla \u00e7\u00f6z\u00fcyor. Bu mant\u0131kla asl\u0131nda ortakla\u015fa kullan\u0131lan Kernel mod\u00fclleri yard\u0131m\u0131yla, ortak kullan\u0131lacak method\u2019lar bu mod\u00fcllerin Include edilmesiyle ilgili yerlere da\u011f\u0131t\u0131l\u0131yor. Acaba Array\u2019de hangi mod\u00fcller var? Array . included_modules # => [Enumerable, Kernel] Bu bak\u0131mdan Array, Hash gibi nesnelerde benzer ortak method\u2019lar g\u00f6rmek m\u00fcmk\u00fcn. length veya count Array\u2019in boyu / i\u00e7inde ka\u00e7 eleman oldu\u011fu ile ilgili bilgiyi almak i\u00e7in kullan\u0131l\u0131r. [ 1 , 2 , 3 , 4 ]. length # => 4 [ 1 , 2 , 3 , 4 ]. count # => 4 empty? Array acaba bo\u015fmu? \u0130\u00e7inde hi\u00e7 eleman var m\u0131? [ 1 , 2 , 3 , 4 ]. empty? # => false []. empty? # => true eql? , == , === E\u015fitlik kontrol\u00fc i\u00e7indir. E\u011fer kar\u015f\u0131l\u0131\u011f\u0131 ayn\u0131 cinsse ve birebir ayn\u0131 elemanlara sahipse true d\u00f6ner. a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . eql? ( [ \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" , \"U\u011fur\" ] ) # => false a . eql? ( [] ) # => false a . eql? ( [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] ) # => true == Generic Equality yani genel e\u015fitlik kontrol\u00fc yani hepimizin bildi\u011fi kontrol, === ise Case Equality yani a === b ifadesinde a , b \u2019nin subseti mi? demek olur. \u00d6rnek verelim: 5 . class . superclass # => Integer Integer === 5 # => true # 5, Integer subsetinde... Integer . class # => Class Integer . class . superclass # => Module Integer . class . superclass . superclass # => Object Integer . class . superclass . superclass . superclass # => BasicObject Integer . class . superclass . superclass . superclass . superclass # => nil # Integer, 5\u2019in subsetinde de\u011fil. 5 === Integer # => false include? ve member? Acaba verdi\u011fim eleman Array\u2019in i\u00e7inde mi? Verdi\u011fim eleman bu dizinin \u00fcyesi mi? [ 1 , 2 , 3 , 4 ]. include? ( 3 ) # => true [ 1 , 2 , 3 , 4 ]. member? ( 1 ) # => true [ 1 , 2 , 3 , 4 ]. member? ( 5 ) # => false [ \"U\u011fur\" , \"Ezel\" , \"Ye\u015fim\" ]. include? ( \"U\u011fur\" ) # => true [ \"U\u011fur\" , \"Ezel\" , \"Ye\u015fim\" ]. include? ( \"\u00d6mer\" ) # => false array & ba\u015fka_bir_array \u0130ki dizide de kullan\u0131n ortak elemanlar\u0131 al\u0131r yeni Array d\u00f6ner: a = [ 1 , 2 , 3 , 4 ] b = [ 3 , 1 , 10 , 22 ] a & b # => [1, 3] array * int [ya da] array * str a = [ \"a\" , \"b\" , \"c\" ] a * 5 # => [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\"] a * \"-vigo-\" # => \"a-vigo-b-vigo-c\" **\\*** \u00e7aparak 3 elemanl\u0131 a Array\u2019inden sanki birle\u015ftirilmi\u015f 15 elemanl\u0131 yeni bir Array olu\u015fturduk. String ile \u00e7arp\u0131nca da asl\u0131nda join methodu ile Array\u2019den String yapt\u0131k ve birle\u015ftirici olarak -vigo- metni kulland\u0131k! array + ba\u015fka_array \u0130ki Array\u2019i toplar ve yeni Array d\u00f6ner: a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" ] b = [ \"\u00d6mer\" ] a + b # => [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\"] array - ba\u015fka_array Array\u2019ler aras\u0131ndaki fark\u0131 Array olarak bulmak: a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" ] b = [ \"U\u011fur\" , \"Ye\u015fim\" ] a - b # => [\"Ezel\"] # a\u2019da olab b elemanlar\u0131 kayboldu array | ba\u015fka_array \u0130ki Array\u2019i unique ( tekil ) elemanlar olarak birle\u015ftirdi. Ayn\u0131 eleman varsa bunlardan birini ald\u0131: a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" ] b = [ \"U\u011fur\" , \"\u00d6mer\" ] a | b # => [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\"] array << nesne ya da push Array\u2019in sonuna eleman eklemek i\u00e7in kullan\u0131l\u0131r. a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" ] a << \"\u00d6mer\" # => [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\"] a . push ( \"Eren\" ) # => [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\", \"Eren\"] Keza zincirleme \u00e7a\u011fr\u0131 da yapabilirsiniz: a . push ( \"Tun\u00e7\" ) . push ( \"Suat\" ) # => [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\", \"Eren\", \"Tun\u00e7\", \"Suat\"] concat Array sonuna Array eklemek i\u00e7in kullan\u0131l\u0131r. a = [ 1 , 2 , 3 ] a . concat ( [ 4 , 5 , 6 ] ) a # => [1, 2, 3, 4, 5, 6] join Array elemanlar\u0131n\u0131 birle\u015ftirip String \u2019e \u00e7evirmeye yarar. E\u011fer parametre verirsek aradaki birle\u015ftiriciyi de belirlemi\u015f oluruz. [ \"Commodore 64\" , \"Amiga\" , \"Sinclair\" , \"Amstrad\" ]. join # => \"Commodore 64AmigaSinclairAmstrad\" [ \"Commodore 64\" , \"Amiga\" , \"Sinclair\" , \"Amstrad\" ]. join ( \" , \" ) # => \"Commodore 64 , Amiga , Sinclair , Amstrad\" unshift Array\u2019in ba\u015f\u0131na eleman eklemek i\u00e7in kullan\u0131l\u0131r. a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" ] a . unshift ( \"\u00d6mer\" ) # => [\"\u00d6mer\", \"U\u011fur\", \"Ye\u015fim\", \"Ezel\"] insert Array\u2019de istedi\u011finiz bir noktaya eleman eklemek i\u00e7in kullan\u0131l\u0131r. \u0130lk parametre index di\u011fer parametre/ler de eklenecek eleman/lar. a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" ] a . insert ( 1 , \"\u00d6mer\" ) # => [\"U\u011fur\", \"\u00d6mer\", \"Ye\u015fim\", \"Ezel\"] a . insert ( 1 , \"Ahmet\" , \"Ece\" , \"Eren\" ) # => [\"U\u011fur\", \"Ahmet\", \"Ece\", \"Eren\", \"\u00d6mer\", \"Ye\u015fim\", \"Ezel\"] replace Array\u2019in i\u00e7ini, di\u011fer Array\u2019le de\u011fi\u015ftirir. Asl\u0131nda Array\u2019i ba\u015fka bir Array\u2019e e\u015fitlemek gibidir. Eleman say\u0131s\u0131n\u0131n e\u015fit olup olmamas\u0131 hi\u00e7 \u00f6nemli de\u011fildir. a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . replace ( [ \"Foo\" , \"Bar\" ] ) # => [\"Foo\", \"Bar\"] a # => [\"Foo\", \"Bar\"] array <=> ba\u015fka_array Spaceship operat\u00f6r\u00fcnden bahsetmi\u015ftik. Array\u2019ler aras\u0131nda kar\u015f\u0131la\u015ft\u0131rma yapmay\u0131 sa\u011flar. [ 1 , 2 , 3 , 4 ] <=> [ 1 , 2 , 3 , 4 ] # => 0 # E\u015fit [ 1 , 2 , 3 , 4 ] <=> [ 1 , 2 , 3 ] # => 1 # \u0130lk de\u011fer b\u00fcy\u00fck [ 1 , 2 , 3 ] <=> [ 1 , 2 , 3 , 4 ] # => -1 # \u0130lk de\u011fer k\u00fc\u00e7\u00fck pop , shift , delete , delete_at , delete_if Son eleman\u0131 \u00e7\u0131kartmak i\u00e7in pop ilk eleman\u0131 \u00e7\u0131kartmak i\u00e7in shift kullan\u0131l\u0131r. Herhangi bir eleman\u0131 \u00e7\u0131kartmak i\u00e7in delete , belirli bir index\u2019deki eleman\u0131 \u00e7\u0131kartmak i\u00e7in delete_at kullan\u0131l\u0131r. a = [ \"U\u011fur\" , \"\u00d6mer\" , \"Ye\u015fim\" , \"Ezel\" , \"Eren\" ] a . pop # => \"Eren\" a # => [\"U\u011fur\", \"\u00d6mer\", \"Ye\u015fim\", \"Ezel\"] a . shift # => \"U\u011fur\" a # => [\"\u00d6mer\", \"Ye\u015fim\", \"Ezel\"] a . delete ( \"\u00d6mer\" ) # => \"\u00d6mer\" a # => [\"Ye\u015fim\", \"Ezel\"] a . delete_at ( 1 ) # => \"Ezel\" a # => [\"Ye\u015fim\"] # not 50\u2019den k\u00fc\u00e7\u00fckse sil :) notlar = [ 40 , 45 , 53 , 70 , 99 , 65 ] notlar . delete_if { | notu | notu < 50 } # => [53, 70, 99, 65] pop \u2019a parametre ge\u00e7ersek son n taneyi u\u00e7urmu\u015f oluruz: a = [ \"U\u011fur\" , \"\u00d6mer\" , \"Ye\u015fim\" , \"Ezel\" , \"Eren\" ] a . pop ( 2 ) # => [\"Ezel\", \"Eren\"] a # => [\"U\u011fur\", \"\u00d6mer\", \"Ye\u015fim\"] compact ve uniq nil elemanlar\u0131 u\u00e7urmak i\u00e7in compact , duplike elemanlar\u0131 tekil hale getirmek i\u00e7in uniq kullan\u0131l\u0131r. [ \"a\" , 1 , nil , 2 , nil , \"b\" , 1 , \"a\" ]. compact # => [\"a\", 1, 2, \"b\", 1, \"a\"] [ \"a\" , 1 , nil , 2 , nil , \"b\" , 1 , \"a\" ]. uniq # => [\"a\", 1, nil, 2, \"b\"] [ \"a\" , 1 , nil , 2 , nil , \"b\" , 1 , \"a\" ]. compact . uniq # => [\"a\", 1, 2, \"b\"] array == ba\u015fka_array \u0130ki Array nitelik ve nicelik olarak birbirine e\u015fit mi? [ 1 , 2 , 3 , 4 ] == [ 1 , 2 , 3 , 4 ] # => true [ 1 , 2 , 3 , 4 ] == [ \"1\" , 2 , 3 , 4 ] # => false [ 1 , 2 , 3 , 4 ] == [ 1 , 2 , 3 ] # => false assoc ve rassoc Elemanlar\u0131 Array olan bir Array i\u00e7inde, ilk de\u011fere g\u00f6re yakalama yapmaya yarar. a = [ \"renkler\" , \"k\u0131rm\u0131z\u0131\" , \"sar\u0131\" , \"mavi\" ] b = [ \"harfler\" , \"a\" , \"b\" , \"c\" ] c = \"foo\" t = [ a , b , c ] t # => [[\"renkler\", \"k\u0131rm\u0131z\u0131\", \"sar\u0131\", \"mavi\"], [\"harfler\", \"a\", \"b\", \"c\"], \"foo\"] t . assoc ( \"renkler\" ) # => [\"renkler\", \"k\u0131rm\u0131z\u0131\", \"sar\u0131\", \"mavi\"] t . assoc ( \"foo\" ) # => nil t . rassoc ( \"k\u0131rm\u0131z\u0131\" ) # => [\"renkler\", \"k\u0131rm\u0131z\u0131\", \"sar\u0131\", \"mavi\"] rassoc ise ikinci eleman\u0131na bakar, yani \"renkler\" yerine \"k\u0131r\u0131m\u0131z\u0131\" kullanabiliriz: slice(ba\u015flang\u0131\u00e7, boy) ya da slice(aral\u0131k) Array i\u00e7inden kesip ba\u015fka bir Array olu\u015fturmak i\u00e7in kullan\u0131l\u0131r. ba\u015flangi\u00e7 indeks\u2019indeki eleman dahil olmak \u00fczere, boy ya da aral\u0131k kadar\u0131n\u0131 kes. [ 1 , 2 , 3 , 4 ]. slice ( 0 , 2 ) # => [1, 2] # 0.dan itibaren 2 tane [ 1 , 2 , 3 , 4 ]. slice ( 2 .. 4 ) # => [3, 4] # 2.den itibaren 2 tane first ve last Ad\u0131ndan da anla\u015f\u0131laca\u011f\u0131 gibi, Array\u2019in ilk ve son elemanlar\u0131 i\u00e7in kullan\u0131l\u0131r: a = [ 1 , 2 , 3 , 4 , 5 ] a . first # => 1 a . last # => 5 E\u011fer parametre ge\u00e7ersek, ilk n ya da son n elemanlar\u0131 alabiliriz: a = [ 1 , 2 , 3 , 4 , 5 ] a . first ( 2 ) # => [1, 2] a . last ( 2 ) # => [4, 5] find ( detect ), find_all , index , find_index find ile blok i\u00e7inde ko\u015fula uyan ilk Array eleman\u0131n\u0131, find_all ile t\u00fcm\u00fcn\u00fc al\u0131r\u0131z: [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ]. find { | n | n . length > 3 } # => \"U\u011fur\" [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ]. find_all { | n | n . length > 3 } # => [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\"] detect ile find ayn\u0131 i\u015fi yapar. index , find_index ile eleman\u0131n index\u2019ini buluruz: [ \"a\" , \"b\" , \"c\" , \"d\" , \"e\" ]. index ( \"e\" ) # => 4 [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ]. index ( \"Ezel\" ) # => 2 [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ]. find_index ( \"Ezel\" ) # => 2 clear Array\u2019i temizlemek i\u00e7in kullan\u0131l\u0131r :) a = [ 1 , 2 , 3 ] a . clear # => [] a # => [] reverse Array\u2019i terse \u00e7evir. a = [ 1 , 2 , 3 , 4 , 5 ] a . reverse # => [5, 4, 3, 2, 1] sample Array\u2019den random olarak eleman almaya yarar. E\u011fer parametre ge\u00e7ilirse ge\u00e7ilen adet kadar random eleman d\u00f6ner. a = [ 1 , 2 , 3 , 4 , 5 ] a . sample # => 3 a . sample ( 3 ) # => [5, 1, 3] shuffle Array\u2019in i\u00e7indeki elemanlar\u0131n index\u2019lerini kar\u0131\u015ft\u0131r\u0131r :) a = [ 1 , 2 , 3 , 4 , 5 ] a . shuffle # => [5, 4, 1, 3, 2] a . shuffle # => [1, 2, 3, 5, 4] sort Array i\u00e7indeki elemanlar\u0131 <=> mant\u0131\u011f\u0131yla s\u0131ralar. a = [ 1 , 4 , 2 , 3 , 11 , 5 ] a . sort # => [1, 2, 3, 4, 5, 11] b = [ \"a\" , \"c\" , \"b\" , \"z\" , \"d\" ] b . sort # => [\"a\", \"b\", \"c\", \"d\", \"z\"] fill Array\u2019in i\u00e7ini ilgili de\u011ferle doldurmak i\u00e7in kullan\u0131l\u0131r. \u0130\u015flem sonucunda orijinal Array\u2019in de\u011feri de\u011fi\u015fir. Yani ne ile fill ettiyseniz Array art\u0131k o de\u011ferlerdedir. a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . fill ( \"x\" ) # => [\"x\", \"x\", \"x\", \"x\"] # t\u00fcm elemanlar\u0131 x yapt\u0131 a # => [\"x\", \"x\", \"x\", \"x\"] # art\u0131k a\u2019n\u0131n yeni de\u011feri bu a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . fill ( \"y\" , 2 ) # => [\"U\u011fur\", \"Ye\u015fim\", \"y\", \"y\"] # 2.den itibaren y ile doldur a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] # 2.den itibaren 1 tane doldur a . fill ( \"z\" , 2 , 1 ) # => [\"U\u011fur\", \"Ye\u015fim\", \"z\", \"\u00d6mer\"] Keza; a = [ 1 , 2 , 3 , 4 , 5 ] a . fill { | i | i * 5 } # => [0, 5, 10, 15, 20] a # => [0, 5, 10, 15, 20] \u015feklinde de kullan\u0131l\u0131r. flatten Array i\u00e7inde Array elemanlar\u0131 varsa, tek harekette bunlar\u0131 d\u00fcz tek bir Array haline getirebiliriz. [ 1 , 2 , [ \"a\" , \"b\" , :c ] , [ 66 , [ 5 . 5 , 3 . 1 ]]]. flatten # => [1, 2, \"a\", \"b\", :c, 66, 5.5, 3.1] rotate Array elemanlar\u0131 kendi i\u00e7inde kayd\u0131r\u0131r. a = [ 1 , 2 , 3 , 4 , 5 ] a . rotate # => [2, 3, 4, 5, 1] # 1 kayd\u0131rd\u0131 a . rotate ( 2 ) # => [3, 4, 5, 1, 2] # 2 kayd\u0131rd\u0131, ilk 2 eleman\u0131 sona koydu! Varsay\u0131lan de\u011fer 1 \u2019dir. zip a = [ 4 , 5 , 6 ] b = [ 7 , 8 , 9 ] [ 1 , 2 , 3 ]. zip ( a , b ) # => [[1, 4, 7], [2, 5, 8], [3, 6, 9]] [ 1 , 2 ]. zip ( a , b ) # => [[1, 4, 7], [2, 5, 8]] a . zip ( [ 1 , 2 ] , [ 8 ] ) # => [[4, 1, 8], [5, 2, nil], [6, nil, nil]] [1, 2, 3].zip(a, b) i\u015flemini yaparken, \u00f6nce 0.eleman\u0131 yani 1 \u2019i ald\u0131, sonra a \u2019nun 0.eleman\u0131n\u0131 ald\u0131, sonra da b \u2019nin 0.eleman\u0131n\u0131 ald\u0131 ve paketledi : [1, 4, 7] ayn\u0131 i\u015fi 1. ve 2. elemanlar i\u00e7in yapt\u0131. [1, 2].zip(a, b) yaparken, Array boylar\u0131 e\u015fit olmad\u0131\u011f\u0131 i\u00e7in [1, 2] sadece 2 elemanl\u0131 oldu\u011fu i\u00e7in bu i\u015flemi 0. ve 1. elemanlar i\u00e7in yapt\u0131. Son \u00f6rnekte index\u2019e kar\u015f\u0131l\u0131k gelmedi\u011fi i\u00e7in elemanlar nil geldi! transpose Array i\u00e7indeki Array\u2019leri sat\u0131r gibi d\u00fc\u015f\u00fcn\u00fcp bunlar\u0131 s\u00fctuna \u00e7eviriyor gibi alg\u0131layabilirsiniz. a = [[ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ]] a . transpose # => [[1, 3, 5], [2, 4, 6]] # [ # [1, 2], # [3, 4], # [5, 6] # ] # -> [1, 3, 5], [2, 4, 5] #","title":"Instance Method\u2019lar\u0131"},{"location":"bolum-04/04-array/#tip-ceviricileri","text":"to_a ve to_ary kendisini d\u00f6ner, as\u0131l g\u00f6revi e\u011fer alt s\u0131n\u0131ftan \u00e7a\u011fr\u0131lm\u0131\u015fsa, yani Array\u2019den t\u00fcreyen ba\u015fka bir Class\u2019da kullan\u0131ld\u0131\u011f\u0131nda direk Array\u2019e d\u00f6n\u00fc\u015ft\u00fcr\u00fcr. [ \"a\" , 1 , \"b\" , 2 ]. to_a # => [\"a\", 1, \"b\", 2] [ \"a\" , 1 , \"b\" , 2 ]. to_ary # => [\"a\", 1, \"b\", 2] [[ \"a\" , 1 ] , [ \"b\" , 2 ]]. to_h # => {\"a\"=>1, \"b\"=>2} [ \"a\" , 1 , \"b\" , 2 ]. to_s # => \"[\\\"a\\\", 1, \\\"b\\\", 2]\" [ \"a\" , 1 , \"b\" , 2 ]. inspect # => \"[\\\"a\\\", 1, \\\"b\\\", 2]\" entries de aynen to_a gibi \u00e7al\u0131\u015f\u0131r: ( 1 .. 3 ) # => 1..3 ( 1 .. 3 ) . entries # => [1, 2, 3] ( 1 .. 3 ) . to_a # => [1, 2, 3] grep Asl\u0131nda bu konular\u0131 Regular Expressions \u2019da g\u00f6rece\u011fiz ama yeri gelmi\u015fken h\u0131zla de\u011finelim. Array i\u00e7inde elemanlar\u0131 Regex ko\u015fullar\u0131na g\u00f6re filtreleyebiliyoruz: ( 1 .. 10 ) . to_a # => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 2\u2019den 5\u2019e kadar (5 dahil) ( 1 .. 10 ) . grep 2 .. 5 # => [2, 3, 4, 5] # sadece .com olan elemanlar\u0131 al [ \"a\" , \"http://example.com\" , \"b\" , \"foo\" , \"http://webbox.io\" ]. grep ( /^http.+\\.com/ ) # => [\"http://example.com\"] pack Array\u2019in i\u00e7eri\u011fini verilen direktife g\u00f6re Binary String haline getirir. Uzunca bir direktif listesi var. # A: String olarak i\u015fle, space karakteri kullan # 5: Uzunlu\u011fu 5 karakter olsun [ \"a\" , \"b\" , \"c\" ]. pack ( \"A5A5A5\" ) # => \"a b c \" # Uzunlu\u011fu 5\u2019ten b\u00fcy\u00fck olan kesintiye u\u011frad\u0131 [ \"ali\" , \"burak\" , \"cengiz\" ]. pack ( \"A5A5A5\" ) # => \"ali burakcengi\" # a: String olarak i\u015fle, null yani \\x00 karakteri kullan [ \"a\" , \"b\" , \"c\" ]. pack ( \"a3a3a3\" ) # => \"a\\x00\\x00b\\x00\\x00c\\x00\\x00\"","title":"Tip \u00c7eviricileri"},{"location":"bolum-04/04-array/#iterasyon-ve-block-kullanm","text":"collect / map { |eleman| blok } \u2192 yeni_array Blok i\u00e7inde gelen kodu her elemana uygular, yeni Array d\u00f6ner: a = [ 1 , 2 , 3 , 4 , 5 ] a . collect { | i | i * 2 } # => [2, 4, 6, 8, 10] a . collect { | i | \"say\u0131 #{ i } \" } # => [\"say\u0131 1\", \"say\u0131 2\", \"say\u0131 3\", \"say\u0131 4\", \"say\u0131 5\"] map de ayn\u0131 i\u015fi yapar: [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ]. map { | isim | \"\u0130sim: #{ isim } \" } # => [\"\u0130sim: U\u011fur\", \"\u0130sim: Ye\u015fim\", \"\u0130sim: Ezel\", \"\u0130sim: \u00d6mer\"] [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ]. collect { | isim | \"\u0130sim: #{ isim } \" } # => [\"\u0130sim: U\u011fur\", \"\u0130sim: Ye\u015fim\", \"\u0130sim: Ezel\", \"\u0130sim: \u00d6mer\"] select Blok i\u00e7inden gelen ifadenin true / false olmas\u0131na g\u00f6re filtre yapar ve yeni Array d\u00f6ner: [ 1 , 2 , 3 , 10 , 15 , 20 ]. select { | n | n % 2 == 0 } # => [2, 10, 20] # 2\u2019ye tam b\u00f6l\u00fcnenler [ 1 , 2 , \"3\" , \"ali\" , 15 , 20 ]. select { | n | n . is_a? ( Fixnum ) } # => [1, 2, 15, 20] # sadece say\u0131lar reject select in tersidir. [ 1 , 2 , 3 , 10 , 15 , 20 ]. reject { | n | n % 2 == 0 } # => [1, 3, 15] # 2\u2019ye tam b\u00f6l\u00fclenleri at [ 1 , 2 , \"3\" , \"ali\" , 15 , 20 ]. reject { | n | n . is_a? ( Fixnum ) } # => [\"3\", \"ali\"] # Say\u0131 olanlar\u0131 at keep_if Blok i\u00e7indeki ifade\u2019den sadece false d\u00f6nenleri atar ve Array\u2019in orjinal de\u011ferini bozar, de\u011fi\u015ftirir. a = [ 1 , 2 , 3 , 10 , 15 , 20 ] a . keep_if { | n | n % 2 == 0 } # => [2, 10, 20] # 2\u2019ye b\u00f6l\u00fcnemeyenler false geldi\u011fi i\u00e7in d\u00fc\u015ft\u00fcler. a # => [2, 10, 20] # a art\u0131k bu! combination(n) { |c| blok } \u2192 array Matematikteki kombinasyon i\u015flemidir. 1, 2 ve 3 say\u0131lar\u0131n\u0131n 2\u2019li kombinasyonu: a = [ 1 , 2 , 3 ] a . combination ( 1 ) . to_a # => [[1], [2], [3]] a . combination ( 2 ) . to_a # => [[1, 2], [1, 3], [2, 3]] a . combination ( 2 ) { | c | puts \"Olas\u0131klar: #{ c . join ( \" ve \" ) } \" } # Olas\u0131klar: 1 ve 2 # Olas\u0131klar: 1 ve 3 # Olas\u0131klar: 2 ve 3 permutation Ayn\u0131 kombinasyon gibi, matematikteki perm\u00fctasyon i\u015flemidir. [ 1 , 2 , 3 ]. permutation . to_a # => [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] E\u011fer parametre ge\u00e7ersek ka\u00e7l\u0131 perm\u00fctasyon oldu\u011funu belirtiriz: [ 1 , 2 , 3 ]. permutation ( 1 ) . to_a # => [[1], [2], [3]] [ 1 , 2 , 3 ]. permutation ( 2 ) . to_a # => [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] repeated_combination , repeated_permutation combination ile repeated_combination aras\u0131ndaki fark\u0131 \u00f6rnekle g\u00f6relim: [ 1 , 2 , 3 ]. combination ( 1 ) . to_a # => [[1], [2], [3]] [ 1 , 2 , 3 ]. repeated_combination ( 1 ) . to_a # => [[1], [2], [3]] [ 1 , 2 , 3 ]. combination ( 2 ) . to_a # => [[1, 2], [1, 3], [2, 3]] [ 1 , 2 , 3 ]. repeated_combination ( 2 ) . to_a # => [[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3]] combination olas\u0131 tekil sonucu, repeated_combination pas edilen say\u0131ya g\u00f6re tekrar da edebilen sonucu d\u00f6ner. Ayn\u0131s\u0131 repeated_permutation i\u00e7in de ge\u00e7erlidir: [ 1 , 2 , 3 ]. permutation ( 1 ) . to_a # => [[1], [2], [3]] [ 1 , 2 , 3 ]. repeated_permutation ( 1 ) . to_a # => [[1], [2], [3]] [ 1 , 2 , 3 ]. permutation ( 2 ) . to_a # => [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] [ 1 , 2 , 3 ]. repeated_permutation ( 2 ) . to_a # => [[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]] product Array ve arg\u00fcman olarak ge\u00e7ilecek di\u011fer Array/lerin elemanlar\u0131yla olu\u015fabilecek t\u00fcm alternatifleri \u00fcretmenizi sa\u011flar. [ 1 , 2 , 3 ]. product # => [[1], [2], [3]] [ 1 , 2 , 3 ]. product ( [ 4 , 5 ] ) # => [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]] [ 1 , 2 , 3 ]. product ( [ 7 , 8 , 9 ] ) # => [[1, 7], [1, 8], [1, 9], [2, 7], [2, 8], [2, 9], [3, 7], [3, 8], [3, 9]] [ 1 , 2 , 3 ]. product ( [ \"a\" , \"b\" ] , [ \"x\" , \"y\" ] ) # => [[1, \"a\", \"x\"], [1, \"a\", \"y\"], [1, \"b\", \"x\"], [1, \"b\", \"y\"], [2, \"a\", \"x\"], [2, \"a\", \"y\"], [2, \"b\", \"x\"], [2, \"b\", \"y\"], [3, \"a\", \"x\"], [3, \"a\", \"y\"], [3, \"b\", \"x\"], [3, \"b\", \"y\"]] count Az \u00f6nce method olarak i\u015fledi\u011fimiz count ile ba\u015fka ilgin\u00e7 i\u015fler de yapabiliyoruz: a = [ 1 , 2 , 3 , 4 , 2 ] a . count # => 5 # eleman say\u0131s\u0131 a . count ( 2 ) # => 2 # ka\u00e7 tane 2 var? a . count { | n | n % 2 == 0 } # => 3 # ka\u00e7 tane 2\u2019ye tam b\u00f6l\u00fcnen var? cycle(n=nil) { |obje| blok } \u2192 nil Pas edilen blok\u2019u n defa tekrar eder. a = [ 1 , 2 , 3 ] a . cycle ( 2 ) . to_a # => [1, 2, 3, 1, 2, 3] # 2 defa a . cycle ( 4 ) . to_a # => [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3] # 3defa a . cycle ( 2 ) { | o | puts \"Say\u0131 #{ o } \" } # Say\u0131 1 # Say\u0131 2 # Say\u0131 3 # Say\u0131 1 # Say\u0131 2 # Say\u0131 3 E\u011fer [1, 2, 3].cycle { |i| puts i } gibi bir i\u015flem yaparsan\u0131z, default olarak nil ge\u00e7mi\u015f olursun ve bu sonsuz d\u00f6ng\u00fcle girer, sonsuza kadar 1, 2, 3, 1, 2, 3 .... \u015feklinde devam eder! drop_while { |array| blok } \u2192 yeni array delete_if ile ayn\u0131 i\u015fi yapar. notlar = [ 40 , 45 , 53 , 70 , 99 , 65 ] notlar . drop_while { | notu | notu < 50 } # => [53, 70, 99, 65] Ko\u015fula g\u00f6re Array\u2019den atar gibi d\u00fc\u015f\u00fcnebilirsiniz. Not 50\u2019den k\u00fc\u00e7\u00fckse b\u0131rak. take_while Ayn\u0131 drop_while gibi \u00e7al\u0131\u015f\u0131r ama tersini yapar: notlar = [ 40 , 45 , 53 , 70 , 99 , 65 ] notlar . take_while { | notu | notu < 50 } # => [40, 45] Ko\u015fula g\u00f6re Array\u2019e ekler gibi d\u00fc\u015f\u00fcnebilirsiniz. Not 50\u2019den k\u00fc\u00e7\u00fckse sepete ekle! :) each , each_index , each_with_index , each_slice , each_cons , each_with_object , reverse_each Array ve hatta Enumator\u2019lerin can damar\u0131d\u0131r. Ruby yazarken siz de g\u00f6receksiniz each en s\u0131k kulland\u0131\u011f\u0131n\u0131z iterasyon ( yineleme / tekrarlama ) y\u00f6ntemi olacak. a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . each # => #<Enumerator: [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\"]:each> a . each { | isim | puts \"\u0130sim: #{ isim } \" } # \u0130sim: U\u011fur # \u0130sim: Ye\u015fim # \u0130sim: Ezel # \u0130sim: \u00d6mer Array ve i\u00e7inde dola\u015f\u0131labilir her nesnede i\u015fe yarar. Birde bunun index \u2019li hali var; a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . each_index # => #<Enumerator: [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\"]:each_index> a . each_index . to_a # => [0, 1, 2, 3] a . each_index { | i | puts \"Index: #{ i } , De\u011feri: #{ a [ i ] } \" } # Index: 0, De\u011feri: U\u011fur # Index: 1, De\u011feri: Ye\u015fim # Index: 2, De\u011feri: Ezel # Index: 3, De\u011feri: \u00d6mer ya da bu i\u015fi; a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . each_with_index { | eleman , index | puts \"index: #{ index } , eleman: #{ eleman } \" } # index: 0, eleman: U\u011fur # index: 1, eleman: Ye\u015fim # index: 2, eleman: Ezel # index: 3, eleman: \u00d6mer each_slice da Array\u2019i gruplamak, par\u00e7alara ay\u0131rmak i\u00e7indir. Ge\u00e7ilen parametre bu i\u015fe yarar: a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . each_slice ( 2 ) # => #<Enumerator: [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\"]:each_slice(2)> a . each_slice ( 2 ) . to_a # => [[\"U\u011fur\", \"Ye\u015fim\"], [\"Ezel\", \"\u00d6mer\"]] a . each_slice ( 2 ) { | ikili_grup | puts \" #{ ikili_grup } \" } # [\"U\u011fur\", \"Ye\u015fim\"] # [\"Ezel\", \"\u00d6mer\"] each_cons ise slice gibi ama mutlaka belirtilen miktarda par\u00e7a \u00fcretir. # 3\u2019l\u00fc \u00fcret [ 1 , 2 , 3 , 4 , 5 , 6 ]. each_cons ( 3 ) . to_a # => [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]] # 4\u2019l\u00fc \u00fcret [ 1 , 2 , 3 , 4 , 5 , 6 ]. each_cons ( 4 ) . to_a # => [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]] each_with_object de ise, iterasyona girerken bir nesne pas edip, o nesneyi doldurabilirsiniz. [ 1 , 2 , 3 , 4 ]. each_with_object ( [] ) { | number , given_object | given_object << number * 2 } # => [2, 4, 6, 8] number Array\u2019den gelen eleman ( 1, 2, 3, 4 gibi ), given_object ise each_with_object([]) method\u2019da ge\u00e7ti\u011fimiz bo\u015f Array [] . reverse_each asl\u0131nda Array\u2019i otomatik olarak ters \u00e7evirir yani reverse eder ve i\u00e7inde dola\u015fman\u0131z\u0131 sa\u011flar: computers = [ \"Commodore 64\" , \"Amiga\" , \"Sinclair\" , \"Amstrad\" ] computers . reverse_each # => #<Enumerator: [\"Commodore 64\", \"Amiga\", \"Sinclair\", \"Amstrad\"]:reverse_each> computers . reverse_each . to_a # => [\"Amstrad\", \"Sinclair\", \"Amiga\", \"Commodore 64\"] computers . reverse_each { | c | puts \"Bilgisayar: #{ c } \" } # Bilgisayar: Amstrad # Bilgisayar: Sinclair # Bilgisayar: Amiga # Bilgisayar: Commodore 64 find_index \u0130ndeks\u2019i ararken blok i\u015fleyebiliriz: computers = [ \"Commodore 64\" , \"Amiga\" , \"Sinclair\" , \"Amstrad\" ] computers . find_index { | c | c == \"Amstrad\" } # => 3 freeze ve frozen? Array\u2019i kitlemek i\u00e7in kullan\u0131l\u0131r. Yani freeze ( dondurulmu\u015f ) bir Array\u2019e yeni eleman eklenemez. Keza Array#sort esnas\u0131nda da otomatik olarak freeze olur sort bitince buz \u00e7\u00f6z\u00fcl\u00fcr! a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . freeze a << \"Fazilet\" # Yeni isim eklemek m\u00fcmk\u00fcn de\u011fildir! RuntimeError : can \u2019 t modify frozen Array Array\u2019de buzlanma var m\u0131 yok mu anlamak i\u00e7in frozen? kullan\u0131r\u0131z: a = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] a . freeze # => [\"U\u011fur\", \"Ye\u015fim\", \"Ezel\", \"\u00d6mer\"] a . frozen? # => true min , max , minmax , min_by , max_by ve minmax_by min ve max ile Array elemanlar\u0131ndan en k\u00fc\u00e7\u00fck/b\u00fcy\u00fck de\u011feri al\u0131r\u0131z: a = [ 6 , 1 , 8 , 4 , 11 ] a . min # => 1 a . max # => 11 Peki say\u0131 yerine metinler olsa ne olacakt\u0131? m = [ \"a\" , \"ab\" , \"abc\" , \"abcd\" ] m . min # => \"a\" m . max # => \"abcd\" peki, m Array\u2019i \u015f\u00f6yle olsayd\u0131: m = [\"a\", \"ab\", \"abc\", \"abcd\", \"111111111\"] sonu\u00e7 ne olurdu? m = [ \"a\" , \"ab\" , \"abc\" , \"abcd\" , \"111111111\" ] m . min # => \"111111111\" # ? m . max # => \"abcd\" \u00d6nce Comparable m\u0131 diyer bak\u0131l\u0131r, say\u0131lar i\u00e7in \u00e7al\u0131\u015fan bu y\u00f6ntem, String de a <=> b kar\u015f\u0131la\u015ft\u0131rmas\u0131na girer ve Lexicological kar\u015f\u0131la\u015ft\u0131rma yapar. \"111111111\" karakter say\u0131s\u0131 olarak di\u011ferlerine g\u00f6re \u00e7ok olmas\u0131na ra\u011fmen, min de\u011fer olarak gelir. E\u011fer karakter say\u0131na g\u00f6re kar\u015f\u0131la\u015ft\u0131rma yapmak gerekiyorsa; m = [ \"a\" , \"ab\" , \"abc\" , \"abcd\" , \"111111111\" ] m . min { | a , b | a . length <=> b . length } # => \"a\" m . max # => \"abcd\" \u015eeklinde yapmak gerekir. Blok kullanabildi\u011fimiz i\u00e7in ayn\u0131 i\u015f max i\u00e7in de ge\u00e7erlidir. Ya da bu i\u015fleri yapabilmek i\u00e7in min_by ve max_by kullanabiliriz: m = [ \"a\" , \"ab\" , \"abc\" , \"abcd\" , \"111111111\" ] m . min_by { | x | x . length } # => \"a\" m . max_by { | x | x . length } # => \"111111111\" minmax da Array\u2019in minimum ve maximum\u2019unu d\u00f6ner: m = [ \"a\" , \"ab\" , \"abc\" , \"abcd\" ] m . min # => \"a\" m . max # => \"abcd\" m . minmax # => [\"a\", \"abcd\"] Ayn\u0131 mant\u0131kta minmax_by da gerekli \u015farta g\u00f6re min , max d\u00f6ner: m = [ \"a\" , \"ab\" , \"abc\" , \"abcd\" ] m . minmax_by { | x | x . length } # => [\"a\", \"abcd\"] all? , any? , one? , none? Array i\u00e7indeki elemanlar\u0131 belli bir ko\u015fula g\u00f6re kontrol etmek i\u00e7in kullan\u0131l\u0131r. Sonu\u00e7 Boolean yani true ya da false d\u00f6ner. T\u00fcm elemanlar\u0131n kontrol\u00fc ko\u015fula uyuyorsa true uymuyorsa false d\u00f6ner. # acaba hayvanlar dizisindeki isimlerin hepsinin uzunlu\u011fu # en az 2 karakter mi? hayvanlar = [ \"Kedi\" , \"K\u00f6pek\" , \"Ku\u015f\" , \"Kurba\u011fa\" , \"Kaplumba\u011fa\" ] hayvanlar . all? { | hayvan_ismi | hayvan_ismi . length >= 2 } # => true # Acaba ilk karfleri K harfimi? hayvanlar . all? { | hayvan_ismi | hayvan_ismi . start_with? ( \"K\" ) } # => true # Elemanlar\u0131n her biri true mu? [ true , false , nil ]. all? # => false any? de yanl\u0131zca bir tanesi true olsa yeterlidir: # En az\u0131ndan bir hayvan ismi A ile ba\u015fl\u0131yor mu? hayvanlar = [ \"Kedi\" , \"K\u00f6pek\" , \"At\" , \"Y\u0131lan\" , \"Bal\u0131k\" ] hayvanlar . any? { | hayvan_ismi | hayvan_ismi . start_with? ( \"A\" ) } # => true one? da ise sadece bir eleman ko\u015fula uymal\u0131d\u0131r. Yani bir tanesi true d\u00f6nmelidir. E\u011fer birden fazla eleman ko\u015fula true d\u00f6nerse sonu\u00e7 false olur: hayvanlar = [ \"Kedi\" , \"K\u00f6pek\" , \"At\" , \"Y\u0131lan\" , \"Bal\u0131k\" , \"Kaplumba\u011fa\" ] # Sadece bir ismin uzunlu\u011fu 6 karaterten b\u00fcy\u00fck olmal\u0131! hayvanlar . one? { | hayvan_ismi | hayvan_ismi . length > 6 } # => true # Uzunlu\u011fu 3\u2019ten b\u00fcy\u00fck 5 isim oldu\u011fu i\u00e7in false d\u00f6nd\u00fc! hayvanlar . one? { | hayvan_ismi | hayvan_ismi . length > 3 } # => false none? da ise hepsi false olmal\u0131d\u0131r ki sonu\u00e7 true d\u00f6ns\u00fcn: hayvanlar = [ \"Kedi\" , \"K\u00f6pek\" , \"At\" , \"Y\u0131lan\" , \"Bal\u0131k\" , \"Kaplumba\u011fa\" ] # Hi\u00e7bir ismin uzunlu\u011fu 2 karakter olmamal\u0131 ? false. At\u2019\u0131n uzunlu\u011fu 2 hayvanlar . none? { | hayvan_ismi | hayvan_ismi . length == 2 } # => false # C ile ba\u015flayan hayvan ismi olmas\u0131n! true. Hi\u00e7bir isim C ile ba\u015flam\u0131yor hayvanlar . none? { | hayvan_ismi | hayvan_ismi . start_with? ( \"C\" ) } # => true inject , reduce * inject ve reduce ayn\u0131 i\u015fi yaparlar ve bir t\u00fcr ak\u00fcm\u00fclator i\u015flemi yapmaya yararlar. Blok i\u00e7inde 2 paramtre kullan\u0131l\u0131r. Ba\u015flama parametresi de alabilir. \u00d6rne\u011fin Array [1, 2, 3, 4, 5] ve t\u00fcm elemanlar\u0131 birbiriyle toplamak isitiyoruz. [ 1 , 2 , 3 , 4 , 5 ]. inject { | toplam , eleman | toplam + eleman } # => 15 # i\u015flem \u015fu \u015fekilde ilerliyor # toplam: 0, eleman: 1 # toplam: 1, eleman: 2 # toplam: 3, eleman: 3 # toplam: 6, eleman: 4 # toplam: 10, eleman: 5 # sona geldi\u011finde toplam 10, eleman 5 -> 10 + 5 = 15 E\u011fer ba\u015flang\u0131\u00e7 de\u011feri i\u00e7in parametre ge\u00e7seydik, \u00f6rne\u011fin 10 : [ 1 , 2 , 3 , 4 , 5 ]. inject ( 10 ){ | toplam , eleman | toplam + eleman } # => 25 # toplam: 10, eleman: 1 # toplam: 11, eleman: 2 # toplam: 13, eleman: 3 # toplam: 16, eleman: 4 # toplam: 20, eleman: 5 # sona geldi\u011finde toplam 20, eleman 5 -> 20 + 5 = 25 Ayn\u0131 i\u015fi reduce ile de yapabilirdik. [ 1 , 2 , 3 , 4 , 5 ]. reduce ( :+ ) # => 15 \u00d6rnekte her eleman\u0131n + methodu\u2019nu \u00e7a\u011f\u0131r\u0131yoruz ve sanki x = x + 1 mant\u0131\u011f\u0131nda, kendisini ekleye ekleye sonuca var\u0131yoruz. en_uzun_hayvan_ismi = [ \"kedi\" , \"k\u00f6pek\" , \"kamplumba\u011fa\" ]. inject do | buffer , hayvan | buffer . length > hayvan . length ? buffer : hayvan end en_uzun_hayvan_ismi # => \"kamplumba\u011fa\" partition ve group_by partition Array\u2019i 2 par\u00e7aya ay\u0131rmaya yarar. Sonu\u00e7, blok\u2019ta i\u015flenen ifadeye ba\u011fl\u0131 olarak [true_array, false_array] olarak d\u00f6ner. Yani ko\u015fula true cevap verenlerle false cevap verenler ayr\u0131 par\u00e7alar halinde d\u00f6ner :) [ 1 , 2 , 3 , 4 , 5 , 6 ]. partition { | n | n . even? } # => [[2, 4, 6], [1, 3, 5]] # \u00c7ift say\u0131lar, true_array yani ilk par\u00e7a: [2, 4, 6] # Tek say\u0131lar, false_array yani ikinci par\u00e7a: [1, 3, 5] # Sadece \u00e7ift say\u0131lar gelsin: [ 1 , 2 , 3 , 4 , 5 , 6 ]. partition { | n | n . even? } [ 0 ] # => [2, 4, 6] group_by gruplama yapmak i\u00e7in kullan\u0131l\u0131r. Sonu\u00e7 Hash d\u00f6ner, ilk de\u011fer ( key ) blok i\u00e7indeki ifadenin sonucu, ikinci de\u011fer ( value ) ise sonucu verenlerin olu\u015fturdu gruptur. 1\u2019den 6\u2019ya kadar say\u0131lar\u0131 3\u2019e b\u00f6l\u00fcnce ka\u00e7 kald\u0131\u011f\u0131n\u0131 gruplayarak bulal\u0131m: [ 1 , 2 , 3 , 4 , 5 , 6 ]. group_by { | n | n % 3 } # => {1=>[1, 4], 2=>[2, 5], 0=>[3, 6]} # 3\u2019e b\u00f6l\u00fcnce kalan\u0131; # 1 olanlar: [1, 4] # 2 olanlar: [2, 5] # 0 olanlar (tam b\u00f6l\u00fcnenler) : [3, 6] Notu 50\u2019den b\u00fcy\u00fck olanlar: notlar = [ 50 , 20 , 44 , 60 , 80 , 100 , 99 , 81 , 5 ] notlar . group_by { | notu | notu > 40 } [ true ] # => [50, 44, 60, 80, 100, 99, 81] chunk Array elemanlar\u0131 ko\u015fula g\u00f6re gruplar. [ 3 , 1 , 4 , 1 , 5 , 9 , 2 , 6 , 5 , 3 , 5 ]. chunk { | n | n . even? } . to_a # => [ # [false, [3, 1]], # [true, [4]], # [false, [1, 5, 9]], # [true, [2, 6]], # [false, [5, 3, 5]] # ] slice_before Array i\u00e7inde belli bir elemana ya da kurala g\u00f6re par\u00e7alara ay\u0131rmak i\u00e7in kullan\u0131l\u0131r. [ 1 , 2 , 3 , \u2019 a \u2019 , 4 , 5 , 6 , \u2019 a \u2019 , 7 , 8 , 9 , \u2019 a \u2019 , 1 , 3 , 5 ]. slice_before { | i | i == \u2019 a \u2019 } . to_a # => [[1, 2, 3], [\"a\", 4, 5, 6], [\"a\", 7, 8, 9], [\"a\", 1, 3, 5]] flat_map , collect_concat \u0130kisi de ayn\u0131 i\u015fi yapar. \u00d6nce map eder sonra flatten yapar. pos_neg = [ 1 , 2 , 3 , 4 , 5 , 6 ]. map { | n | [ n , - n ] } pos_neg # => [[1, -1], [2, -2], [3, -3], [4, -4], [5, -5], [6, -6]] pos_neg . flatten # => [1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6] # yerine: [ 1 , 2 , 3 , 4 , 5 , 6 ]. flat_map { | n | [ n , - n ] } # => [1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6] sort_by Ayn\u0131 sort gibi \u00e7al\u0131\u015f\u0131r, Blok kullan\u0131r. \u0130fadenin true olmas\u0131na g\u00f6re \u00e7al\u0131\u015f\u0131r: hayvanlar = [ \"kamplumba\u011fa\" , \"at\" , \"e\u015f\u015fek\" , \"kurba\u011fa\" , \"ay\u0131\" ] # isimleri uzunluklar\u0131na g\u00f6re k\u00fc\u00e7\u00fckten b\u00fcy\u00fc\u011fe do\u011fru s\u0131ralayal\u0131m hayvanlar . sort_by { | isim | isim . length } # => [\"at\", \"ay\u0131\", \"e\u015f\u015fek\", \"kurba\u011fa\", \"kamplumba\u011fa\"] # isimleri uzunluklar\u0131na g\u00f6re b\u00fcy\u00fckten k\u00fc\u00e7\u00fc\u011fe do\u011fru s\u0131ralayal\u0131m hayvanlar . sort_by { | isim | - isim . length } # => [\"at\", \"ay\u0131\", \"e\u015f\u015fek\", \"kurba\u011fa\", \"kamplumba\u011fa\"] bsearch Binary arama yapar, O(log n) form\u00fcl\u00fcn\u00fc uygular, buradaki n Array\u2019in boyudur. Find minimum gibidir, yani ko\u015fula ilk uyan\u0131 bul gibi... # 2\u2019den b\u00fcy\u00fck 3, 4 ve 5 olmas\u0131na ra\u011fmen tek sonu\u00e7 [ 1 , 2 , 3 , 4 , 5 ]. bsearch { | n | n > 2 } # => 3 [ 1 , 2 , 3 , 4 , 5 ]. bsearch { | n | n >= 4 } # => 4","title":"\u0130terasyon ve Block Kullan\u0131m\u0131"},{"location":"bolum-04/04-array/#tehlikeli-islemler","text":"Ba\u015flarda da bahsetti\u011fimiz gibi method ismi ! ile bitiyorsa bu ilgili nesnede de\u011fi\u015fiklik yap\u0131yor oldu\u011fumuz anlam\u0131na gelir. Array\u2019lerde de bu t\u00fcr method\u2019lar var: [ :reverse! , :rotate! , :sort! , :sort_by! , :collect! , :map! , :select! , :reject! , :slice! , :uniq! , :compact! , :flatten! , :shuffle! ] Bu method\u2019lar orijinal Array\u2019i bozar. Yani; a = [ 1 , 2 , 3 , 4 , 5 ] a . reverse! # => [5, 4, 3, 2, 1] # a art\u0131k reverse edilmi\u015f halde! a # => [5, 4, 3, 2, 1]","title":"Tehlikeli \u0130\u015flemler"},{"location":"bolum-04/05-hash/","text":"Hash Pek \u00e7ok dilde Dictionary olarak ge\u00e7en, Array\u2019imsi, hatta Associative Array de denir, Key - Value \u00e7ifti bar\u0131nd\u0131ran yine Array\u2019e benzeyen ba\u015fka bir ta\u015f\u0131y\u0131c\u0131d\u0131r. Key - Value dedi\u011fimiz \u015fey ise; { key1 : \"value1\" , key2 : \"value2\" , .... } \u015feklindedir. Yukar\u0131daki \u00f6rnek, yeni syntax\u2019\u0131 kullan\u0131r. Ruby programc\u0131lar\u0131n\u0131n al\u0131\u015f\u0131k oldu\u011fu \u00f6rnek: { \"key1\" => \"value1\" , \"key2\" => \"value2\" , ... } ya da { :key1 => \"value1\" , :key2 => \"value2\" , ... } \u015feklindedir. Hepsi ayn\u0131 kap\u0131ya \u00e7\u0131kar... Array\u2019deki s\u0131ra ( index ) mant\u0131\u011f\u0131 burada key \u2019ler ile oluyor gibi d\u00fc\u015f\u00fcnebilirsiniz. Key\u2019ler unique \u2019dir yani bir Hash i\u00e7inde 2 tane ayn\u0131 key \u2019den olamaz. Hash\u2019de sonu\u00e7ta bir class oldu\u011fu i\u00e7in new method\u2019u ile Hash\u2019i olu\u015fturabiliriz; Hash . new # => {} Ayn\u0131 Array\u2019deki gibi Hash\u2019in de h\u0131zl\u0131 olu\u015furma yolu var : h = {} . Hemen Hash\u2019in nereden geldi\u011fine bakal\u0131m: Hash . class # => Class Hash . class . superclass # => Module Hash . class . superclass . superclass # => Object Hash . class . superclass . superclass . superclass # => BasicObject Hash . class . superclass . superclass . superclass . superclass # => nil Dikkat ettiyseniz Hash\u2019in bir \u00fcst s\u0131n\u0131f\u0131 Module . Ayn\u0131 Array\u2019deki gibi. Peki bu mod\u00fcller nelermi\u015f? Hash . included_modules # => [Enumerable, Kernel] E\u011fer Hash\u2019i olu\u015ftururken default de\u011fer ge\u00e7ersek, tan\u0131ms\u0131z olan key i\u00e7in de\u011fer atam\u0131\u015f oluruz: h = Hash . new ( \"Tan\u0131ms\u0131z\" ) # => {} h [ :isim ] = \"U\u011fur\" # => \"U\u011fur\" h # => {:isim=>\"U\u011fur\"} h [ :soyad ] # => \"Tan\u0131ms\u0131z\" h . default # => \"Tan\u0131ms\u0131z\" Olmayan bir key\u2019e ula\u015fmak istedi\u011fimizde \"Tan\u0131ms\u0131z\" de\u011feri geldi. E\u011fer bu default de\u011feri atamasayd\u0131 ne olacakt\u0131? h = Hash . new # => {} h [ :isim ] = \"U\u011fur\" # => \"U\u011fur\" h [ :soyad ] # => nil nil gelecekti. Biraz sonra g\u00f6rece\u011fimiz fetch method\u2019unu l\u00fctfen akl\u0131n\u0131zda tutun! Default de\u011fer tan\u0131mlama mant\u0131\u011f\u0131nda; h = Hash . new { | hash , key | hash [ key ] = \"User: #{ key } \" } h [ \"vigo\" ] # => \"User: vigo\" h [ \"foobar\" ] # => \"User: foobar\" h [ \"animal\" ] = \"horse\" # => \"horse\" h # => {\"vigo\"=>\"User: vigo\", \"foobar\"=>\"User: foobar\", \"animal\"=>\"horse\"} bu tarz ilgin\u00e7 bir y\u00f6ntem de kullan\u0131labilir. Normalde vigo key\u2019ine kar\u015f\u0131l\u0131k value yok ama Hash in new method\u2019unda yapt\u0131\u011f\u0131m\u0131z bir blok i\u015flemi ile olmayan key i\u00e7in de\u011fer atamas\u0131 yapt\u0131\u011f\u0131m\u0131z gibi key-value atamas\u0131 da yapabiliyoruz. Hash Class Method\u2019lar\u0131 Hash\u2019den bir instance olu\u015fturmadan kulland\u0131\u011f\u0131m\u0131z methodlard\u0131r. Hash[ key, value, ... ] -> yeni_hash Hash[ [ [key, value], ... ] ] -> yeni_hash Hash[ object ] -> yeni_hash Hash [ \"user_count\" , 5 ] # => {\"user_count\"=>5} Hash [ [[ \"user_count\" , 5 ] , [ \"active_users\" , 2 ]] ] # => {\"user_count\"=>5, \"active_users\"=>2} Hash [ \"user_count\" => 5 , \"active_users\" => 2 ] # => {\"user_count\"=>5, \"active_users\"=>2} Hash.new Zaten ilgili \u00f6rnekleri ba\u015fta vermi\u015ftik, tekrar edelim: h = Hash . new h # => {} h [ \"user_count\" ] = 5 h # => {\"user_count\"=>5} h = Hash . new { | hash , key | hash [ key ] = \"User ID: #{ key } \" } h [ \"1\" ] # => \"User ID: 1\" h [ \"2\" ] # => \"User ID: 2\" h # => {\"1\"=>\"User ID: 1\", \"2\"=>\"User ID: 2\"} try_convert(obj) \u2192 hash ya da nil Hash\u2019e d\u00f6n\u00fc\u015febilme ihtimali olan nesneyi Hash haline \u00e7evirir. Hash . try_convert ({ \"user_count\" => 5 }) # => {\"user_count\"=>5} Hash . try_convert ( \"user_count=>5\" ) # => nil Hash Instance Method\u2019lar\u0131 Hash instance\u2019\u0131 olu\u015fturduktan sonra kullanaca\u011f\u0131m\u0131z method\u2019lard\u0131r. \u00d6nce klasik de\u011fer okuma ve de\u011fer atama i\u015flerine bakal\u0131m. Zaten bu noktaya kadar kabaca biliyoruz nas\u0131l de\u011fer atar\u0131z geri okuruz. Ama biraz kafalar\u0131 kar\u0131\u015ft\u0131rmak istiyorum: h = { username : \"vigo\" , password : \"1234\" } # => {:username=>\"vigo\", :password=>\"1234\"} Yukar\u0131daki gibi bir Hash \u2019imiz var. Dikkat ettiyseniz, key,value olarak bakt\u0131\u011f\u0131m\u0131zda :username ve :password diye ba\u015flayan key ler var... Hatta: h . keys # => [:username, :password] diye de sa\u011flamas\u0131n\u0131 yapar\u0131z. Peki, yeni bir key tan\u0131mlasak? h[\"useremail\"] = \"vigo@example.com\" . Tekrar bakal\u0131m key lere: h . keys # => [:username, :password, \"useremail\"] Bir sonraki b\u00f6l\u00fcmde kar\u015f\u0131m\u0131za \u00e7\u0131kacak olan Symbol tipi ile kar\u015f\u0131 kar\u015f\u0131yay\u0131z. Sadece symbol mu? hay\u0131r, kar\u0131\u015f\u0131k keyler var elimizde. Hemen sa\u011flamas\u0131n\u0131 yapal\u0131m: h . keys . map ( & :class ) # => [Symbol, Symbol, String] \u0130lk iki key Symbol iken son key String oldu. Demek ki Hash i\u00e7ine key cinsi olarak kar\u015f\u0131k atama yapabiliniyor. Biraz s\u0131k\u0131nt\u0131l\u0131 bir durum ama genel k\u00fclt\u00fcr mahiyetinde akl\u0131n\u0131zda tutun bunu! \u015eimdi genel olarak Hash hangi method\u2019lara sahip hemen bakal\u0131m: h = Hash . new h . methods # => [:rehash, :to_hash, :to_h, :to_a, :inspect, :to_s, :==, :[], :hash, :eql?, :fetch, :[]=, :store, :default, :default=, :default_proc, :default_proc=, :key, :index, :size, :length, :empty?, :each_value, :each_key, :each_pair, :each, :keys, :values, :values_at, :shift, :delete, :delete_if, :keep_if, :select, :select!, :reject, :reject!, :clear, :invert, :update, :replace, :merge!, :merge, :assoc, :rassoc, :flatten, :include?, :member?, :has_key?, :has_value?, :key?, :value?, :compare_by_identity, :compare_by_identity?, :entries, :sort, :sort_by, :grep, :count, :find, :detect, :find_index, :find_all, :collect, :map, :flat_map, :collect_concat, :inject, :reduce, :partition, :group_by, :first, :all?, :any?, :one?, :none?, :min, :max, :minmax, :min_by, :max_by, :minmax_by, :each_with_index, :reverse_each, :each_entry, :each_slice, :each_cons, :each_with_object, :zip, :take, :take_while, :drop, :drop_while, :cycle, :chunk, :slice_before, :lazy, :nil?, :===, :=~, :!~, :<=>, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :singleton_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__] Dikkat ettiyseniz method\u2019lar\u0131n bir k\u0131sm\u0131 Array ile ayn\u0131 \u00e7\u00fcnki ikisi de Enumerable mod\u00fcl\u00fcn\u00fc kullan\u0131yor. \u015eimdi s\u0131radan ba\u015flayal\u0131m! \u00d6nceki Array b\u00f6l\u00fcm\u00fcnde anlatt\u0131\u011f\u0131m ortak method\u2019lar\u0131 pas ge\u00e7ece\u011fim! rehash Hash\u2019e key olarak Array verebiliriz. Yani h[key] = value mant\u0131\u011f\u0131nda key olarak bildi\u011finiz Array ge\u00e7ebiliriz. a = [ \"a\" , \"b\" ] c = [ \"c\" , \"d\" ] h = { a => 100 , c => 300 } # => {[\"a\", \"b\"]=>100, [\"c\", \"d\"]=>300} h Hash\u2019inin keyleri nedir? h . keys # => [[\"a\", \"b\"], [\"c\", \"d\"]] 2 key\u2019i var biri [\"a\", \"b\"] ve di\u011feri [\"c\", \"d\"] nas\u0131l yani? h [ a ] # => 100 h [[ \"a\" , \"b\" ]] # => 100 h [ c ] # => 300 h [[ \"c\" , \"d\" ]] # => 300 \u015eimdi i\u015fleri kar\u0131\u015ft\u0131ral\u0131m. a Array\u2019inin ilk de\u011ferini de\u011fi\u015ftirelim. Bakal\u0131m h ne olacak? a [ 0 ] = \"v\" # => \"v\" a # => [\"v\", \"b\"] h [ a ] # => nil ???????? h[a] patlad\u0131? nil d\u00f6nd\u00fc. \u0130\u015fte \u015fimdi imdad\u0131m\u0131za ne yeti\u015fecek? h . rehash # => {[\"v\", \"b\"]=>100, [\"c\", \"d\"]=>300} h [ a ] # => 100 to_hash , to_h , to_a , to_s Tip d\u00f6n\u00fc\u015ft\u00fcrmeleri i\u00e7in kullan\u0131l\u0131rlar. to_h ve to_hash e\u011fer kendisi Hash ise sonu\u00e7 yine kendisi olur. to_a ise Hash\u2019den Array yapmak i\u00e7in kullan\u0131l\u0131r. Tahmin edece\u011finiz gibi to_s de String\u2019e \u00e7evirmek i\u00e7in kullan\u0131l\u0131r. h = { :foo => \"bar\" } h # => {:foo=>\"bar\"} h . to_hash # => {:foo=>\"bar\"} h . to_h # => {:foo=>\"bar\"} [ \"foo\" , \"bar\" ]. respond_to? ( :to_h ) # => true [[ :foo , \"bar\" ]]. to_h # => {:foo=>\"bar\"} [[ \"a\" , 1 ] , [ \"b\" , 2 ]]. to_h # => {\"a\"=>1, \"b\"=>2} h . to_a # => [[:foo, \"bar\"]] h . to_s # => \"{:foo=>\\\"bar\\\"}\" == ve eql? E\u015fitlik Hash i\u00e7inde key\u2019lerin s\u0131ras\u0131 e\u015fitlik kontrol\u00fcnde \u00f6nemli de\u011fildir. \u0130\u00e7erik \u00f6nemlidir. E\u015fitlik kontrol\u00fc i\u00e7in kullan\u0131l\u0131rlar. h1 = { \"a\" => 100 , \"c\" => 200 } h2 = { 70 => 350 , \"x\" => 22 , \"y\" => 11 } h3 = { \"y\" => 11 , \"x\" => 22 , 70 => 350 } h1 == h2 # => false h2 == h3 # => true h1 . eql? ( h2 ) # => false h2 . eql? ( h3 ) # => true h2 ile h3 key s\u0131ralar\u0131 farkl\u0131 olmas\u0131na ra\u011fmen i\u00e7erik baz\u0131nda e\u015fittirler. fetch Hash i\u00e7inden sorgu yaparken kullan\u0131l\u0131r. E\u011fer olmayan key \u00e7a\u011f\u0131r\u0131rsan\u0131z exception olu\u015fur. Bu method g\u00fcvenli bir y\u00f6ntemdir. Aksi takdirde nil d\u00f6ner ve kompleks i\u015flerde Silent Fail yani dipsiz kuyuya d\u00fc\u015fer bir t\u00fcrl\u00fc hatan\u0131n yerini bulamazs\u0131n\u0131z! h = { :user => \"vigo\" , :password => \"secret\" } puts h . fetch ( :user ) # \"vigo\" puts h . fetch ( :email ) KeyError : key not found : :email Keza e\u011fer key\u2019e kar\u015f\u0131l\u0131k yoksa default de\u011fer atamas\u0131 yapabilirsiniz: h = { :user => \"vigo\" , :password => \"secret\" } h . fetch ( :user ) # => \"vigo\" h . fetch ( :email , \"Not found\" ) # => \"Not found\" Block kabul etti\u011fi i\u00e7in artistlik hareketler yapmak da m\u00fcmk\u00fcn :) h = { :user => \"vigo\" , :password => \"secret\" } h . fetch ( :email ) { | element | \"key: #{ element } is not defined!\" } # => \"key: email is not defined!\" store Atama yapman\u0131n farkl\u0131 bir y\u00f6ntemidir. h = { :user => \"vigo\" , :password => \"secret\" } h . store ( :email , \"vigo@example.com\" ) # => \"vigo@example.com\" h # => {:user=>\"vigo\", :password=>\"secret\", :email=>\"vigo@example.com\"} # ya da h [ :url ] = \"http://webbox.io\" # => \"http://webbox.io\" h # => {:user=>\"vigo\", :password=>\"secret\", :email=>\"vigo@example.com\", :url=>\"http://webbox.io\"} default , default= Kar\u015f\u0131l\u0131\u011f\u0131 olmayan key ler i\u00e7in varsay\u0131lan de\u011fer atamas\u0131 yap\u0131lm\u0131\u015fsa bunu bulmak i\u00e7in ya da varsay\u0131lan de\u011feri atamak i\u00e7in kullan\u0131l\u0131r. En ba\u015fta benzer i\u015fler yapt\u0131k: h = Hash . new ( 10 ) h [ :user_age ] # => 10 h # => {} h . default # => 10 h . default ( :user_weight ) # => 10 ya da h = Hash . new h # => {} h . default = 100 # => 100 h [ :user_weight ] # => 100 h [ :foo ] # => 100 key Value\u2019den key\u2019i bulmak i\u00e7in kullan\u0131l\u0131r. E\u011fer key\u2019i olmayan bir value kullan\u0131rsan\u0131z sonu\u00e7 nil d\u00f6ner! h = { :user => \"vigo\" , :password => \"secret\" } h . key ( \"vigo\" ) # => :user h . key ( \"foobar\" ) # => nil size , length , count Ayn\u0131 i\u015fi yaparlar, Arrar gibi Hash\u2019in boyunu / uzunlu\u011funu verir. h = { :user => \"vigo\" , :password => \"secret\" } h . length # => 2 h . size # => 2 h . count # => 2 Key, Value Kontrolleri keys , values , values_at Tahmin edece\u011finiz gibi keys ile Hash\u2019e ait key\u2019leri, values ile sadece key\u2019lere kar\u015f\u0131l\u0131k gelen de\u011ferleri, values_at ile verdi\u011fimiz key\u2019lere ait de\u011ferleri al\u0131r\u0131z. h = { :user => \"vigo\" , :password => \"secret\" , :email => \"vigo@foo.com\" } h . keys # => [:user, :password, :email] h . values # => [\"vigo\", \"secret\", \"vigo@foo.com\"] h . values_at ( :user , :password ) # => [\"vigo\", \"secret\"] key? , value? , has_key? , has_value? Soru i\u015fareti ile biten method\u2019lar bize her zaman Boolean yani true ya da false d\u00f6ner demi\u015ftik. Acaba Hash\u2019in i\u00e7inde ilgili key var m\u0131? ya da value var m\u0131? h = { :user => \"vigo\" , :password => \"secret\" , :email => \"vigo@foo.com\" } h . key? ( :user ) # => true h . has_key? ( :user ) # => true h . key? ( :full_name ) # => false h . has_key? ( :full_name ) # => false h . value? ( \"vigo\" ) # => true h . has_value? ( \"vigo\" ) # => true h . value? ( \"lego\" ) # => false h . has_value? ( \"lego\" ) # => false include? , member? key? ya da has_key? ile ayn\u0131 i\u015fi yapar. h = { :user => \"vigo\" , :password => \"secret\" , :email => \"vigo@foo.com\" } h . include? ( :user ) # => true h . member? ( :user ) # => true empty? Hash\u2019in i\u00e7inde eleman var m\u0131 yok mu? { :user => \"vigo\" , :password => \"secret\" , :email => \"vigo@foo.com\" } . empty? # => false {} . empty? # => true all? , any? , one? , none? Array b\u00f6l\u00fcm\u00fcnde g\u00f6rm\u00fc\u015ft\u00fck, Enumerable mod\u00fcl\u00fcnden gelen bu \u00f6zellik aynen Hash\u2019de de kullan\u0131l\u0131yor. all? da t\u00fcm elemanlar, verilen ko\u015fuldan nil ya da false d\u0131\u015f\u0131nda bir \u015fey d\u00f6nmek zorunda, aksi halde sonu\u00e7 false oluyor: # value\u2019su bo\u015f olan var m\u0131? { :user => \"vigo\" , :password => \"secret\" , :email => \"vigo@foo.com\" } . all? { | k , v | v . empty? } # => false { :user => \"\" , :password => \"\" , :email => \"\" } . all? { | k , v | v . empty? } # => true { :user => \"vigo\" , :password => \"\" , :email => \"\" } . all? { | k , v | v . empty? } # => false any? de i\u00e7lerinden biri false ya da nil d\u00f6nmezse sonu\u00e7 true olur. one? da sadece bir tanesi true d\u00f6nmelidir. none da ise block\u2019daki i\u015flem sonucu her eleman i\u00e7in false olmal\u0131d\u0131r. { :is_admin => true , :notifications_enabled => true } . all? { | option , value | value } # => true { :is_admin => true , :notifications_enabled => false } . any? { | option , value | value } # => true { :is_admin => true , :notifications_enabled => false } . one? { | option , value | value } # => true { :is_admin => false , :notifications_enabled => false } . one? { | option , value | value } # => false { :is_admin => false , :notifications_enabled => false } . all? { | option , value | value } # => false { :is_admin => false , :notifications_enabled => false } . none? { | option , value | value } # => true { :is_admin => false , :notifications_enabled => false } . any? { | option , value | value } # => false shift Hash\u2019den key-value \u00e7iftini silmek i\u00e7in kullan\u0131l\u0131r. Her seferinde ilk key-value \u00e7iftini siler. h = { :user => \"vigo\" , :password => \"secret\" , :email => \"vigo@foo.com\" } h . shift # => [:user, \"vigo\"] h # => {:password=>\"secret\", :email=>\"vigo@foo.com\"} h . shift # => [:password, \"secret\"] h # => {:email=>\"vigo@foo.com\"} h . shift # => [:email, \"vigo@foo.com\"] h # => {} delete , delete_if , keep_if Hash\u2019den key kullanarak eleman silmek i\u00e7in delete method\u2019u kullan\u0131l\u0131r. h = { :user => \"vigo\" , :password => \"secret\" , :email => \"vigo@foo.com\" } h . delete ( :user ) # => \"vigo\" h # => {:password=>\"secret\", :email=>\"vigo@foo.com\"} Block kullan\u0131ld\u0131\u011f\u0131nda, e\u011fer olmayan bir key kullan\u0131lm\u0131\u015fsa, bununla ilgili i\u015flem yapmam\u0131z\u0131 sa\u011flar: h . delete ( :phone ){ | key | \"- #{ key } - bulunamad\u0131?\" } # => \"-phone- bulunamad\u0131?\" delete_if de ise direk block kullanarak ko\u015fullu silme i\u015flemi yapabiliyoruz. # 40\u2019dan b\u00fcy\u00fckleri silelim h = { point_a : 10 , point_b : 20 , point_c : 50 } # => {:point_a=>10, :point_b=>20, :point_c=>50} h . delete_if { | k , v | v > 40 } # => {:point_a=>10, :point_b=>20} h # => {:point_a=>10, :point_b=>20} keep_if ise delete_if in tam tersi gibidir. E\u011fer block\u2019daki ko\u015ful true ise key-value \u00e7iftini tutar, aksi halde siler: # 20\u2019dan k\u00fc\u00e7\u00fckleri tutal\u0131m sadece h = { point_a : 10 , point_b : 20 , point_c : 50 } # => {:point_a=>10, :point_b=>20, :point_c=>50} h . keep_if { | k , v | v < 20 } # => {:point_a=>10} h # => {:point_a=>10} invert Hash\u2019in key\u2019leri ile value\u2019lerini yer de\u011fi\u015ftirmek i\u00e7in kullan\u0131l\u0131r. h = { \"a\" => 100 , \"b\" => 200 } # => {\"a\"=>100, \"b\"=>200} h . keys # => [\"a\", \"b\"] h . invert # => {100=>\"a\", 200=>\"b\"} merge , update , merge! \u0130ki Hash\u2019i birbiryle birle\u015ftirmek i\u00e7in merge kullan\u0131l\u0131r. h1 = { \"a\" => 100 , \"b\" => 200 } h2 = { \"x\" => 1 , \"y\" => 2 , \"z\" => 3 } h1 . merge ( h2 ) # => {\"a\"=>100, \"b\"=>200, \"x\"=>1, \"y\"=>2, \"z\"=>3} h1 # => {\"a\"=>100, \"b\"=>200} Dikkat ettiyseniz h1 ile h2 yi birle\u015ftirdik ama h1 in orijinal de\u011ferini bozmad\u0131k. E\u011fer bu birle\u015fmenin kal\u0131c\u0131 olmas\u0131n\u0131 isteseydik ya update ya da merge! kullanmam\u0131z gerekecekti! h1 = { \"a\" => 100 , \"b\" => 200 } h2 = { \"x\" => 1 , \"y\" => 2 , \"z\" => 3 } h1 . update ( h2 ) # => {\"a\"=>100, \"b\"=>200, \"x\"=>1, \"y\"=>2, \"z\"=>3} h1 # => {\"a\"=>100, \"b\"=>200, \"x\"=>1, \"y\"=>2, \"z\"=>3} h1 = { \"a\" => 100 , \"b\" => 200 } h2 = { \"x\" => 1 , \"y\" => 2 , \"z\" => 3 } h1 . merge! ( h2 ) # => {\"a\"=>100, \"b\"=>200, \"x\"=>1, \"y\"=>2, \"z\"=>3} h1 # => {\"a\"=>100, \"b\"=>200, \"x\"=>1, \"y\"=>2, \"z\"=>3} replace Hash\u2019in i\u00e7eri\u011fini ba\u015fka bir Hash ile de\u011fi\u015ftirmek i\u00e7in kullan\u0131l\u0131r. Asl\u0131nda varolan Hash\u2019i ba\u015fka bir Hash\u2019e \u00e7evirmek gibidir. Neden replace kullan\u0131l\u0131yor? Tamamen haf\u0131zadaki adresleme ile ilgili. replace kullan\u0131ld\u0131\u011f\u0131 zaman, ayn\u0131 Hash kullan\u0131l\u0131yor, yeni bir Hash instance\u2019\u0131 yarat\u0131lm\u0131yor. h1 = { \"a\" => 100 , \"b\" => 200 , \"c\" => 0 } h1 . __id__ # => 70320602334320 Haf\u0131zadaki h1 Hash\u2019nin nesne referans\u0131 : 70320602334320. \u015eimdir replace ile de\u011ferlerini de\u011fi\u015ftirelim: h1 . replace ({ \"foo\" => 1 , \"bar\" => 2 }) h1 # => {\"foo\"=>1, \"bar\"=>2} h1 . __id__ # => 70320602334320 Referanslar\u0131 ayn\u0131 : 70320602334320 . E\u011fer direkt olarak atama yapsakd\u0131k h1 gibi g\u00f6r\u00fcnen ama bamba\u015fka yepyeni bir Hash\u2019imiz olacakt\u0131. h1 = { \"foo\" => 1 , \"bar\" => 2 } h1 . __id__ # => 70216424232360 \u0130terasyon ve Block Kullan\u0131m\u0131 Ayn\u0131 Array\u2019lerdeki gibi Hash\u2019lerde de iterasyon ve block kullanmak m\u00fcmk\u00fcn. each , each_pair , each_value , each_key each ve each_pair karde\u015f gibidirler: h = { \"a\" => 100 , \"b\" => 200 , \"c\" => 0 } h . each { | key , value | puts \"key: #{ key } , value: #{ value } \" } h . each_pair { | key , value | puts \"key: #{ key } , value: #{ value } \" } # key: a, value: 100 # key: b, value: 200 # key: c, value: 0 each_value sadece value , each_key de sadece key d\u00f6ner. h = { \"a\" => 100 , \"b\" => 200 , \"c\" => 0 } h . each_value { | value | puts \"value: #{ value } \" } # value: 100 # value: 200 # value: 0 h . each_key { | key | puts \"key: #{ key } \" } # key: a # key: b # key: c each_entry , each_slice , each_cons Hash\u2019deki key-value \u00e7ifti Array \u015feklinde bir entry olur: h = { \"a\" => 100 , \"b\" => 200 , \"c\" => 0 } h . each_entry { | o | puts \"o: #{ o } \" } # o: [\"a\", 100] # o: [\"b\", 200] # o: [\"c\", 0] each_slice ile entry \u2019leri par\u00e7ac\u0131klara ay\u0131r\u0131r\u0131z: h = { \"a\" => 100 , \"b\" => 200 , \"c\" => 0 } # 2\u2019li dilimlere ay\u0131rd\u0131k h . each_slice ( 2 ){ | s | puts \"slice: #{ s } \" } # slice: [[\"a\", 100], [\"b\", 200]] # slice: [[\"c\", 0]] each_cons ise each_slice gibi \u00e7al\u0131\u015f\u0131r ama fark\u0131 \u00f6rnekteki gibidir: h = { \"a\" => 100 , \"b\" => 200 , \"c\" => 0 } h . each_cons ( 2 ){ | s | puts \"grup: #{ s } \" } # grup: [[\"a\", 100], [\"b\", 200]] # grup: [[\"b\", 200], [\"c\", 0]] Neticede, 3 key-value \u00e7ifti vard\u0131. 2 \u2019li gruplad\u0131k ama sonu\u00e7 each_slice daki gibi d\u00f6nmedi. [\"b\", 200] tekrar etti, \u00e7\u0131kt\u0131 gruplamas\u0131 mutlaka 2 eleman i\u00e7erdi. default_proc , default_proc= Konunun ba\u015f\u0131nda varsay\u0131lan de\u011fer atamas\u0131 yaparken \u015f\u00f6yle bir \u00f6rnek vermi\u015ftik: h = Hash . new { | hash , key | hash [ key ] = \"User: #{ key } \" } e\u011fer; h . default_proc # => #<Proc:0x007f85f2250fd8@-:7> deseydik, bu Hash\u2019e ait Proc u g\u00f6rm\u00fc\u015f olurduk. Yani bu Hash i\u00e7in varsay\u0131lan i\u015flem prosed\u00fcr\u00fcn\u00fc tan\u0131mlam\u0131\u015f olduk asl\u0131nda. \u00d6rne\u011fi biraz geni\u015fletelim: h = Hash . new { | obj , key | obj [ key ] = key * 4 } # => {} h [ 1 ] # => 4 h [ 2 ] # => 8 h # => {1=>4, 2=>8} Key olarak say\u0131 veriyoruz, gelen say\u0131dan da value \u00fcretiyoruz otomatik olarak. \u0130\u015flemin \u00e7al\u0131\u015fmas\u0131 i\u00e7in bir adet obje ve say\u0131 ge\u00e7memiz gerekiyor parametre olarak. Asl\u0131nda; h . default_proc . call ( Array . new , 9 ) # => 36 h . default_proc . call ( [] , 9 ) # => 36 h . default_proc . call ({}, 9 ) # => 36 \u015feklinde de, Hash\u2019i sanki bir fonksiyon gibi kullan\u0131p i\u015fleyebiliyoruz. Daha sonra, \u00f6nceden tan\u0131mlad\u0131\u011f\u0131m\u0131z bu prosed\u00fcr\u00fc de\u011fi\u015ftirmek istersek default_proc= methodunu kullan\u0131yoruz: h = Hash . new { | hash , key | hash [ key ] = \"User: #{ key } \" } h . default_proc # => #<Proc:0x007feea39bbd80@-:7> h [ 1 ] # => \"User: 1\" # Yeni prosed\u00fcr veriyoruz h . default_proc = proc do | hash , key | hash [ key ] = \"hello #{ key } \" end h # => {1=>\"User: 1\"} h [ 2 ] # => \"hello 2\" h # => {1=>\"User: 1\", 2=>\"hello 2\"} compare_by_identity , compare_by_identity? Hash\u2019in key ve value\u2019leri birbirine benziyor mu? h = { \"a\" => 1 , \"b\" => 2 , :c => \"c\" } h [ \"a\" ] # => 1 h . compare_by_identity? # => false h . compare_by_identity # => {\"a\"=>1, \"b\"=>2, :c=>\"c\"} h . compare_by_identity? # => true # acaba key ile value benziyormu? h [ \"a\" ] # => nil # burada benzer :) h [ :c ] # => \"c\"","title":"Hash"},{"location":"bolum-04/05-hash/#hash","text":"Pek \u00e7ok dilde Dictionary olarak ge\u00e7en, Array\u2019imsi, hatta Associative Array de denir, Key - Value \u00e7ifti bar\u0131nd\u0131ran yine Array\u2019e benzeyen ba\u015fka bir ta\u015f\u0131y\u0131c\u0131d\u0131r. Key - Value dedi\u011fimiz \u015fey ise; { key1 : \"value1\" , key2 : \"value2\" , .... } \u015feklindedir. Yukar\u0131daki \u00f6rnek, yeni syntax\u2019\u0131 kullan\u0131r. Ruby programc\u0131lar\u0131n\u0131n al\u0131\u015f\u0131k oldu\u011fu \u00f6rnek: { \"key1\" => \"value1\" , \"key2\" => \"value2\" , ... } ya da { :key1 => \"value1\" , :key2 => \"value2\" , ... } \u015feklindedir. Hepsi ayn\u0131 kap\u0131ya \u00e7\u0131kar... Array\u2019deki s\u0131ra ( index ) mant\u0131\u011f\u0131 burada key \u2019ler ile oluyor gibi d\u00fc\u015f\u00fcnebilirsiniz. Key\u2019ler unique \u2019dir yani bir Hash i\u00e7inde 2 tane ayn\u0131 key \u2019den olamaz. Hash\u2019de sonu\u00e7ta bir class oldu\u011fu i\u00e7in new method\u2019u ile Hash\u2019i olu\u015fturabiliriz; Hash . new # => {} Ayn\u0131 Array\u2019deki gibi Hash\u2019in de h\u0131zl\u0131 olu\u015furma yolu var : h = {} . Hemen Hash\u2019in nereden geldi\u011fine bakal\u0131m: Hash . class # => Class Hash . class . superclass # => Module Hash . class . superclass . superclass # => Object Hash . class . superclass . superclass . superclass # => BasicObject Hash . class . superclass . superclass . superclass . superclass # => nil Dikkat ettiyseniz Hash\u2019in bir \u00fcst s\u0131n\u0131f\u0131 Module . Ayn\u0131 Array\u2019deki gibi. Peki bu mod\u00fcller nelermi\u015f? Hash . included_modules # => [Enumerable, Kernel] E\u011fer Hash\u2019i olu\u015ftururken default de\u011fer ge\u00e7ersek, tan\u0131ms\u0131z olan key i\u00e7in de\u011fer atam\u0131\u015f oluruz: h = Hash . new ( \"Tan\u0131ms\u0131z\" ) # => {} h [ :isim ] = \"U\u011fur\" # => \"U\u011fur\" h # => {:isim=>\"U\u011fur\"} h [ :soyad ] # => \"Tan\u0131ms\u0131z\" h . default # => \"Tan\u0131ms\u0131z\" Olmayan bir key\u2019e ula\u015fmak istedi\u011fimizde \"Tan\u0131ms\u0131z\" de\u011feri geldi. E\u011fer bu default de\u011feri atamasayd\u0131 ne olacakt\u0131? h = Hash . new # => {} h [ :isim ] = \"U\u011fur\" # => \"U\u011fur\" h [ :soyad ] # => nil nil gelecekti. Biraz sonra g\u00f6rece\u011fimiz fetch method\u2019unu l\u00fctfen akl\u0131n\u0131zda tutun! Default de\u011fer tan\u0131mlama mant\u0131\u011f\u0131nda; h = Hash . new { | hash , key | hash [ key ] = \"User: #{ key } \" } h [ \"vigo\" ] # => \"User: vigo\" h [ \"foobar\" ] # => \"User: foobar\" h [ \"animal\" ] = \"horse\" # => \"horse\" h # => {\"vigo\"=>\"User: vigo\", \"foobar\"=>\"User: foobar\", \"animal\"=>\"horse\"} bu tarz ilgin\u00e7 bir y\u00f6ntem de kullan\u0131labilir. Normalde vigo key\u2019ine kar\u015f\u0131l\u0131k value yok ama Hash in new method\u2019unda yapt\u0131\u011f\u0131m\u0131z bir blok i\u015flemi ile olmayan key i\u00e7in de\u011fer atamas\u0131 yapt\u0131\u011f\u0131m\u0131z gibi key-value atamas\u0131 da yapabiliyoruz.","title":"Hash"},{"location":"bolum-04/05-hash/#hash-class-methodlar","text":"Hash\u2019den bir instance olu\u015fturmadan kulland\u0131\u011f\u0131m\u0131z methodlard\u0131r. Hash[ key, value, ... ] -> yeni_hash Hash[ [ [key, value], ... ] ] -> yeni_hash Hash[ object ] -> yeni_hash Hash [ \"user_count\" , 5 ] # => {\"user_count\"=>5} Hash [ [[ \"user_count\" , 5 ] , [ \"active_users\" , 2 ]] ] # => {\"user_count\"=>5, \"active_users\"=>2} Hash [ \"user_count\" => 5 , \"active_users\" => 2 ] # => {\"user_count\"=>5, \"active_users\"=>2} Hash.new Zaten ilgili \u00f6rnekleri ba\u015fta vermi\u015ftik, tekrar edelim: h = Hash . new h # => {} h [ \"user_count\" ] = 5 h # => {\"user_count\"=>5} h = Hash . new { | hash , key | hash [ key ] = \"User ID: #{ key } \" } h [ \"1\" ] # => \"User ID: 1\" h [ \"2\" ] # => \"User ID: 2\" h # => {\"1\"=>\"User ID: 1\", \"2\"=>\"User ID: 2\"} try_convert(obj) \u2192 hash ya da nil Hash\u2019e d\u00f6n\u00fc\u015febilme ihtimali olan nesneyi Hash haline \u00e7evirir. Hash . try_convert ({ \"user_count\" => 5 }) # => {\"user_count\"=>5} Hash . try_convert ( \"user_count=>5\" ) # => nil","title":"Hash Class Method\u2019lar\u0131"},{"location":"bolum-04/05-hash/#hash-instance-methodlar","text":"Hash instance\u2019\u0131 olu\u015fturduktan sonra kullanaca\u011f\u0131m\u0131z method\u2019lard\u0131r. \u00d6nce klasik de\u011fer okuma ve de\u011fer atama i\u015flerine bakal\u0131m. Zaten bu noktaya kadar kabaca biliyoruz nas\u0131l de\u011fer atar\u0131z geri okuruz. Ama biraz kafalar\u0131 kar\u0131\u015ft\u0131rmak istiyorum: h = { username : \"vigo\" , password : \"1234\" } # => {:username=>\"vigo\", :password=>\"1234\"} Yukar\u0131daki gibi bir Hash \u2019imiz var. Dikkat ettiyseniz, key,value olarak bakt\u0131\u011f\u0131m\u0131zda :username ve :password diye ba\u015flayan key ler var... Hatta: h . keys # => [:username, :password] diye de sa\u011flamas\u0131n\u0131 yapar\u0131z. Peki, yeni bir key tan\u0131mlasak? h[\"useremail\"] = \"vigo@example.com\" . Tekrar bakal\u0131m key lere: h . keys # => [:username, :password, \"useremail\"] Bir sonraki b\u00f6l\u00fcmde kar\u015f\u0131m\u0131za \u00e7\u0131kacak olan Symbol tipi ile kar\u015f\u0131 kar\u015f\u0131yay\u0131z. Sadece symbol mu? hay\u0131r, kar\u0131\u015f\u0131k keyler var elimizde. Hemen sa\u011flamas\u0131n\u0131 yapal\u0131m: h . keys . map ( & :class ) # => [Symbol, Symbol, String] \u0130lk iki key Symbol iken son key String oldu. Demek ki Hash i\u00e7ine key cinsi olarak kar\u015f\u0131k atama yapabiliniyor. Biraz s\u0131k\u0131nt\u0131l\u0131 bir durum ama genel k\u00fclt\u00fcr mahiyetinde akl\u0131n\u0131zda tutun bunu! \u015eimdi genel olarak Hash hangi method\u2019lara sahip hemen bakal\u0131m: h = Hash . new h . methods # => [:rehash, :to_hash, :to_h, :to_a, :inspect, :to_s, :==, :[], :hash, :eql?, :fetch, :[]=, :store, :default, :default=, :default_proc, :default_proc=, :key, :index, :size, :length, :empty?, :each_value, :each_key, :each_pair, :each, :keys, :values, :values_at, :shift, :delete, :delete_if, :keep_if, :select, :select!, :reject, :reject!, :clear, :invert, :update, :replace, :merge!, :merge, :assoc, :rassoc, :flatten, :include?, :member?, :has_key?, :has_value?, :key?, :value?, :compare_by_identity, :compare_by_identity?, :entries, :sort, :sort_by, :grep, :count, :find, :detect, :find_index, :find_all, :collect, :map, :flat_map, :collect_concat, :inject, :reduce, :partition, :group_by, :first, :all?, :any?, :one?, :none?, :min, :max, :minmax, :min_by, :max_by, :minmax_by, :each_with_index, :reverse_each, :each_entry, :each_slice, :each_cons, :each_with_object, :zip, :take, :take_while, :drop, :drop_while, :cycle, :chunk, :slice_before, :lazy, :nil?, :===, :=~, :!~, :<=>, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :singleton_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__] Dikkat ettiyseniz method\u2019lar\u0131n bir k\u0131sm\u0131 Array ile ayn\u0131 \u00e7\u00fcnki ikisi de Enumerable mod\u00fcl\u00fcn\u00fc kullan\u0131yor. \u015eimdi s\u0131radan ba\u015flayal\u0131m! \u00d6nceki Array b\u00f6l\u00fcm\u00fcnde anlatt\u0131\u011f\u0131m ortak method\u2019lar\u0131 pas ge\u00e7ece\u011fim! rehash Hash\u2019e key olarak Array verebiliriz. Yani h[key] = value mant\u0131\u011f\u0131nda key olarak bildi\u011finiz Array ge\u00e7ebiliriz. a = [ \"a\" , \"b\" ] c = [ \"c\" , \"d\" ] h = { a => 100 , c => 300 } # => {[\"a\", \"b\"]=>100, [\"c\", \"d\"]=>300} h Hash\u2019inin keyleri nedir? h . keys # => [[\"a\", \"b\"], [\"c\", \"d\"]] 2 key\u2019i var biri [\"a\", \"b\"] ve di\u011feri [\"c\", \"d\"] nas\u0131l yani? h [ a ] # => 100 h [[ \"a\" , \"b\" ]] # => 100 h [ c ] # => 300 h [[ \"c\" , \"d\" ]] # => 300 \u015eimdi i\u015fleri kar\u0131\u015ft\u0131ral\u0131m. a Array\u2019inin ilk de\u011ferini de\u011fi\u015ftirelim. Bakal\u0131m h ne olacak? a [ 0 ] = \"v\" # => \"v\" a # => [\"v\", \"b\"] h [ a ] # => nil ???????? h[a] patlad\u0131? nil d\u00f6nd\u00fc. \u0130\u015fte \u015fimdi imdad\u0131m\u0131za ne yeti\u015fecek? h . rehash # => {[\"v\", \"b\"]=>100, [\"c\", \"d\"]=>300} h [ a ] # => 100 to_hash , to_h , to_a , to_s Tip d\u00f6n\u00fc\u015ft\u00fcrmeleri i\u00e7in kullan\u0131l\u0131rlar. to_h ve to_hash e\u011fer kendisi Hash ise sonu\u00e7 yine kendisi olur. to_a ise Hash\u2019den Array yapmak i\u00e7in kullan\u0131l\u0131r. Tahmin edece\u011finiz gibi to_s de String\u2019e \u00e7evirmek i\u00e7in kullan\u0131l\u0131r. h = { :foo => \"bar\" } h # => {:foo=>\"bar\"} h . to_hash # => {:foo=>\"bar\"} h . to_h # => {:foo=>\"bar\"} [ \"foo\" , \"bar\" ]. respond_to? ( :to_h ) # => true [[ :foo , \"bar\" ]]. to_h # => {:foo=>\"bar\"} [[ \"a\" , 1 ] , [ \"b\" , 2 ]]. to_h # => {\"a\"=>1, \"b\"=>2} h . to_a # => [[:foo, \"bar\"]] h . to_s # => \"{:foo=>\\\"bar\\\"}\" == ve eql? E\u015fitlik Hash i\u00e7inde key\u2019lerin s\u0131ras\u0131 e\u015fitlik kontrol\u00fcnde \u00f6nemli de\u011fildir. \u0130\u00e7erik \u00f6nemlidir. E\u015fitlik kontrol\u00fc i\u00e7in kullan\u0131l\u0131rlar. h1 = { \"a\" => 100 , \"c\" => 200 } h2 = { 70 => 350 , \"x\" => 22 , \"y\" => 11 } h3 = { \"y\" => 11 , \"x\" => 22 , 70 => 350 } h1 == h2 # => false h2 == h3 # => true h1 . eql? ( h2 ) # => false h2 . eql? ( h3 ) # => true h2 ile h3 key s\u0131ralar\u0131 farkl\u0131 olmas\u0131na ra\u011fmen i\u00e7erik baz\u0131nda e\u015fittirler. fetch Hash i\u00e7inden sorgu yaparken kullan\u0131l\u0131r. E\u011fer olmayan key \u00e7a\u011f\u0131r\u0131rsan\u0131z exception olu\u015fur. Bu method g\u00fcvenli bir y\u00f6ntemdir. Aksi takdirde nil d\u00f6ner ve kompleks i\u015flerde Silent Fail yani dipsiz kuyuya d\u00fc\u015fer bir t\u00fcrl\u00fc hatan\u0131n yerini bulamazs\u0131n\u0131z! h = { :user => \"vigo\" , :password => \"secret\" } puts h . fetch ( :user ) # \"vigo\" puts h . fetch ( :email ) KeyError : key not found : :email Keza e\u011fer key\u2019e kar\u015f\u0131l\u0131k yoksa default de\u011fer atamas\u0131 yapabilirsiniz: h = { :user => \"vigo\" , :password => \"secret\" } h . fetch ( :user ) # => \"vigo\" h . fetch ( :email , \"Not found\" ) # => \"Not found\" Block kabul etti\u011fi i\u00e7in artistlik hareketler yapmak da m\u00fcmk\u00fcn :) h = { :user => \"vigo\" , :password => \"secret\" } h . fetch ( :email ) { | element | \"key: #{ element } is not defined!\" } # => \"key: email is not defined!\" store Atama yapman\u0131n farkl\u0131 bir y\u00f6ntemidir. h = { :user => \"vigo\" , :password => \"secret\" } h . store ( :email , \"vigo@example.com\" ) # => \"vigo@example.com\" h # => {:user=>\"vigo\", :password=>\"secret\", :email=>\"vigo@example.com\"} # ya da h [ :url ] = \"http://webbox.io\" # => \"http://webbox.io\" h # => {:user=>\"vigo\", :password=>\"secret\", :email=>\"vigo@example.com\", :url=>\"http://webbox.io\"} default , default= Kar\u015f\u0131l\u0131\u011f\u0131 olmayan key ler i\u00e7in varsay\u0131lan de\u011fer atamas\u0131 yap\u0131lm\u0131\u015fsa bunu bulmak i\u00e7in ya da varsay\u0131lan de\u011feri atamak i\u00e7in kullan\u0131l\u0131r. En ba\u015fta benzer i\u015fler yapt\u0131k: h = Hash . new ( 10 ) h [ :user_age ] # => 10 h # => {} h . default # => 10 h . default ( :user_weight ) # => 10 ya da h = Hash . new h # => {} h . default = 100 # => 100 h [ :user_weight ] # => 100 h [ :foo ] # => 100 key Value\u2019den key\u2019i bulmak i\u00e7in kullan\u0131l\u0131r. E\u011fer key\u2019i olmayan bir value kullan\u0131rsan\u0131z sonu\u00e7 nil d\u00f6ner! h = { :user => \"vigo\" , :password => \"secret\" } h . key ( \"vigo\" ) # => :user h . key ( \"foobar\" ) # => nil size , length , count Ayn\u0131 i\u015fi yaparlar, Arrar gibi Hash\u2019in boyunu / uzunlu\u011funu verir. h = { :user => \"vigo\" , :password => \"secret\" } h . length # => 2 h . size # => 2 h . count # => 2","title":"Hash Instance Method\u2019lar\u0131"},{"location":"bolum-04/05-hash/#key-value-kontrolleri","text":"keys , values , values_at Tahmin edece\u011finiz gibi keys ile Hash\u2019e ait key\u2019leri, values ile sadece key\u2019lere kar\u015f\u0131l\u0131k gelen de\u011ferleri, values_at ile verdi\u011fimiz key\u2019lere ait de\u011ferleri al\u0131r\u0131z. h = { :user => \"vigo\" , :password => \"secret\" , :email => \"vigo@foo.com\" } h . keys # => [:user, :password, :email] h . values # => [\"vigo\", \"secret\", \"vigo@foo.com\"] h . values_at ( :user , :password ) # => [\"vigo\", \"secret\"] key? , value? , has_key? , has_value? Soru i\u015fareti ile biten method\u2019lar bize her zaman Boolean yani true ya da false d\u00f6ner demi\u015ftik. Acaba Hash\u2019in i\u00e7inde ilgili key var m\u0131? ya da value var m\u0131? h = { :user => \"vigo\" , :password => \"secret\" , :email => \"vigo@foo.com\" } h . key? ( :user ) # => true h . has_key? ( :user ) # => true h . key? ( :full_name ) # => false h . has_key? ( :full_name ) # => false h . value? ( \"vigo\" ) # => true h . has_value? ( \"vigo\" ) # => true h . value? ( \"lego\" ) # => false h . has_value? ( \"lego\" ) # => false include? , member? key? ya da has_key? ile ayn\u0131 i\u015fi yapar. h = { :user => \"vigo\" , :password => \"secret\" , :email => \"vigo@foo.com\" } h . include? ( :user ) # => true h . member? ( :user ) # => true empty? Hash\u2019in i\u00e7inde eleman var m\u0131 yok mu? { :user => \"vigo\" , :password => \"secret\" , :email => \"vigo@foo.com\" } . empty? # => false {} . empty? # => true all? , any? , one? , none? Array b\u00f6l\u00fcm\u00fcnde g\u00f6rm\u00fc\u015ft\u00fck, Enumerable mod\u00fcl\u00fcnden gelen bu \u00f6zellik aynen Hash\u2019de de kullan\u0131l\u0131yor. all? da t\u00fcm elemanlar, verilen ko\u015fuldan nil ya da false d\u0131\u015f\u0131nda bir \u015fey d\u00f6nmek zorunda, aksi halde sonu\u00e7 false oluyor: # value\u2019su bo\u015f olan var m\u0131? { :user => \"vigo\" , :password => \"secret\" , :email => \"vigo@foo.com\" } . all? { | k , v | v . empty? } # => false { :user => \"\" , :password => \"\" , :email => \"\" } . all? { | k , v | v . empty? } # => true { :user => \"vigo\" , :password => \"\" , :email => \"\" } . all? { | k , v | v . empty? } # => false any? de i\u00e7lerinden biri false ya da nil d\u00f6nmezse sonu\u00e7 true olur. one? da sadece bir tanesi true d\u00f6nmelidir. none da ise block\u2019daki i\u015flem sonucu her eleman i\u00e7in false olmal\u0131d\u0131r. { :is_admin => true , :notifications_enabled => true } . all? { | option , value | value } # => true { :is_admin => true , :notifications_enabled => false } . any? { | option , value | value } # => true { :is_admin => true , :notifications_enabled => false } . one? { | option , value | value } # => true { :is_admin => false , :notifications_enabled => false } . one? { | option , value | value } # => false { :is_admin => false , :notifications_enabled => false } . all? { | option , value | value } # => false { :is_admin => false , :notifications_enabled => false } . none? { | option , value | value } # => true { :is_admin => false , :notifications_enabled => false } . any? { | option , value | value } # => false shift Hash\u2019den key-value \u00e7iftini silmek i\u00e7in kullan\u0131l\u0131r. Her seferinde ilk key-value \u00e7iftini siler. h = { :user => \"vigo\" , :password => \"secret\" , :email => \"vigo@foo.com\" } h . shift # => [:user, \"vigo\"] h # => {:password=>\"secret\", :email=>\"vigo@foo.com\"} h . shift # => [:password, \"secret\"] h # => {:email=>\"vigo@foo.com\"} h . shift # => [:email, \"vigo@foo.com\"] h # => {} delete , delete_if , keep_if Hash\u2019den key kullanarak eleman silmek i\u00e7in delete method\u2019u kullan\u0131l\u0131r. h = { :user => \"vigo\" , :password => \"secret\" , :email => \"vigo@foo.com\" } h . delete ( :user ) # => \"vigo\" h # => {:password=>\"secret\", :email=>\"vigo@foo.com\"} Block kullan\u0131ld\u0131\u011f\u0131nda, e\u011fer olmayan bir key kullan\u0131lm\u0131\u015fsa, bununla ilgili i\u015flem yapmam\u0131z\u0131 sa\u011flar: h . delete ( :phone ){ | key | \"- #{ key } - bulunamad\u0131?\" } # => \"-phone- bulunamad\u0131?\" delete_if de ise direk block kullanarak ko\u015fullu silme i\u015flemi yapabiliyoruz. # 40\u2019dan b\u00fcy\u00fckleri silelim h = { point_a : 10 , point_b : 20 , point_c : 50 } # => {:point_a=>10, :point_b=>20, :point_c=>50} h . delete_if { | k , v | v > 40 } # => {:point_a=>10, :point_b=>20} h # => {:point_a=>10, :point_b=>20} keep_if ise delete_if in tam tersi gibidir. E\u011fer block\u2019daki ko\u015ful true ise key-value \u00e7iftini tutar, aksi halde siler: # 20\u2019dan k\u00fc\u00e7\u00fckleri tutal\u0131m sadece h = { point_a : 10 , point_b : 20 , point_c : 50 } # => {:point_a=>10, :point_b=>20, :point_c=>50} h . keep_if { | k , v | v < 20 } # => {:point_a=>10} h # => {:point_a=>10} invert Hash\u2019in key\u2019leri ile value\u2019lerini yer de\u011fi\u015ftirmek i\u00e7in kullan\u0131l\u0131r. h = { \"a\" => 100 , \"b\" => 200 } # => {\"a\"=>100, \"b\"=>200} h . keys # => [\"a\", \"b\"] h . invert # => {100=>\"a\", 200=>\"b\"} merge , update , merge! \u0130ki Hash\u2019i birbiryle birle\u015ftirmek i\u00e7in merge kullan\u0131l\u0131r. h1 = { \"a\" => 100 , \"b\" => 200 } h2 = { \"x\" => 1 , \"y\" => 2 , \"z\" => 3 } h1 . merge ( h2 ) # => {\"a\"=>100, \"b\"=>200, \"x\"=>1, \"y\"=>2, \"z\"=>3} h1 # => {\"a\"=>100, \"b\"=>200} Dikkat ettiyseniz h1 ile h2 yi birle\u015ftirdik ama h1 in orijinal de\u011ferini bozmad\u0131k. E\u011fer bu birle\u015fmenin kal\u0131c\u0131 olmas\u0131n\u0131 isteseydik ya update ya da merge! kullanmam\u0131z gerekecekti! h1 = { \"a\" => 100 , \"b\" => 200 } h2 = { \"x\" => 1 , \"y\" => 2 , \"z\" => 3 } h1 . update ( h2 ) # => {\"a\"=>100, \"b\"=>200, \"x\"=>1, \"y\"=>2, \"z\"=>3} h1 # => {\"a\"=>100, \"b\"=>200, \"x\"=>1, \"y\"=>2, \"z\"=>3} h1 = { \"a\" => 100 , \"b\" => 200 } h2 = { \"x\" => 1 , \"y\" => 2 , \"z\" => 3 } h1 . merge! ( h2 ) # => {\"a\"=>100, \"b\"=>200, \"x\"=>1, \"y\"=>2, \"z\"=>3} h1 # => {\"a\"=>100, \"b\"=>200, \"x\"=>1, \"y\"=>2, \"z\"=>3} replace Hash\u2019in i\u00e7eri\u011fini ba\u015fka bir Hash ile de\u011fi\u015ftirmek i\u00e7in kullan\u0131l\u0131r. Asl\u0131nda varolan Hash\u2019i ba\u015fka bir Hash\u2019e \u00e7evirmek gibidir. Neden replace kullan\u0131l\u0131yor? Tamamen haf\u0131zadaki adresleme ile ilgili. replace kullan\u0131ld\u0131\u011f\u0131 zaman, ayn\u0131 Hash kullan\u0131l\u0131yor, yeni bir Hash instance\u2019\u0131 yarat\u0131lm\u0131yor. h1 = { \"a\" => 100 , \"b\" => 200 , \"c\" => 0 } h1 . __id__ # => 70320602334320 Haf\u0131zadaki h1 Hash\u2019nin nesne referans\u0131 : 70320602334320. \u015eimdir replace ile de\u011ferlerini de\u011fi\u015ftirelim: h1 . replace ({ \"foo\" => 1 , \"bar\" => 2 }) h1 # => {\"foo\"=>1, \"bar\"=>2} h1 . __id__ # => 70320602334320 Referanslar\u0131 ayn\u0131 : 70320602334320 . E\u011fer direkt olarak atama yapsakd\u0131k h1 gibi g\u00f6r\u00fcnen ama bamba\u015fka yepyeni bir Hash\u2019imiz olacakt\u0131. h1 = { \"foo\" => 1 , \"bar\" => 2 } h1 . __id__ # => 70216424232360","title":"Key, Value Kontrolleri"},{"location":"bolum-04/05-hash/#iterasyon-ve-block-kullanm","text":"Ayn\u0131 Array\u2019lerdeki gibi Hash\u2019lerde de iterasyon ve block kullanmak m\u00fcmk\u00fcn. each , each_pair , each_value , each_key each ve each_pair karde\u015f gibidirler: h = { \"a\" => 100 , \"b\" => 200 , \"c\" => 0 } h . each { | key , value | puts \"key: #{ key } , value: #{ value } \" } h . each_pair { | key , value | puts \"key: #{ key } , value: #{ value } \" } # key: a, value: 100 # key: b, value: 200 # key: c, value: 0 each_value sadece value , each_key de sadece key d\u00f6ner. h = { \"a\" => 100 , \"b\" => 200 , \"c\" => 0 } h . each_value { | value | puts \"value: #{ value } \" } # value: 100 # value: 200 # value: 0 h . each_key { | key | puts \"key: #{ key } \" } # key: a # key: b # key: c each_entry , each_slice , each_cons Hash\u2019deki key-value \u00e7ifti Array \u015feklinde bir entry olur: h = { \"a\" => 100 , \"b\" => 200 , \"c\" => 0 } h . each_entry { | o | puts \"o: #{ o } \" } # o: [\"a\", 100] # o: [\"b\", 200] # o: [\"c\", 0] each_slice ile entry \u2019leri par\u00e7ac\u0131klara ay\u0131r\u0131r\u0131z: h = { \"a\" => 100 , \"b\" => 200 , \"c\" => 0 } # 2\u2019li dilimlere ay\u0131rd\u0131k h . each_slice ( 2 ){ | s | puts \"slice: #{ s } \" } # slice: [[\"a\", 100], [\"b\", 200]] # slice: [[\"c\", 0]] each_cons ise each_slice gibi \u00e7al\u0131\u015f\u0131r ama fark\u0131 \u00f6rnekteki gibidir: h = { \"a\" => 100 , \"b\" => 200 , \"c\" => 0 } h . each_cons ( 2 ){ | s | puts \"grup: #{ s } \" } # grup: [[\"a\", 100], [\"b\", 200]] # grup: [[\"b\", 200], [\"c\", 0]] Neticede, 3 key-value \u00e7ifti vard\u0131. 2 \u2019li gruplad\u0131k ama sonu\u00e7 each_slice daki gibi d\u00f6nmedi. [\"b\", 200] tekrar etti, \u00e7\u0131kt\u0131 gruplamas\u0131 mutlaka 2 eleman i\u00e7erdi. default_proc , default_proc= Konunun ba\u015f\u0131nda varsay\u0131lan de\u011fer atamas\u0131 yaparken \u015f\u00f6yle bir \u00f6rnek vermi\u015ftik: h = Hash . new { | hash , key | hash [ key ] = \"User: #{ key } \" } e\u011fer; h . default_proc # => #<Proc:0x007f85f2250fd8@-:7> deseydik, bu Hash\u2019e ait Proc u g\u00f6rm\u00fc\u015f olurduk. Yani bu Hash i\u00e7in varsay\u0131lan i\u015flem prosed\u00fcr\u00fcn\u00fc tan\u0131mlam\u0131\u015f olduk asl\u0131nda. \u00d6rne\u011fi biraz geni\u015fletelim: h = Hash . new { | obj , key | obj [ key ] = key * 4 } # => {} h [ 1 ] # => 4 h [ 2 ] # => 8 h # => {1=>4, 2=>8} Key olarak say\u0131 veriyoruz, gelen say\u0131dan da value \u00fcretiyoruz otomatik olarak. \u0130\u015flemin \u00e7al\u0131\u015fmas\u0131 i\u00e7in bir adet obje ve say\u0131 ge\u00e7memiz gerekiyor parametre olarak. Asl\u0131nda; h . default_proc . call ( Array . new , 9 ) # => 36 h . default_proc . call ( [] , 9 ) # => 36 h . default_proc . call ({}, 9 ) # => 36 \u015feklinde de, Hash\u2019i sanki bir fonksiyon gibi kullan\u0131p i\u015fleyebiliyoruz. Daha sonra, \u00f6nceden tan\u0131mlad\u0131\u011f\u0131m\u0131z bu prosed\u00fcr\u00fc de\u011fi\u015ftirmek istersek default_proc= methodunu kullan\u0131yoruz: h = Hash . new { | hash , key | hash [ key ] = \"User: #{ key } \" } h . default_proc # => #<Proc:0x007feea39bbd80@-:7> h [ 1 ] # => \"User: 1\" # Yeni prosed\u00fcr veriyoruz h . default_proc = proc do | hash , key | hash [ key ] = \"hello #{ key } \" end h # => {1=>\"User: 1\"} h [ 2 ] # => \"hello 2\" h # => {1=>\"User: 1\", 2=>\"hello 2\"} compare_by_identity , compare_by_identity? Hash\u2019in key ve value\u2019leri birbirine benziyor mu? h = { \"a\" => 1 , \"b\" => 2 , :c => \"c\" } h [ \"a\" ] # => 1 h . compare_by_identity? # => false h . compare_by_identity # => {\"a\"=>1, \"b\"=>2, :c=>\"c\"} h . compare_by_identity? # => true # acaba key ile value benziyormu? h [ \"a\" ] # => nil # burada benzer :) h [ :c ] # => \"c\"","title":"\u0130terasyon ve Block Kullan\u0131m\u0131"},{"location":"bolum-04/06-symbol/","text":"Symbol Symbol ( sembol ) Ruby\u2019e ait \u00f6zel bir nesnedir. Bir t\u00fcr placeholder ( yer tutucu ) g\u00f6revindedir. : i\u015fareti ile ba\u015flayan her \u015fey sembold\u00fcr. Sembol\u00fcn, de\u011fi\u015fkenden en \u00f6nemli fark\u0131 tekil olmas\u0131d\u0131r. Yani sembole atanan de\u011fi\u015fkenden haf\u0131zada 1 adet bulunur. user = \"vigo\" user . object_id # => 70122132113780 # \u015fimdi ba\u015fka de\u011fer atayal\u0131m user = \"bronx\" user . object_id # => 70122132113340 # object_id de\u011fi\u015fti! E\u011fer Symbol kullansayd\u0131k: user = :vigo user . object_id # => 420488 user = :bronx user . object_id # => 420648 user de\u011fi\u015fkeninin de\u011feri Symbol cinsinden oldu\u011fu i\u00e7in, art\u0131k haf\u0131zada sabit bir yer ayr\u0131lm\u0131\u015f oldu bu i\u015f i\u00e7in. De\u011fer de\u011fi\u015fse bile haf\u0131zadaki adreslendi\u011fi alan de\u011fi\u015fmemi\u015f oluyor :) String olarak atanm\u0131\u015f de\u011fi\u015fkeni de Symbol\u2019e \u00e7evirmek m\u00fcmk\u00fcn: full_name = \"U\u011fur\" # => \"U\u011fur\" full_name . to_sym # => :U\u011fur full_name == :U\u011fur . id2name # => true user_full_name = :U\u011fur # => :U\u011fur user_full_name . object_id # => 420428 :is_user_admin . id2name # => \"is_user_admin\" :is_user_admin . to_s # => \"is_user_admin\" Symbol\u2019ler, de\u011fi\u015fkenler gibi direkt atama y\u00f6ntemiyle yani :a = 1 gibi bir \u015fekilde \u00e7al\u0131\u015fmazlar. E\u011fer bir String\u2019den Symbol \u00fcretmek isterseniz to_sym methodunu kullanman\u0131z gerekiyor. Haf\u0131zay\u0131 idareli kullanmak, bo\u015fu bo\u015funa de\u011fi\u015fken kirli\u011fi yaratmamak gibi konularda tercih edilir. Keza Hash\u2019lerde de KEY atamas\u0131 Symbol olarak yap\u0131l\u0131yor bu t\u00fcr h\u0131z / tasarruf i\u015fleri i\u00e7in. { :user => \"vigo\" }","title":"Symbol"},{"location":"bolum-04/06-symbol/#symbol","text":"Symbol ( sembol ) Ruby\u2019e ait \u00f6zel bir nesnedir. Bir t\u00fcr placeholder ( yer tutucu ) g\u00f6revindedir. : i\u015fareti ile ba\u015flayan her \u015fey sembold\u00fcr. Sembol\u00fcn, de\u011fi\u015fkenden en \u00f6nemli fark\u0131 tekil olmas\u0131d\u0131r. Yani sembole atanan de\u011fi\u015fkenden haf\u0131zada 1 adet bulunur. user = \"vigo\" user . object_id # => 70122132113780 # \u015fimdi ba\u015fka de\u011fer atayal\u0131m user = \"bronx\" user . object_id # => 70122132113340 # object_id de\u011fi\u015fti! E\u011fer Symbol kullansayd\u0131k: user = :vigo user . object_id # => 420488 user = :bronx user . object_id # => 420648 user de\u011fi\u015fkeninin de\u011feri Symbol cinsinden oldu\u011fu i\u00e7in, art\u0131k haf\u0131zada sabit bir yer ayr\u0131lm\u0131\u015f oldu bu i\u015f i\u00e7in. De\u011fer de\u011fi\u015fse bile haf\u0131zadaki adreslendi\u011fi alan de\u011fi\u015fmemi\u015f oluyor :) String olarak atanm\u0131\u015f de\u011fi\u015fkeni de Symbol\u2019e \u00e7evirmek m\u00fcmk\u00fcn: full_name = \"U\u011fur\" # => \"U\u011fur\" full_name . to_sym # => :U\u011fur full_name == :U\u011fur . id2name # => true user_full_name = :U\u011fur # => :U\u011fur user_full_name . object_id # => 420428 :is_user_admin . id2name # => \"is_user_admin\" :is_user_admin . to_s # => \"is_user_admin\" Symbol\u2019ler, de\u011fi\u015fkenler gibi direkt atama y\u00f6ntemiyle yani :a = 1 gibi bir \u015fekilde \u00e7al\u0131\u015fmazlar. E\u011fer bir String\u2019den Symbol \u00fcretmek isterseniz to_sym methodunu kullanman\u0131z gerekiyor. Haf\u0131zay\u0131 idareli kullanmak, bo\u015fu bo\u015funa de\u011fi\u015fken kirli\u011fi yaratmamak gibi konularda tercih edilir. Keza Hash\u2019lerde de KEY atamas\u0131 Symbol olarak yap\u0131l\u0131yor bu t\u00fcr h\u0131z / tasarruf i\u015fleri i\u00e7in. { :user => \"vigo\" }","title":"Symbol"},{"location":"bolum-04/07-class/","text":"Class (S\u0131n\u0131f) Ruby, Object-Oriented ( OO ) bir dil oldu\u011fu i\u00e7in, methodlar\u0131 de\u011fi\u015fkenleri ve benzeri \u015feyleri i\u00e7inde bar\u0131ndan bir t\u00fcr ta\u015f\u0131y\u0131c\u0131ya ihtiya\u00e7 duyar. \u0130\u015fte bu ta\u015f\u0131y\u0131c\u0131ya Class ya da s\u0131n\u0131f diyoruz. Asl\u0131nda ben t\u00fcr demeyi tercih ediyorum s\u0131n\u0131f yerine. Zaten \u00f6nceki konularda Class Methods , Instance Methods gibi kavramlara girmi\u015ftik. Class\u2019lar birbirinden t\u00fcreyebilir ( Hani class.superclass \u015feklinde analizler yapm\u0131\u015ft\u0131k ) Teknik olarak bir dosyada birden fazla Class tan\u0131mlamas\u0131 yap\u0131labilir. \u00d6rne\u011fin, my_class.rb adl\u0131 bir dosya i\u00e7inde farkl\u0131 farkl\u0131 Class tan\u0131mlamalar\u0131 olabilir; class MyClass end class OtherClass end a = MyClass . new # => #<MyClass:0x007ffa2b09b758> b = OtherClass . new # => #<OtherClass:0x007ffa2b09b3c0> Class tek ba\u015f\u0131na bir nesne ( Obje ) bu bak\u0131mdan instantiate etmeseniz bile ( Yani a = Array.new gibi ) kullanabilece\u011finiz bir \u015feydir. Class\u2019lar\u0131n di\u011fer bir \u00f6zelli\u011fi de a\u00e7\u0131k olmas\u0131d\u0131r. Ruby\u2019nin bence en harika \u00f6zelli\u011fi, built-in yani dilin \u00e7ekirde\u011finden gelen Class\u2019lara bile method / property eklemeniz m\u00fcmk\u00fcnd\u00fcr. Bu konular\u0131 Monkey Patching k\u0131sm\u0131nda detayl\u0131 g\u00f6rece\u011fiz. En basit tan\u0131m\u0131yla Class a\u015fa\u011f\u0131daki gibidir: class Merhaba def initialize ( isim ) @isim = isim end def selam_sana \"Selam sana, #{ @isim } \" end end hey = Merhaba . new \"U\u011fur\" hey . selam_sana # => \"Selam sana, U\u011fur\" initialize methodu, Class\u2019dan ilk \u00f6rnek t\u00fcredildi\u011finde ( yani bir instance olu\u015fturuldu\u011funda ) tetiklenir ve bir t\u00fcr Class ile ilgili \u00f6n tan\u0131mlamalar\u0131n yap\u0131ld\u0131\u011f\u0131 alan konumundad\u0131r. Benzer dillerdeki class constructor \u2019\u0131 gibi d\u00fc\u015f\u00fcn\u00fclebilir. @isim ise Instance Variable yani Class\u2019tan t\u00fcreyen nesneye ait de\u011fi\u015fkendir. selam_sana ise bu Class\u2019\u0131n bir method\u2019udur. hey de\u011fi\u015fkeni, Merhaba Class\u2019\u0131ndan t\u00fcremi\u015f bir Instance \u2019d\u0131r. Merhaba s\u0131n\u0131f\u0131ndaki t\u00fcm method\u2019lar inherit yani miras olarak hey nesnesine ge\u00e7mi\u015ftir. Class\u2019\u0131 tan\u0131mlarken ister klasik ister block y\u00f6ntemini kullanabilirsiniz. Klasik y\u00f6ntem: class Person end jack = Person . new # => #<Person:0x007fb0521a4820> Block ise; Person = Class . new do end jack = Person . new # => #<Person:0x007fc42c0c8648> \u015feklindedir. Class isimleri B\u00fcy\u00fck harfle ba\u015flar. Public Instance Method\u2019lar\u0131 Bir Class\u2019tan t\u00fcreyen \u015feye Instance diyoruz. Ruby\u2019de Class\u2019lar first-class objects olarak ge\u00e7er yani birinci s\u0131n\u0131f nesnelerdir. Bu da \u015fu anlama gelir, asl\u0131nda her Class, Kernel\u2019dan gelen Class nesnesinden t\u00fcremi\u015f alt s\u0131n\u0131ft\u0131r :) allocate , new ve superclass superclass ilgili Class\u2019\u0131n kimden geldi\u011fini / t\u00fcredi\u011fini g\u00f6sterir. Benzer \u00f6rnekleri kitab\u0131n ba\u015f\u0131nda yapm\u0131\u015ft\u0131k: String . superclass # => Object Object . superclass # => BasicObject BasicObject . superclass # => nil new ise \u00f6nce allocate method\u2019unu \u00e7a\u011f\u0131r\u0131p haf\u0131zada gereken yeri ay\u0131r\u0131r, yani instantiate edece\u011fimiz Class\u2019\u0131n s\u0131n\u0131f\u0131n\u0131 organize eder, sonra olu\u015facak Class\u2019\u0131n initialize method\u2019unu \u00e7a\u011f\u0131r\u0131p varsa ilgili arg\u00fcmanlar\u0131 pas eder. Her .new \u00e7a\u011f\u0131r\u0131ld\u0131\u011f\u0131nda bu i\u015f olur. Private Instance Method\u2019lar\u0131 inherited(subclass) \u0130lgili s\u0131n\u0131f\u0131n alt s\u0131n\u0131f\u0131 olu\u015fturuldu\u011funda tetiklenir. class Animal def self . inherited ( subclass ) puts \"Yeni subclass: #{ subclass } \" end end class Cat < Animal end class Tiger < Cat end # Yeni subclass: Cat # Yeni subclass: Tiger Animal ( hayvan ) s\u0131n\u0131f\u0131ndan, Cat ( kedi ) \u00fcrettik, Tiger ( kaplan )\u2019\u0131 da yine Cat ( kedi )\u2019den \u00fcrettik... Accessors (getter + setter) \u00d6zel method\u2019lar kullanarak Meta Programming mant\u0131\u011f\u0131yla Ruby, Instance Variable\u2019lar\u0131 y\u00f6netmeyi kolayla\u015ft\u0131r\u0131r. Yukar\u0131daki Merhaba Class\u2019\u0131ndaki @isim i\u00e7in asl\u0131nda get ve set yani oku ve yaz method\u2019lar\u0131 tan\u0131mlamam\u0131z laz\u0131m ki ilgili de\u011fi\u015fken \u00fczerinde i\u015flem yapabilelim. \u00d6nce uzun yolu, sonra do\u011fru ve k\u0131sa yolu g\u00f6relim: class Person def name @name end def name= ( name ) @name = name end end vigo = Person . new # => #<Person:0x007f903b8d0590> vigo . name # => nil vigo . name = \"U\u011fur\" # => \"U\u011fur\" vigo . name # => \"U\u011fur\" name method\u2019unu \u00e7a\u011f\u0131r\u0131nca bize instance variable olan @name d\u00f6n\u00fcyor. \u0130lk anda set etmedi\u011fimiz yani de\u011fer atamad\u0131\u011f\u0131m\u0131z i\u00e7in nil geliyor. Daha sonra vigo.name = \"U\u011fur\" diyerek atama yap\u0131yoruz ve art\u0131k de\u011ferini belirlemi\u015f oluyoruz. Bu i\u015f i\u00e7in 2 tane method yazd\u0131k. name ve name= method\u2019lar\u0131. \u0130\u015fte bu noktada accessors imdad\u0131m\u0131za yeti\u015fiyor: class Person attr_accessor :name end vigo = Person . new # => #<Person:0x007fb7c9a4c620> vigo . name # => nil vigo . name = \"U\u011fur\" # => \"U\u011fur\" vigo . name # => \"U\u011fur\" attr_accessor :name dedi\u011fimizde, Ruby, bizim i\u00e7in name ve name= method\u2019lar\u0131 olu\u015fturuyor. Keza sadece bununla kalmay\u0131p, pek \u00e7ok farkl\u0131 kullan\u0131m imkanlar\u0131 sunuyor. attr mod\u00fcl\u00fcyle: attr attr_accessor attr_reader attr_writer gibi \u00f6zel getter/setter\u2019lar geliyor. Yukar\u0131daki \u00f6rne\u011fi attr ile yapal\u0131m; class Person attr :name , true end Person . instance_methods - Object . instance_methods # => [:name, :name=] Otomatik olarak 2 method ekledi : [:name, :name=] . Ayn\u0131 \u015feyi attr_accessor :name ile de yapabilirdik: class Person attr_accessor :name end Person . instance_methods - Object . instance_methods # => [:name, :name=] E\u011fer sadece attr_reader kullansayd\u0131k, sadece ilgili instance variable\u2019\u0131n\u0131 okuyabilir ama de\u011ferini set edemezdik! class Person attr_reader :name end Person . instance_methods - Object . instance_methods # => [:name] vigo = Person . new vigo . name # => nil vigo . name = \"U\u011fur\" # => NoMethodError: undefined method `name=\u2019 for #<Person:0x007ffe4d0e8528> G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi NoMethodError hatas\u0131 ald\u0131k \u00e7\u00fcnki setter yani name= method\u2019u olu\u015fmad\u0131! Peki sadece attr_writer olsayd\u0131? class Person attr_writer :name end Person . instance_methods - Object . instance_methods # => [:name=] vigo = Person . new vigo . name = \"U\u011fur\" # => \"U\u011fur\" vigo . name # => NoMethodError: undefined method \u2018name\u2019 for #<Person:0x007fb92b9d45b8 @name=\"U\u011fur\"> Set edebiliyoruz ama get edemiyoruz! Peki attr_writer nerede i\u015fimize yarar? \u00d6rne\u011fin sadece Class\u2019\u0131 initialize ederken de\u011fer pas edip s\u0131n\u0131f i\u00e7inde bir de\u011fi\u015fkene atama yapmak gerekti\u011finde kullanabilirsiniz: class Person attr_writer :name def initialize ( name ) @name = name end def greet \"Hello #{ @name } \" end end vigo = Person . new \"U\u011fur\" vigo . greet # => \"Hello U\u011fur\" @name de\u011fi\u015fkenini sadece ilk tetiklenmede set ediceksem ve d\u0131\u015far\u0131dan okuma ihtiyac\u0131m yoksa bu \u015fekilde kullanabilirim! Class Variables @@ ile ba\u015flayan de\u011fi\u015fkenler Class Variable ( S\u0131n\u0131f De\u011fi\u015fkeni ) olarak tan\u0131mlan\u0131r. Yani Ana Class\u2019a ait bir de\u011fi\u015fkendir. Her yeni instance olu\u015ftu\u011funda bu de\u011fer ait oldu\u011fu \u00fcst s\u0131n\u0131ftan eri\u015filebilir: class Person attr_accessor :name @@amount = 0 def initialize ( name ) @@amount += 1 @name = name end def greet \"Hello #{ name } \" end def how_many_people_created \"Number of people: #{ @@amount } \" end end user1 = Person . new \"U\u011fur\" user2 = Person . new \"Ye\u015fim\" user3 = Person . new \"Ezel\" Person . class_variable_get ( :@@amount ) # => 3 user3 . how_many_people_created # => \"Number of people: 3\" Class Methods \u0130lgili Class\u2019dan t\u00fcretme yapmadan, direk Class\u2019dan \u00e7a\u011f\u0131r\u0131lan \u00f6zel method\u2019dur. Bu method\u2019u \u00e7a\u011f\u0131rmak i\u00e7in s\u0131n\u0131ftan herhangi bir t\u00fcretme yapmaya gerek olmaz, direkt olarak s\u0131n\u0131f\u2019tan \u00e7a\u011f\u0131r\u0131l\u0131r: class Person attr_accessor :name @@amount = 0 def initialize ( name ) @@amount += 1 @name = name end def greet \"Hello #{ name } \" end def how_many_people_created \"Number of people: #{ @@amount } \" end def self . how_many_people_created \"We have #{ @@amount } copie(s)\" end end user1 = Person . new \"U\u011fur\" user2 = Person . new \"Ye\u015fim\" user3 = Person . new \"Ezel\" Person . how_many_people_created # => \"We have 3 copie(s)\" Person.how_many_people_created direkt olarak \u00e7a\u011f\u0131r\u0131l\u0131r! Singletons S\u0131n\u0131f i\u00e7inde class komutunu kullanarak method olu\u015fturmak i\u00e7indir. Buna Singleton denir. Sadece bir kere instantiate ( tetiklenme diyelim ) olur. \u00d6rne\u011fin alan hesab\u0131 yapacak bir s\u0131n\u0131f d\u00fc\u015f\u00fcn\u00fcyoruz ve bunun calculate method\u2019u olsun. En x Boy bize metrekare\u2019yi versin: class Area class << self def calculate ( width , height ) width * height end end end Area . calculate ( 5 , 5 ) # => 25 G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi hi\u00e7bir \u015fekilde new ya da benzer bir \u015fey t\u00fcretme kullanmad\u0131k direkt olarak Area.calculate(5, 5) \u015feklinde kulland\u0131k. Keza ayn\u0131 i\u015fi; class Area end x = Area . new def x . calculate ( width , height ) width * height end x . calculate 5 , 5 # => 25 \u015feklinde de yapabilirdik. Inheritance (Miras) Asl\u0131nda bu da bildi\u011fimiz bir \u015fey. S\u0131n\u0131ftan t\u00fcreme yaparkan, t\u00fcretti\u011fimiz s\u0131n\u0131f\u0131n \u00f6zellikleri t\u00fcreyene miras ge\u00e7er. class Animal attr_accessor :name , :kind def initialize ( name ) @name = name end def say_hi \"Hello! I\u2019m a #{ @kind } , my name is #{ @name } \" end end class Cat < Animal end class Horse < Animal end bidik = Cat . new \"B\u0131d\u0131k\" bidik . kind = \"cat\" zuzu = Horse . new \"Zuzu\" zuzu . kind = \"horse\" bidik . say_hi # => \"Hello! I\u2019m a cat, my name is B\u0131d\u0131k\" zuzu . say_hi # => \"Hello! I\u2019m a horse, my name is Zuzu\" Cat ve Horse Animal s\u0131n\u0131f\u0131ndan < y\u00f6ntemiyle t\u00fcredi ve Animal deki t\u00fcm method\u2019lar Cat ve Horse \u2019a ge\u00e7ti. Access Level (Eri\u015fim): Public, Private, ve Protected Method\u2019lar Class i\u00e7indeki method\u2019lar duruma g\u00f6re eri\u015filebilirlik a\u00e7\u0131s\u0131ndan k\u0131s\u0131tlanabilir. public olanlar her yerden eri\u015filebilirken ( bu default bir durumdur ), private olana sadece i\u00e7eriden eri\u015filebilir, protected olana ise ancak alt s\u0131n\u0131ftan t\u00fcreyenden eri\u015filebilir. class User def bu_sayede_private_cagirabilirim bu_sadece_iceriden end private def bu_sadece_iceriden puts \"Bu private method. Bu method instance\u2019dan \u00e7a\u011f\u0131r\u0131lamaz!\" end protected def bu_sadece_subclass_veya_instance_dan puts \"Bu proteced method.\" end end u = User . new u . bu_sadece_iceriden # => NoMethodError: private method \u2018bu_sadece_iceriden\u2019 called for #<User:0x007feb9d0d2560> G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi bu_sadece_iceriden method\u2019unu User dan instantiate etti\u011fimiz u \u00fczeriden \u00e7a\u011f\u0131ram\u0131yoruz. private oldu\u011fu i\u00e7in ancak i\u00e7eriden \u00e7a\u011f\u0131r\u0131labilir: u . bu_sayede_private_cagirabilirim # => \"Bu private method. Bu method instance\u2019dan \u00e7a\u011f\u0131r\u0131lamaz!\" public olan bu_sayede_private_cagirabilirim method\u2019u i\u00e7eriden private method olan bu_sadece_iceriden \u2019e eri\u015febildi. Peki ya protected ? E\u011fer direkt olarak \u00e7a\u011f\u0131rmaya kalksayd\u0131k: u . bu_sadece_subclass_veya_instance_dan # => NoMethodError: protected method \u2018bu_sadece_subclass_veya_instance_dan\u2019 called for #<User:0x007fff131c60a0> Hemen gerekeni yapal\u0131m; User Class\u2019\u0131ndan ba\u015fka bir Class \u00fcretelim: class SuperUser < User def initialize bu_sadece_subclass_veya_instance_dan end end y = SuperUser . new # => \"Bu proteced method.\" Method Aliasing Baz\u0131 durumlarda, \u00fcst s\u0131n\u0131ftaki method\u2019u ezmek gerekir. Bu i\u015flemi yaparken asl\u0131nda \u00fcst s\u0131n\u0131ftaki orijinal method\u2019a da eri\u015fmeniz gerekebilir. class User attr_accessor :name def initialize ( name ) @name = name end def give_random_age ( 20 .. 45 ) . to_a . sample end end class SuperUser < User alias :yedek :give_random_age # \u00fcst s\u0131n\u0131ftaki give_random_age\u2019i saklad\u0131k, yedek ad\u0131n\u0131 verdik def give_random_age rnd = self . yedek \"Kendi ya\u015f\u0131m: 43, rnd= #{ rnd } \" end end u = User . new \"vigo\" u . name # => \"vigo\" u . give_random_age # => 29 v = SuperUser . new \"U\u011fur\" v . give_random_age # => \"Kendi ya\u015f\u0131m: 43, rnd= 44\" \u00d6rnekte, SuperUser Class\u2019\u0131nda kafam\u0131za g\u00f6re give_random_age method\u2019unu ezip kendi i\u015flemimizi yaparken, \u00fcst s\u0131n\u0131ftan miras gelen orijinal method\u2019u da yedekliyoruz, yedek ad\u0131 alt\u0131nda. S\u0131n\u0131flar A\u00e7\u0131kt\u0131r, Modifiye Edilebilir! \u0130ster Kernel\u2019dan ister ba\u015fka bir yerden gelsin, her \u015fekilde Class\u2019lar modifiye edilebilir. Detaylar\u0131 Monkey Patching \u2019de g\u00f6rece\u011fiz. K\u0131sa bir \u00f6rnek yapal\u0131m. String Class\u2019\u0131na ne\u015femize g\u00f6re bir method ekleyelim: class String def hello \"Hello: #{ self } \" end end \"Deneme\" . hello # => \"Hello: Deneme\" Tipi String olan her \u015feyin art\u0131k hello diye bir method\u2019u oldu :) Nested Class Ayn\u0131 Module\u2019lerde oldu\u011fu gibi, i\u00e7 i\u00e7e Class tan\u0131mlamak da m\u00fcmk\u00fcnd\u00fcr. Kimi zaman d\u00fczenli olmak i\u00e7in ( Namespace ) kimi zaman da belli bir kural\u0131 uygulamak i\u00e7in kullan\u0131l\u0131r; class Animal attr_reader :name def initialize ( name ) @name = name end class Cat < Animal end class Horse < Animal end class Uber end end horse = Animal :: Horse . new \"Furry\" horse . name # => \"Furry\" horse . class # => Animal::Horse horse . class . superclass # => Animal cat = Animal :: Cat . new \"B\u0131d\u0131k\" cat . name # => \"B\u0131d\u0131k\" cat . class # => Animal::Cat cat . class . superclass # => Animal alien = Animal :: Uber . new alien . respond_to? ( :name ) # => false alien . class # => Animal::Uber alien . class . superclass # => Object Cat ve Horse , Animal s\u0131n\u0131f\u0131ndan t\u00fcremi\u015f, Uber ise sadece Animal namespace\u2019i i\u00e7inde olup kendi ba\u015f\u0131na bir Class\u2019\u0131 temsil etmektedir.","title":"Class"},{"location":"bolum-04/07-class/#class-snf","text":"Ruby, Object-Oriented ( OO ) bir dil oldu\u011fu i\u00e7in, methodlar\u0131 de\u011fi\u015fkenleri ve benzeri \u015feyleri i\u00e7inde bar\u0131ndan bir t\u00fcr ta\u015f\u0131y\u0131c\u0131ya ihtiya\u00e7 duyar. \u0130\u015fte bu ta\u015f\u0131y\u0131c\u0131ya Class ya da s\u0131n\u0131f diyoruz. Asl\u0131nda ben t\u00fcr demeyi tercih ediyorum s\u0131n\u0131f yerine. Zaten \u00f6nceki konularda Class Methods , Instance Methods gibi kavramlara girmi\u015ftik. Class\u2019lar birbirinden t\u00fcreyebilir ( Hani class.superclass \u015feklinde analizler yapm\u0131\u015ft\u0131k ) Teknik olarak bir dosyada birden fazla Class tan\u0131mlamas\u0131 yap\u0131labilir. \u00d6rne\u011fin, my_class.rb adl\u0131 bir dosya i\u00e7inde farkl\u0131 farkl\u0131 Class tan\u0131mlamalar\u0131 olabilir; class MyClass end class OtherClass end a = MyClass . new # => #<MyClass:0x007ffa2b09b758> b = OtherClass . new # => #<OtherClass:0x007ffa2b09b3c0> Class tek ba\u015f\u0131na bir nesne ( Obje ) bu bak\u0131mdan instantiate etmeseniz bile ( Yani a = Array.new gibi ) kullanabilece\u011finiz bir \u015feydir. Class\u2019lar\u0131n di\u011fer bir \u00f6zelli\u011fi de a\u00e7\u0131k olmas\u0131d\u0131r. Ruby\u2019nin bence en harika \u00f6zelli\u011fi, built-in yani dilin \u00e7ekirde\u011finden gelen Class\u2019lara bile method / property eklemeniz m\u00fcmk\u00fcnd\u00fcr. Bu konular\u0131 Monkey Patching k\u0131sm\u0131nda detayl\u0131 g\u00f6rece\u011fiz. En basit tan\u0131m\u0131yla Class a\u015fa\u011f\u0131daki gibidir: class Merhaba def initialize ( isim ) @isim = isim end def selam_sana \"Selam sana, #{ @isim } \" end end hey = Merhaba . new \"U\u011fur\" hey . selam_sana # => \"Selam sana, U\u011fur\" initialize methodu, Class\u2019dan ilk \u00f6rnek t\u00fcredildi\u011finde ( yani bir instance olu\u015fturuldu\u011funda ) tetiklenir ve bir t\u00fcr Class ile ilgili \u00f6n tan\u0131mlamalar\u0131n yap\u0131ld\u0131\u011f\u0131 alan konumundad\u0131r. Benzer dillerdeki class constructor \u2019\u0131 gibi d\u00fc\u015f\u00fcn\u00fclebilir. @isim ise Instance Variable yani Class\u2019tan t\u00fcreyen nesneye ait de\u011fi\u015fkendir. selam_sana ise bu Class\u2019\u0131n bir method\u2019udur. hey de\u011fi\u015fkeni, Merhaba Class\u2019\u0131ndan t\u00fcremi\u015f bir Instance \u2019d\u0131r. Merhaba s\u0131n\u0131f\u0131ndaki t\u00fcm method\u2019lar inherit yani miras olarak hey nesnesine ge\u00e7mi\u015ftir. Class\u2019\u0131 tan\u0131mlarken ister klasik ister block y\u00f6ntemini kullanabilirsiniz. Klasik y\u00f6ntem: class Person end jack = Person . new # => #<Person:0x007fb0521a4820> Block ise; Person = Class . new do end jack = Person . new # => #<Person:0x007fc42c0c8648> \u015feklindedir. Class isimleri B\u00fcy\u00fck harfle ba\u015flar.","title":"Class (S\u0131n\u0131f)"},{"location":"bolum-04/07-class/#public-instance-methodlar","text":"Bir Class\u2019tan t\u00fcreyen \u015feye Instance diyoruz. Ruby\u2019de Class\u2019lar first-class objects olarak ge\u00e7er yani birinci s\u0131n\u0131f nesnelerdir. Bu da \u015fu anlama gelir, asl\u0131nda her Class, Kernel\u2019dan gelen Class nesnesinden t\u00fcremi\u015f alt s\u0131n\u0131ft\u0131r :) allocate , new ve superclass superclass ilgili Class\u2019\u0131n kimden geldi\u011fini / t\u00fcredi\u011fini g\u00f6sterir. Benzer \u00f6rnekleri kitab\u0131n ba\u015f\u0131nda yapm\u0131\u015ft\u0131k: String . superclass # => Object Object . superclass # => BasicObject BasicObject . superclass # => nil new ise \u00f6nce allocate method\u2019unu \u00e7a\u011f\u0131r\u0131p haf\u0131zada gereken yeri ay\u0131r\u0131r, yani instantiate edece\u011fimiz Class\u2019\u0131n s\u0131n\u0131f\u0131n\u0131 organize eder, sonra olu\u015facak Class\u2019\u0131n initialize method\u2019unu \u00e7a\u011f\u0131r\u0131p varsa ilgili arg\u00fcmanlar\u0131 pas eder. Her .new \u00e7a\u011f\u0131r\u0131ld\u0131\u011f\u0131nda bu i\u015f olur.","title":"Public Instance Method\u2019lar\u0131"},{"location":"bolum-04/07-class/#private-instance-methodlar","text":"inherited(subclass) \u0130lgili s\u0131n\u0131f\u0131n alt s\u0131n\u0131f\u0131 olu\u015fturuldu\u011funda tetiklenir. class Animal def self . inherited ( subclass ) puts \"Yeni subclass: #{ subclass } \" end end class Cat < Animal end class Tiger < Cat end # Yeni subclass: Cat # Yeni subclass: Tiger Animal ( hayvan ) s\u0131n\u0131f\u0131ndan, Cat ( kedi ) \u00fcrettik, Tiger ( kaplan )\u2019\u0131 da yine Cat ( kedi )\u2019den \u00fcrettik...","title":"Private Instance Method\u2019lar\u0131"},{"location":"bolum-04/07-class/#accessors-getter-setter","text":"\u00d6zel method\u2019lar kullanarak Meta Programming mant\u0131\u011f\u0131yla Ruby, Instance Variable\u2019lar\u0131 y\u00f6netmeyi kolayla\u015ft\u0131r\u0131r. Yukar\u0131daki Merhaba Class\u2019\u0131ndaki @isim i\u00e7in asl\u0131nda get ve set yani oku ve yaz method\u2019lar\u0131 tan\u0131mlamam\u0131z laz\u0131m ki ilgili de\u011fi\u015fken \u00fczerinde i\u015flem yapabilelim. \u00d6nce uzun yolu, sonra do\u011fru ve k\u0131sa yolu g\u00f6relim: class Person def name @name end def name= ( name ) @name = name end end vigo = Person . new # => #<Person:0x007f903b8d0590> vigo . name # => nil vigo . name = \"U\u011fur\" # => \"U\u011fur\" vigo . name # => \"U\u011fur\" name method\u2019unu \u00e7a\u011f\u0131r\u0131nca bize instance variable olan @name d\u00f6n\u00fcyor. \u0130lk anda set etmedi\u011fimiz yani de\u011fer atamad\u0131\u011f\u0131m\u0131z i\u00e7in nil geliyor. Daha sonra vigo.name = \"U\u011fur\" diyerek atama yap\u0131yoruz ve art\u0131k de\u011ferini belirlemi\u015f oluyoruz. Bu i\u015f i\u00e7in 2 tane method yazd\u0131k. name ve name= method\u2019lar\u0131. \u0130\u015fte bu noktada accessors imdad\u0131m\u0131za yeti\u015fiyor: class Person attr_accessor :name end vigo = Person . new # => #<Person:0x007fb7c9a4c620> vigo . name # => nil vigo . name = \"U\u011fur\" # => \"U\u011fur\" vigo . name # => \"U\u011fur\" attr_accessor :name dedi\u011fimizde, Ruby, bizim i\u00e7in name ve name= method\u2019lar\u0131 olu\u015fturuyor. Keza sadece bununla kalmay\u0131p, pek \u00e7ok farkl\u0131 kullan\u0131m imkanlar\u0131 sunuyor. attr mod\u00fcl\u00fcyle: attr attr_accessor attr_reader attr_writer gibi \u00f6zel getter/setter\u2019lar geliyor. Yukar\u0131daki \u00f6rne\u011fi attr ile yapal\u0131m; class Person attr :name , true end Person . instance_methods - Object . instance_methods # => [:name, :name=] Otomatik olarak 2 method ekledi : [:name, :name=] . Ayn\u0131 \u015feyi attr_accessor :name ile de yapabilirdik: class Person attr_accessor :name end Person . instance_methods - Object . instance_methods # => [:name, :name=] E\u011fer sadece attr_reader kullansayd\u0131k, sadece ilgili instance variable\u2019\u0131n\u0131 okuyabilir ama de\u011ferini set edemezdik! class Person attr_reader :name end Person . instance_methods - Object . instance_methods # => [:name] vigo = Person . new vigo . name # => nil vigo . name = \"U\u011fur\" # => NoMethodError: undefined method `name=\u2019 for #<Person:0x007ffe4d0e8528> G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi NoMethodError hatas\u0131 ald\u0131k \u00e7\u00fcnki setter yani name= method\u2019u olu\u015fmad\u0131! Peki sadece attr_writer olsayd\u0131? class Person attr_writer :name end Person . instance_methods - Object . instance_methods # => [:name=] vigo = Person . new vigo . name = \"U\u011fur\" # => \"U\u011fur\" vigo . name # => NoMethodError: undefined method \u2018name\u2019 for #<Person:0x007fb92b9d45b8 @name=\"U\u011fur\"> Set edebiliyoruz ama get edemiyoruz! Peki attr_writer nerede i\u015fimize yarar? \u00d6rne\u011fin sadece Class\u2019\u0131 initialize ederken de\u011fer pas edip s\u0131n\u0131f i\u00e7inde bir de\u011fi\u015fkene atama yapmak gerekti\u011finde kullanabilirsiniz: class Person attr_writer :name def initialize ( name ) @name = name end def greet \"Hello #{ @name } \" end end vigo = Person . new \"U\u011fur\" vigo . greet # => \"Hello U\u011fur\" @name de\u011fi\u015fkenini sadece ilk tetiklenmede set ediceksem ve d\u0131\u015far\u0131dan okuma ihtiyac\u0131m yoksa bu \u015fekilde kullanabilirim!","title":"Accessors (getter + setter)"},{"location":"bolum-04/07-class/#class-variables","text":"@@ ile ba\u015flayan de\u011fi\u015fkenler Class Variable ( S\u0131n\u0131f De\u011fi\u015fkeni ) olarak tan\u0131mlan\u0131r. Yani Ana Class\u2019a ait bir de\u011fi\u015fkendir. Her yeni instance olu\u015ftu\u011funda bu de\u011fer ait oldu\u011fu \u00fcst s\u0131n\u0131ftan eri\u015filebilir: class Person attr_accessor :name @@amount = 0 def initialize ( name ) @@amount += 1 @name = name end def greet \"Hello #{ name } \" end def how_many_people_created \"Number of people: #{ @@amount } \" end end user1 = Person . new \"U\u011fur\" user2 = Person . new \"Ye\u015fim\" user3 = Person . new \"Ezel\" Person . class_variable_get ( :@@amount ) # => 3 user3 . how_many_people_created # => \"Number of people: 3\"","title":"Class Variables"},{"location":"bolum-04/07-class/#class-methods","text":"\u0130lgili Class\u2019dan t\u00fcretme yapmadan, direk Class\u2019dan \u00e7a\u011f\u0131r\u0131lan \u00f6zel method\u2019dur. Bu method\u2019u \u00e7a\u011f\u0131rmak i\u00e7in s\u0131n\u0131ftan herhangi bir t\u00fcretme yapmaya gerek olmaz, direkt olarak s\u0131n\u0131f\u2019tan \u00e7a\u011f\u0131r\u0131l\u0131r: class Person attr_accessor :name @@amount = 0 def initialize ( name ) @@amount += 1 @name = name end def greet \"Hello #{ name } \" end def how_many_people_created \"Number of people: #{ @@amount } \" end def self . how_many_people_created \"We have #{ @@amount } copie(s)\" end end user1 = Person . new \"U\u011fur\" user2 = Person . new \"Ye\u015fim\" user3 = Person . new \"Ezel\" Person . how_many_people_created # => \"We have 3 copie(s)\" Person.how_many_people_created direkt olarak \u00e7a\u011f\u0131r\u0131l\u0131r!","title":"Class Methods"},{"location":"bolum-04/07-class/#singletons","text":"S\u0131n\u0131f i\u00e7inde class komutunu kullanarak method olu\u015fturmak i\u00e7indir. Buna Singleton denir. Sadece bir kere instantiate ( tetiklenme diyelim ) olur. \u00d6rne\u011fin alan hesab\u0131 yapacak bir s\u0131n\u0131f d\u00fc\u015f\u00fcn\u00fcyoruz ve bunun calculate method\u2019u olsun. En x Boy bize metrekare\u2019yi versin: class Area class << self def calculate ( width , height ) width * height end end end Area . calculate ( 5 , 5 ) # => 25 G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi hi\u00e7bir \u015fekilde new ya da benzer bir \u015fey t\u00fcretme kullanmad\u0131k direkt olarak Area.calculate(5, 5) \u015feklinde kulland\u0131k. Keza ayn\u0131 i\u015fi; class Area end x = Area . new def x . calculate ( width , height ) width * height end x . calculate 5 , 5 # => 25 \u015feklinde de yapabilirdik.","title":"Singletons"},{"location":"bolum-04/07-class/#inheritance-miras","text":"Asl\u0131nda bu da bildi\u011fimiz bir \u015fey. S\u0131n\u0131ftan t\u00fcreme yaparkan, t\u00fcretti\u011fimiz s\u0131n\u0131f\u0131n \u00f6zellikleri t\u00fcreyene miras ge\u00e7er. class Animal attr_accessor :name , :kind def initialize ( name ) @name = name end def say_hi \"Hello! I\u2019m a #{ @kind } , my name is #{ @name } \" end end class Cat < Animal end class Horse < Animal end bidik = Cat . new \"B\u0131d\u0131k\" bidik . kind = \"cat\" zuzu = Horse . new \"Zuzu\" zuzu . kind = \"horse\" bidik . say_hi # => \"Hello! I\u2019m a cat, my name is B\u0131d\u0131k\" zuzu . say_hi # => \"Hello! I\u2019m a horse, my name is Zuzu\" Cat ve Horse Animal s\u0131n\u0131f\u0131ndan < y\u00f6ntemiyle t\u00fcredi ve Animal deki t\u00fcm method\u2019lar Cat ve Horse \u2019a ge\u00e7ti.","title":"Inheritance (Miras)"},{"location":"bolum-04/07-class/#access-level-erisim-public-private-ve-protected-methodlar","text":"Class i\u00e7indeki method\u2019lar duruma g\u00f6re eri\u015filebilirlik a\u00e7\u0131s\u0131ndan k\u0131s\u0131tlanabilir. public olanlar her yerden eri\u015filebilirken ( bu default bir durumdur ), private olana sadece i\u00e7eriden eri\u015filebilir, protected olana ise ancak alt s\u0131n\u0131ftan t\u00fcreyenden eri\u015filebilir. class User def bu_sayede_private_cagirabilirim bu_sadece_iceriden end private def bu_sadece_iceriden puts \"Bu private method. Bu method instance\u2019dan \u00e7a\u011f\u0131r\u0131lamaz!\" end protected def bu_sadece_subclass_veya_instance_dan puts \"Bu proteced method.\" end end u = User . new u . bu_sadece_iceriden # => NoMethodError: private method \u2018bu_sadece_iceriden\u2019 called for #<User:0x007feb9d0d2560> G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi bu_sadece_iceriden method\u2019unu User dan instantiate etti\u011fimiz u \u00fczeriden \u00e7a\u011f\u0131ram\u0131yoruz. private oldu\u011fu i\u00e7in ancak i\u00e7eriden \u00e7a\u011f\u0131r\u0131labilir: u . bu_sayede_private_cagirabilirim # => \"Bu private method. Bu method instance\u2019dan \u00e7a\u011f\u0131r\u0131lamaz!\" public olan bu_sayede_private_cagirabilirim method\u2019u i\u00e7eriden private method olan bu_sadece_iceriden \u2019e eri\u015febildi. Peki ya protected ? E\u011fer direkt olarak \u00e7a\u011f\u0131rmaya kalksayd\u0131k: u . bu_sadece_subclass_veya_instance_dan # => NoMethodError: protected method \u2018bu_sadece_subclass_veya_instance_dan\u2019 called for #<User:0x007fff131c60a0> Hemen gerekeni yapal\u0131m; User Class\u2019\u0131ndan ba\u015fka bir Class \u00fcretelim: class SuperUser < User def initialize bu_sadece_subclass_veya_instance_dan end end y = SuperUser . new # => \"Bu proteced method.\"","title":"Access Level (Eri\u015fim): Public, Private, ve Protected Method\u2019lar"},{"location":"bolum-04/07-class/#method-aliasing","text":"Baz\u0131 durumlarda, \u00fcst s\u0131n\u0131ftaki method\u2019u ezmek gerekir. Bu i\u015flemi yaparken asl\u0131nda \u00fcst s\u0131n\u0131ftaki orijinal method\u2019a da eri\u015fmeniz gerekebilir. class User attr_accessor :name def initialize ( name ) @name = name end def give_random_age ( 20 .. 45 ) . to_a . sample end end class SuperUser < User alias :yedek :give_random_age # \u00fcst s\u0131n\u0131ftaki give_random_age\u2019i saklad\u0131k, yedek ad\u0131n\u0131 verdik def give_random_age rnd = self . yedek \"Kendi ya\u015f\u0131m: 43, rnd= #{ rnd } \" end end u = User . new \"vigo\" u . name # => \"vigo\" u . give_random_age # => 29 v = SuperUser . new \"U\u011fur\" v . give_random_age # => \"Kendi ya\u015f\u0131m: 43, rnd= 44\" \u00d6rnekte, SuperUser Class\u2019\u0131nda kafam\u0131za g\u00f6re give_random_age method\u2019unu ezip kendi i\u015flemimizi yaparken, \u00fcst s\u0131n\u0131ftan miras gelen orijinal method\u2019u da yedekliyoruz, yedek ad\u0131 alt\u0131nda.","title":"Method Aliasing"},{"location":"bolum-04/07-class/#snflar-acktr-modifiye-edilebilir","text":"\u0130ster Kernel\u2019dan ister ba\u015fka bir yerden gelsin, her \u015fekilde Class\u2019lar modifiye edilebilir. Detaylar\u0131 Monkey Patching \u2019de g\u00f6rece\u011fiz. K\u0131sa bir \u00f6rnek yapal\u0131m. String Class\u2019\u0131na ne\u015femize g\u00f6re bir method ekleyelim: class String def hello \"Hello: #{ self } \" end end \"Deneme\" . hello # => \"Hello: Deneme\" Tipi String olan her \u015feyin art\u0131k hello diye bir method\u2019u oldu :)","title":"S\u0131n\u0131flar A\u00e7\u0131kt\u0131r, Modifiye Edilebilir!"},{"location":"bolum-04/07-class/#nested-class","text":"Ayn\u0131 Module\u2019lerde oldu\u011fu gibi, i\u00e7 i\u00e7e Class tan\u0131mlamak da m\u00fcmk\u00fcnd\u00fcr. Kimi zaman d\u00fczenli olmak i\u00e7in ( Namespace ) kimi zaman da belli bir kural\u0131 uygulamak i\u00e7in kullan\u0131l\u0131r; class Animal attr_reader :name def initialize ( name ) @name = name end class Cat < Animal end class Horse < Animal end class Uber end end horse = Animal :: Horse . new \"Furry\" horse . name # => \"Furry\" horse . class # => Animal::Horse horse . class . superclass # => Animal cat = Animal :: Cat . new \"B\u0131d\u0131k\" cat . name # => \"B\u0131d\u0131k\" cat . class # => Animal::Cat cat . class . superclass # => Animal alien = Animal :: Uber . new alien . respond_to? ( :name ) # => false alien . class # => Animal::Uber alien . class . superclass # => Object Cat ve Horse , Animal s\u0131n\u0131f\u0131ndan t\u00fcremi\u015f, Uber ise sadece Animal namespace\u2019i i\u00e7inde olup kendi ba\u015f\u0131na bir Class\u2019\u0131 temsil etmektedir.","title":"Nested Class"},{"location":"bolum-04/08-module/","text":"Module Class\u2019a benzeyen ama Class gibi instantiate edilemeyen \u015feydir mod\u00fcl. Mod\u00fcl denen \u015feye Class eklenebilir ( include edilir ) Mod\u00fclden gelen methodlar art\u0131k ilgili Class\u2019\u0131n methodu haline gelir. Yani d\u00fc\u015f\u00fcn\u00fcn ki bir Class var, bu Class\u2019\u0131n farkl\u0131 2-3 Class\u2019tan \u00f6zellik almas\u0131n\u0131 istiyorsunuz. Bunu ba\u015farmak i\u00e7in ilgili Class\u2019a o 2-3 Class\u2019\u0131 Mod\u00fcl olarak ekliyorsunuz! Module\u2019ler sayesinde Namespace ve Mix-in fonksiyonalitesi de gelmi\u015f olur. Tahmin edebilece\u011finiz gibi module kelimesiyle ba\u015flarlar ve ayn\u0131 Class\u2019larda oldu\u011fu gibi b\u00fcy\u00fck harfle ba\u015flayan module ad\u0131 ya da Namespace tan\u0131mlamas\u0131 yap\u0131l\u0131r: module RandomNumbers def generate rand ( 10 ) end end class DiceGame include RandomNumbers end class RaceGame include RandomNumbers end g = DiceGame . new g . generate # => 3 x = RaceGame . new x . generate # => 7 RandomNumbers ad\u0131nda bir Module yapt\u0131k, iki farkl\u0131 Class\u2019\u0131m\u0131z var, DiceGame ve RaceGame diye, include ile bu Module\u2019\u00fc 2 farkl\u0131 Class\u2019a ekledik. \u015eimdi her iki Class\u2019\u0131n da generate ad\u0131nda method\u2019u oldu... Namespacing Module i\u00e7inde Module tan\u0131mlayabilirsiniz. Bu sayede belirledi\u011finiz Module tan\u0131m\u0131 alt\u0131nda ba\u015fka alt Module\u2019ler ve method\u2019lar ekleyebilir, bu sayede t\u00fcm fonksiyonaliteyi ortak bir isim alt\u0131ndan y\u00fcr\u00fctebilirsiniz: module Framework module HttpFunctions def self . fetch_url \"This is url fetcher\" end end end Framework :: HttpFunctions . fetch_url # => \"This is url fetcher\" Alt Module\u2019e ula\u015fmak i\u00e7in :: kulland\u0131k. Ayn\u0131 kodu \u015fu \u015fekilde de tan\u0131mlayabilirdik: module Framework end module Framework::HttpFunctions def self . fetch_url \"This is url fetcher\" end end Framework :: HttpFunctions . fetch_url # => \"This is url fetcher\" Bu sayede, ba\u015fka bir k\u00fct\u00fcphaneden gelen Module\u2019e ek Module\u2019ler takma \u015fans\u0131n\u0131z olur. \u00d6rne\u011fin Sinatra i\u00e7in ek bir \u00f6zellik yap\u0131yorsunuz. Bu durumda; module Sinatra::MyFeature end \u015eeklinde kullanabilirsiniz. Scope (Kapsama Alan\u0131) Dikkat ettiyseniz Module\u2019\u00fc kullan\u0131rken Class gibi instanciate etmedik. Keza \u00f6rnekte self.fetch_url diye method tan\u0131mlamas\u0131 yapt\u0131k. Asl\u0131nda burada Singleton gibi kulland\u0131k. \u00d6rnekte fetch_url methodu i\u00e7in scope olarak HttpFunctions vermi\u015f olduk. Yani fetch_url sadece Framework::HttpFunctions.fetch_url \u015feklinde eri\u015filebilir oldu. Constants (Sabitler) Module i\u00e7inde sabit de\u011fer tan\u0131mlamas\u0131 da yapmak m\u00fcmk\u00fcnd\u00fcr. module A SABIT = 5 end A :: SABIT # => 5 E\u011fer nested ( i\u00e7 i\u00e7e ) yani Module i\u00e7inde Module yaparsak, sabitlere a\u015fa\u011f\u0131daki gibi eri\u015febiliriz: module A SABIT = 5 module B def self . sabit_degeri_ver SABIT end end end A :: SABIT # => 5 A :: B . sabit_degeri_ver # => 5 Peki, d\u0131\u015far\u0131da tan\u0131mlanm\u0131\u015f bir sabit varsa? SABIT = 5 # en d\u0131\u015ftaki global module A SABIT = 10 # i\u00e7erideki module B def self . sabit_degeri_ver \" #{ :: SABIT } , #{ SABIT } \" end end end A :: B . sabit_degeri_ver # => \"5, 10\" En d\u0131\u015ftakini ::SABIT ile ald\u0131k. Visibility, Access Level (Eri\u015fim): Ayn\u0131 Class\u2019lardaki gibi public , private ve protected olay\u0131 Module\u2019ler i\u00e7in de ge\u00e7erlidir. module A def sadece_iceriden \"Bu private method\" end def bu_sayede_private_erisim_olur sadece_iceriden end private :sadece_iceriden end class Deneme include A end c = Deneme . new c . sadece_iceriden # => NoMethodError: private method \u2018sadece_iceriden\u2019 called for #<Deneme:0x007f8f7c9188c8> c . bu_sayede_private_erisim_olur # => \"Bu private method\" Extend ve Include Durumlar\u0131 Ruby\u2019de bir Class sadece tek bir Class\u2019tan t\u00fcreyebildi\u011fi i\u00e7in module ve include \u00e7\u00f6z\u00fcmlerinden bahsetmi\u015ftik: module Person attr_accessor :name def say_hi \"Hello #{ @name } \" end end Person # => Person class User include Person def initialize ( name ) @name = name end end User # => User u = User . new ( \"U\u011fur\" ) # => #<User:0x007fcd42976de8 @name=\"U\u011fur\"> u . say_hi # => \"Hello U\u011fur\" u . name = \"vigo\" u . say_hi # => \"Hello vigo\" Person mod\u00fcl\u00fcnden gelen say_hi method\u2019una; User . new ( \"Ezel\" ) . say_hi # => \"Hello Ezel\" eri\u015febiliyorsunuz ama ; User . say_hi # => undefined method `say_hi\u2019 for User:Class (NoMethodError) yapt\u0131\u011f\u0131m\u0131zda olmayan bir method \u00e7a\u011fr\u0131m\u0131 yapm\u0131\u015f oluruz. E\u011fer include yerine extend kullansayd\u0131k; module Person attr_accessor :name def say_hi @name ||= \"Undefined name\" \"Hello #{ @name } \" end end class User extend Person def initialize ( name ) @name = name end end user = User . new ( \"Ye\u015fim\" ) # => #<User:0x007f87c39702a0 @name=\"Ye\u015fim\"> user . name # => undefined method `name\u2019 for #<User:0x007f87c39702a0 @name=\"Ye\u015fim\"> (NoMethodError) \u00c7\u00fcnki Person a ait \u00f6zellikleri eklemek ( include ) yerine extend ( geni\u015fletme ) ettik ve; User . say_hi # => \"Hello Undefined name\" User . instance_methods - Object . instance_methods # => [] # bo\u015f array say_hi art\u0131k bir singleton haline geldi yani Instance Method \u2019u olmak yerine Class Method \u2019u oldu. Zaten ilgili s\u0131n\u0131f\u0131n varolan method\u2019lar\u0131na bakt\u0131\u011f\u0131m\u0131zda bo\u015f Array d\u00f6nd\u00fc\u011f\u00fcn\u00fc g\u00f6r\u00fcr\u00fcz. \u00d6zetle, include ile sanki ba\u015fka bir s\u0131n\u0131ftan t\u00fcrer gibi t\u00fcm \u00f6zellikleri instance method olarak al\u0131rken, extend kulland\u0131\u011f\u0131m\u0131zda direk Class kopyas\u0131 gibi davran\u0131yor. Mod\u00fclden gelen method\u2019lar\u0131 Class i\u00e7inde instance method gibi kullanmak yerine singleton method olarak kullanaca\u011f\u0131n\u0131z zaman extend kullanabilirsiniz!","title":"Module"},{"location":"bolum-04/08-module/#module","text":"Class\u2019a benzeyen ama Class gibi instantiate edilemeyen \u015feydir mod\u00fcl. Mod\u00fcl denen \u015feye Class eklenebilir ( include edilir ) Mod\u00fclden gelen methodlar art\u0131k ilgili Class\u2019\u0131n methodu haline gelir. Yani d\u00fc\u015f\u00fcn\u00fcn ki bir Class var, bu Class\u2019\u0131n farkl\u0131 2-3 Class\u2019tan \u00f6zellik almas\u0131n\u0131 istiyorsunuz. Bunu ba\u015farmak i\u00e7in ilgili Class\u2019a o 2-3 Class\u2019\u0131 Mod\u00fcl olarak ekliyorsunuz! Module\u2019ler sayesinde Namespace ve Mix-in fonksiyonalitesi de gelmi\u015f olur. Tahmin edebilece\u011finiz gibi module kelimesiyle ba\u015flarlar ve ayn\u0131 Class\u2019larda oldu\u011fu gibi b\u00fcy\u00fck harfle ba\u015flayan module ad\u0131 ya da Namespace tan\u0131mlamas\u0131 yap\u0131l\u0131r: module RandomNumbers def generate rand ( 10 ) end end class DiceGame include RandomNumbers end class RaceGame include RandomNumbers end g = DiceGame . new g . generate # => 3 x = RaceGame . new x . generate # => 7 RandomNumbers ad\u0131nda bir Module yapt\u0131k, iki farkl\u0131 Class\u2019\u0131m\u0131z var, DiceGame ve RaceGame diye, include ile bu Module\u2019\u00fc 2 farkl\u0131 Class\u2019a ekledik. \u015eimdi her iki Class\u2019\u0131n da generate ad\u0131nda method\u2019u oldu...","title":"Module"},{"location":"bolum-04/08-module/#namespacing","text":"Module i\u00e7inde Module tan\u0131mlayabilirsiniz. Bu sayede belirledi\u011finiz Module tan\u0131m\u0131 alt\u0131nda ba\u015fka alt Module\u2019ler ve method\u2019lar ekleyebilir, bu sayede t\u00fcm fonksiyonaliteyi ortak bir isim alt\u0131ndan y\u00fcr\u00fctebilirsiniz: module Framework module HttpFunctions def self . fetch_url \"This is url fetcher\" end end end Framework :: HttpFunctions . fetch_url # => \"This is url fetcher\" Alt Module\u2019e ula\u015fmak i\u00e7in :: kulland\u0131k. Ayn\u0131 kodu \u015fu \u015fekilde de tan\u0131mlayabilirdik: module Framework end module Framework::HttpFunctions def self . fetch_url \"This is url fetcher\" end end Framework :: HttpFunctions . fetch_url # => \"This is url fetcher\" Bu sayede, ba\u015fka bir k\u00fct\u00fcphaneden gelen Module\u2019e ek Module\u2019ler takma \u015fans\u0131n\u0131z olur. \u00d6rne\u011fin Sinatra i\u00e7in ek bir \u00f6zellik yap\u0131yorsunuz. Bu durumda; module Sinatra::MyFeature end \u015eeklinde kullanabilirsiniz.","title":"Namespacing"},{"location":"bolum-04/08-module/#scope-kapsama-alan","text":"Dikkat ettiyseniz Module\u2019\u00fc kullan\u0131rken Class gibi instanciate etmedik. Keza \u00f6rnekte self.fetch_url diye method tan\u0131mlamas\u0131 yapt\u0131k. Asl\u0131nda burada Singleton gibi kulland\u0131k. \u00d6rnekte fetch_url methodu i\u00e7in scope olarak HttpFunctions vermi\u015f olduk. Yani fetch_url sadece Framework::HttpFunctions.fetch_url \u015feklinde eri\u015filebilir oldu.","title":"Scope (Kapsama Alan\u0131)"},{"location":"bolum-04/08-module/#constants-sabitler","text":"Module i\u00e7inde sabit de\u011fer tan\u0131mlamas\u0131 da yapmak m\u00fcmk\u00fcnd\u00fcr. module A SABIT = 5 end A :: SABIT # => 5 E\u011fer nested ( i\u00e7 i\u00e7e ) yani Module i\u00e7inde Module yaparsak, sabitlere a\u015fa\u011f\u0131daki gibi eri\u015febiliriz: module A SABIT = 5 module B def self . sabit_degeri_ver SABIT end end end A :: SABIT # => 5 A :: B . sabit_degeri_ver # => 5 Peki, d\u0131\u015far\u0131da tan\u0131mlanm\u0131\u015f bir sabit varsa? SABIT = 5 # en d\u0131\u015ftaki global module A SABIT = 10 # i\u00e7erideki module B def self . sabit_degeri_ver \" #{ :: SABIT } , #{ SABIT } \" end end end A :: B . sabit_degeri_ver # => \"5, 10\" En d\u0131\u015ftakini ::SABIT ile ald\u0131k.","title":"Constants (Sabitler)"},{"location":"bolum-04/08-module/#visibility-access-level-erisim","text":"Ayn\u0131 Class\u2019lardaki gibi public , private ve protected olay\u0131 Module\u2019ler i\u00e7in de ge\u00e7erlidir. module A def sadece_iceriden \"Bu private method\" end def bu_sayede_private_erisim_olur sadece_iceriden end private :sadece_iceriden end class Deneme include A end c = Deneme . new c . sadece_iceriden # => NoMethodError: private method \u2018sadece_iceriden\u2019 called for #<Deneme:0x007f8f7c9188c8> c . bu_sayede_private_erisim_olur # => \"Bu private method\"","title":"Visibility, Access Level (Eri\u015fim):"},{"location":"bolum-04/08-module/#extend-ve-include-durumlar","text":"Ruby\u2019de bir Class sadece tek bir Class\u2019tan t\u00fcreyebildi\u011fi i\u00e7in module ve include \u00e7\u00f6z\u00fcmlerinden bahsetmi\u015ftik: module Person attr_accessor :name def say_hi \"Hello #{ @name } \" end end Person # => Person class User include Person def initialize ( name ) @name = name end end User # => User u = User . new ( \"U\u011fur\" ) # => #<User:0x007fcd42976de8 @name=\"U\u011fur\"> u . say_hi # => \"Hello U\u011fur\" u . name = \"vigo\" u . say_hi # => \"Hello vigo\" Person mod\u00fcl\u00fcnden gelen say_hi method\u2019una; User . new ( \"Ezel\" ) . say_hi # => \"Hello Ezel\" eri\u015febiliyorsunuz ama ; User . say_hi # => undefined method `say_hi\u2019 for User:Class (NoMethodError) yapt\u0131\u011f\u0131m\u0131zda olmayan bir method \u00e7a\u011fr\u0131m\u0131 yapm\u0131\u015f oluruz. E\u011fer include yerine extend kullansayd\u0131k; module Person attr_accessor :name def say_hi @name ||= \"Undefined name\" \"Hello #{ @name } \" end end class User extend Person def initialize ( name ) @name = name end end user = User . new ( \"Ye\u015fim\" ) # => #<User:0x007f87c39702a0 @name=\"Ye\u015fim\"> user . name # => undefined method `name\u2019 for #<User:0x007f87c39702a0 @name=\"Ye\u015fim\"> (NoMethodError) \u00c7\u00fcnki Person a ait \u00f6zellikleri eklemek ( include ) yerine extend ( geni\u015fletme ) ettik ve; User . say_hi # => \"Hello Undefined name\" User . instance_methods - Object . instance_methods # => [] # bo\u015f array say_hi art\u0131k bir singleton haline geldi yani Instance Method \u2019u olmak yerine Class Method \u2019u oldu. Zaten ilgili s\u0131n\u0131f\u0131n varolan method\u2019lar\u0131na bakt\u0131\u011f\u0131m\u0131zda bo\u015f Array d\u00f6nd\u00fc\u011f\u00fcn\u00fc g\u00f6r\u00fcr\u00fcz. \u00d6zetle, include ile sanki ba\u015fka bir s\u0131n\u0131ftan t\u00fcrer gibi t\u00fcm \u00f6zellikleri instance method olarak al\u0131rken, extend kulland\u0131\u011f\u0131m\u0131zda direk Class kopyas\u0131 gibi davran\u0131yor. Mod\u00fclden gelen method\u2019lar\u0131 Class i\u00e7inde instance method gibi kullanmak yerine singleton method olarak kullanaca\u011f\u0131n\u0131z zaman extend kullanabilirsiniz!","title":"Extend ve Include Durumlar\u0131"},{"location":"bolum-05/","text":"B\u00f6l\u00fcm 5 Bu b\u00f6l\u00fcmde; Enumeration ve Iteration Ranges File System ve IO (Dosya Sistemi) Exception Handling * Kernel Mod\u00fcl\u00fc * konular\u0131n\u0131 i\u015fleyece\u011fiz.","title":"\u0130ndeks"},{"location":"bolum-05/#bolum-5","text":"Bu b\u00f6l\u00fcmde; Enumeration ve Iteration Ranges File System ve IO (Dosya Sistemi) Exception Handling * Kernel Mod\u00fcl\u00fc * konular\u0131n\u0131 i\u015fleyece\u011fiz.","title":"B\u00f6l\u00fcm 5"},{"location":"bolum-05/01-enumeration-ve-iteration/","text":"Enumeration ve Iteration Say\u0131labilen nesneler Enumerator s\u0131n\u0131f\u0131ndan t\u00fcremi\u015flerdir ve i\u00e7inde d\u00f6ng\u00fc / tekrar yap\u0131labilen nesneler haline geldikleri i\u00e7in de Iterable hale gelmi\u015flerdir. Yani ne demek istiyorum? [ \"a\" , \"b\" , \"c\" ]. class # => Array [ \"a\" , \"b\" , \"c\" ]. each . class # => Enumerator [\"a\", \"b\", \"c\"] asl\u0131nda bir Array iken, #each method\u2019unu \u00e7a\u011f\u0131rd\u0131\u011f\u0131m\u0131z anda elimizdeki Array birden Enumerator haline geldi ve i\u00e7inde iterasyon yap\u0131labilecek yani teker teker dizi i\u00e7indeki elemanlara eri\u015fip istedi\u011fimizi gibi kullanabilece\u011fimiz bir hale geldi. each_with_object , with_object \u0130ki method\u2019da ayn\u0131 i\u015fi yapar. Elimizde Enumerator varsa, yani bu i\u00e7inde dola\u015f\u0131labilen bir nesne ise, bu iterasyona ara elementler takabiliriz. Bu iki method, Enumerator\u2019deki her elemana verilen \u015feyi takar. A\u015fa\u011f\u0131daki \u00f6rnekte each_with_object(\"foo\") , [\"a\", \"b\", \"c\"] dizisindeki her eleman i\u00e7indir. Dolay\u0131s\u0131yla, bu i\u015flem sonras\u0131nda ne oldu\u011funu anlamak i\u00e7in Enumerator \u00fc to_a method\u2019u ile Array e \u00e7evirdik. enumerator = [ \"a\" , \"b\" , \"c\" ]. each enumerator_with_foo = enumerator . each_with_object ( \"foo\" ) enumerator_with_foo . to_a # => [[\"a\", \"foo\"], [\"b\", \"foo\"], [\"c\", \"foo\"]] Keza, bu durumda enumerator_with_foo da each method\u2019unu kullanarak, each_with_object ile pas edilen nesneye de iterasyon esnas\u0131na ula\u015fabiliyoruz; enumerator = [ \"a\" , \"b\" , \"c\" ]. each enumerator_with_foo = enumerator . each_with_object ( \"foo\" ) enumerator_with_foo . each do | element , obj | puts \"eleman: #{ element } , obj: #{ obj } \" end # eleman: a, obj: foo # eleman: b, obj: foo # eleman: c, obj: foo Elimizde Enumerator varsa, bir \u015fekilde s\u0131ra / index bilgisi de var demektir; sayilar = [ 1 , 2 , 3 , 4 ]. each sayilar . next # => 1 sayilar . next # => 2 sayilar . next # => 3 sayilar . next # => 4 sayilar . next # => StopIteration hatas\u0131! next method\u2019unu kullanarak sonraki elemana ula\u015fabiliyoruz. Hat\u0131rlarsan\u0131z, Array \u2019ler 0 index\u2019lidir. Elimizdeki Array i\u00e7inde dola\u015f\u0131rken index kullanmak istersek each_with_index method\u2019unu kullan\u0131r\u0131z; [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ]. each_with_index do | name , index | puts \"\u0130sim: #{ name } , index: #{ index } \" end # \u0130sim: U\u011fur, index: 0 # \u0130sim: Ye\u015fim, index: 1 # \u0130sim: Ezel, index: 2 # \u0130sim: \u00d6mer, index: 3 Keza for kullanarak da a\u015fa\u011f\u0131daki gibi bir i\u015flem yapabiliriz; isimler = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] for isim in isimler puts \"isim: #{ isim } \" end # isim: U\u011fur # isim: Ye\u015fim # isim: Ezel # isim: \u00d6mer next_values , peek , peek_values , rewind Ayn\u0131 next gibi \u00e7al\u0131\u015f\u0131r fakat geriye Array d\u00f6ner ve ilgili index pozisyonunu ileri ta\u015f\u0131r. Sona geldi\u011finde de StopIteration hatas\u0131 verir ( Exception ) a = [ 1 , 2 , 3 , 4 ]. each a . next # => 1 a . next_values # => [2] a . next_values # => [3] peek ile next den sonraki de\u011feri g\u00f6r\u00fcr\u00fcz. E\u011fer sona gelinmi\u015fse yine StopIteration raise edilir. a = [ 1 , 2 , 3 , 4 ]. each a . next # => 1 a . peek # => 2 a . next # => 2 a . peek # => 3 a . next # => 3 a . peek # => 4 a . next # => 4 a . peek # => StopIteration: iteration reached an end ayn\u0131 next_values gibi peek_values de bize Array olarak bilgi verir next sonras\u0131nda kalan elemanlar\u0131. rewind ile pozisyonu ba\u015fa al\u0131r\u0131z, yani kayd\u0131 geri sarar\u0131z :) a = [ 1 , 2 , 3 , 4 ]. each a . next # => 1 a . next # => 2 a . next # => 3 a . rewind # => #<Enumerator: [1, 2, 3, 4]:each> a . peek_values # => [1] a . next # => 1 Di\u011fer Nesnelerdeki Enumeration Durumlar\u0131 Fixnum upto , downto , times Bir say\u0131dan yukar\u0131 do\u011fru sayarken upto , a\u015fa\u011f\u0131 do\u011fru sayarken downto ve ka\u00e7 defa ayn\u0131 i\u015flemi yaparken de times kullan\u0131r\u0131z. # 10\u2019dan 5\u2019e say\u0131yoruz, 10\u2019da 5\u2019de dahil.. 10 . downto ( 5 ){ | i | puts \"Say\u0131: #{ i } \" } # >> Say\u0131: 10 # >> Say\u0131: 9 # >> Say\u0131: 8 # >> Say\u0131: 7 # >> Say\u0131: 6 # >> Say\u0131: 5 # 5\u2019den 10\u2019a say\u0131yoruz, 10\u2019da 5\u2019de dahil.. 5 . upto ( 10 ){ | i | puts \"Say\u0131: #{ i } \" } # >> Say\u0131: 5 # >> Say\u0131: 6 # >> Say\u0131: 7 # >> Say\u0131: 8 # >> Say\u0131: 9 # >> Say\u0131: 10 # 3 defa block i\u00e7indeki kod \u00e7al\u0131\u015fs\u0131n # 0\u2019dan 3\u2019e kadar 3 hari\u00e7 :) 3 . times { | i | puts \" #{ i } \" } # >> 0 # >> 1 # >> 2 String Ayn\u0131 mant\u0131kta upto ve downto ilgin\u00e7 bir \u015fekilde String i\u00e7in de kullan\u0131l\u0131r. \u00d6rne\u011fin A\u2019dan itibaren M\u2019ye kadar demek i\u00e7in: \"A\" . upto ( \"M\" ){ | s | puts s } # >> A # >> B # >> C # >> D # >> E # >> F # >> G # >> H # >> I # >> J # >> K # >> L # >> M ya da, \"AB\", \"AC\", \"AD\" gibi sekans olarak gitmek gerekti\u011finde de; \"AB\" . upto ( \"AE\" ){ | s | puts s } # >> AB # >> AC # >> AD # >> AE tam tersi i\u00e7in downto kullan\u0131l\u0131r.","title":"Enumeration ve Iteration"},{"location":"bolum-05/01-enumeration-ve-iteration/#enumeration-ve-iteration","text":"Say\u0131labilen nesneler Enumerator s\u0131n\u0131f\u0131ndan t\u00fcremi\u015flerdir ve i\u00e7inde d\u00f6ng\u00fc / tekrar yap\u0131labilen nesneler haline geldikleri i\u00e7in de Iterable hale gelmi\u015flerdir. Yani ne demek istiyorum? [ \"a\" , \"b\" , \"c\" ]. class # => Array [ \"a\" , \"b\" , \"c\" ]. each . class # => Enumerator [\"a\", \"b\", \"c\"] asl\u0131nda bir Array iken, #each method\u2019unu \u00e7a\u011f\u0131rd\u0131\u011f\u0131m\u0131z anda elimizdeki Array birden Enumerator haline geldi ve i\u00e7inde iterasyon yap\u0131labilecek yani teker teker dizi i\u00e7indeki elemanlara eri\u015fip istedi\u011fimizi gibi kullanabilece\u011fimiz bir hale geldi. each_with_object , with_object \u0130ki method\u2019da ayn\u0131 i\u015fi yapar. Elimizde Enumerator varsa, yani bu i\u00e7inde dola\u015f\u0131labilen bir nesne ise, bu iterasyona ara elementler takabiliriz. Bu iki method, Enumerator\u2019deki her elemana verilen \u015feyi takar. A\u015fa\u011f\u0131daki \u00f6rnekte each_with_object(\"foo\") , [\"a\", \"b\", \"c\"] dizisindeki her eleman i\u00e7indir. Dolay\u0131s\u0131yla, bu i\u015flem sonras\u0131nda ne oldu\u011funu anlamak i\u00e7in Enumerator \u00fc to_a method\u2019u ile Array e \u00e7evirdik. enumerator = [ \"a\" , \"b\" , \"c\" ]. each enumerator_with_foo = enumerator . each_with_object ( \"foo\" ) enumerator_with_foo . to_a # => [[\"a\", \"foo\"], [\"b\", \"foo\"], [\"c\", \"foo\"]] Keza, bu durumda enumerator_with_foo da each method\u2019unu kullanarak, each_with_object ile pas edilen nesneye de iterasyon esnas\u0131na ula\u015fabiliyoruz; enumerator = [ \"a\" , \"b\" , \"c\" ]. each enumerator_with_foo = enumerator . each_with_object ( \"foo\" ) enumerator_with_foo . each do | element , obj | puts \"eleman: #{ element } , obj: #{ obj } \" end # eleman: a, obj: foo # eleman: b, obj: foo # eleman: c, obj: foo Elimizde Enumerator varsa, bir \u015fekilde s\u0131ra / index bilgisi de var demektir; sayilar = [ 1 , 2 , 3 , 4 ]. each sayilar . next # => 1 sayilar . next # => 2 sayilar . next # => 3 sayilar . next # => 4 sayilar . next # => StopIteration hatas\u0131! next method\u2019unu kullanarak sonraki elemana ula\u015fabiliyoruz. Hat\u0131rlarsan\u0131z, Array \u2019ler 0 index\u2019lidir. Elimizdeki Array i\u00e7inde dola\u015f\u0131rken index kullanmak istersek each_with_index method\u2019unu kullan\u0131r\u0131z; [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ]. each_with_index do | name , index | puts \"\u0130sim: #{ name } , index: #{ index } \" end # \u0130sim: U\u011fur, index: 0 # \u0130sim: Ye\u015fim, index: 1 # \u0130sim: Ezel, index: 2 # \u0130sim: \u00d6mer, index: 3 Keza for kullanarak da a\u015fa\u011f\u0131daki gibi bir i\u015flem yapabiliriz; isimler = [ \"U\u011fur\" , \"Ye\u015fim\" , \"Ezel\" , \"\u00d6mer\" ] for isim in isimler puts \"isim: #{ isim } \" end # isim: U\u011fur # isim: Ye\u015fim # isim: Ezel # isim: \u00d6mer next_values , peek , peek_values , rewind Ayn\u0131 next gibi \u00e7al\u0131\u015f\u0131r fakat geriye Array d\u00f6ner ve ilgili index pozisyonunu ileri ta\u015f\u0131r. Sona geldi\u011finde de StopIteration hatas\u0131 verir ( Exception ) a = [ 1 , 2 , 3 , 4 ]. each a . next # => 1 a . next_values # => [2] a . next_values # => [3] peek ile next den sonraki de\u011feri g\u00f6r\u00fcr\u00fcz. E\u011fer sona gelinmi\u015fse yine StopIteration raise edilir. a = [ 1 , 2 , 3 , 4 ]. each a . next # => 1 a . peek # => 2 a . next # => 2 a . peek # => 3 a . next # => 3 a . peek # => 4 a . next # => 4 a . peek # => StopIteration: iteration reached an end ayn\u0131 next_values gibi peek_values de bize Array olarak bilgi verir next sonras\u0131nda kalan elemanlar\u0131. rewind ile pozisyonu ba\u015fa al\u0131r\u0131z, yani kayd\u0131 geri sarar\u0131z :) a = [ 1 , 2 , 3 , 4 ]. each a . next # => 1 a . next # => 2 a . next # => 3 a . rewind # => #<Enumerator: [1, 2, 3, 4]:each> a . peek_values # => [1] a . next # => 1","title":"Enumeration ve Iteration"},{"location":"bolum-05/01-enumeration-ve-iteration/#diger-nesnelerdeki-enumeration-durumlar","text":"","title":"Di\u011fer Nesnelerdeki Enumeration Durumlar\u0131"},{"location":"bolum-05/01-enumeration-ve-iteration/#fixnum","text":"upto , downto , times Bir say\u0131dan yukar\u0131 do\u011fru sayarken upto , a\u015fa\u011f\u0131 do\u011fru sayarken downto ve ka\u00e7 defa ayn\u0131 i\u015flemi yaparken de times kullan\u0131r\u0131z. # 10\u2019dan 5\u2019e say\u0131yoruz, 10\u2019da 5\u2019de dahil.. 10 . downto ( 5 ){ | i | puts \"Say\u0131: #{ i } \" } # >> Say\u0131: 10 # >> Say\u0131: 9 # >> Say\u0131: 8 # >> Say\u0131: 7 # >> Say\u0131: 6 # >> Say\u0131: 5 # 5\u2019den 10\u2019a say\u0131yoruz, 10\u2019da 5\u2019de dahil.. 5 . upto ( 10 ){ | i | puts \"Say\u0131: #{ i } \" } # >> Say\u0131: 5 # >> Say\u0131: 6 # >> Say\u0131: 7 # >> Say\u0131: 8 # >> Say\u0131: 9 # >> Say\u0131: 10 # 3 defa block i\u00e7indeki kod \u00e7al\u0131\u015fs\u0131n # 0\u2019dan 3\u2019e kadar 3 hari\u00e7 :) 3 . times { | i | puts \" #{ i } \" } # >> 0 # >> 1 # >> 2","title":"Fixnum"},{"location":"bolum-05/01-enumeration-ve-iteration/#string","text":"Ayn\u0131 mant\u0131kta upto ve downto ilgin\u00e7 bir \u015fekilde String i\u00e7in de kullan\u0131l\u0131r. \u00d6rne\u011fin A\u2019dan itibaren M\u2019ye kadar demek i\u00e7in: \"A\" . upto ( \"M\" ){ | s | puts s } # >> A # >> B # >> C # >> D # >> E # >> F # >> G # >> H # >> I # >> J # >> K # >> L # >> M ya da, \"AB\", \"AC\", \"AD\" gibi sekans olarak gitmek gerekti\u011finde de; \"AB\" . upto ( \"AE\" ){ | s | puts s } # >> AB # >> AC # >> AD # >> AE tam tersi i\u00e7in downto kullan\u0131l\u0131r.","title":"String"},{"location":"bolum-05/02-ranges/","text":"Ranges Ba\u015f\u0131, sonu olan, tan\u0131mlanan belli bir aral\u0131ktaki de\u011ferleri g\u00f6steren nesneler Range s\u0131n\u0131f\u0131ndad\u0131r. \u00d6rne\u011fin 0\u2019la 5 aras\u0131ndaki say\u0131lar Range olarak ifade edilebilir; ( 0 .. 5 ) # => 0..5 ( 0 .. 5 ) . class # => Range ( 0 .. 5 ) . to_a # => [0, 1, 2, 3, 4, 5] ( 0 .. 5 ) . to_a . join # => \"012345\" ( 0 .. 5 ) . each # => #<Enumerator: 0..5:each> (0..5) ifadesinde 0 ve 5 dahil olmak \u00fczere bir aral\u0131k tan\u0131mlad\u0131k. \u0130stedi\u011fimiz gibi i\u015fleyebiliriz. ( - 10 .. 0 ) . to_a # => [-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0] ( 0 ..- 10 ) . to_a # => [] ( \"a\" .. \"e\" ) . to_a # => [\"a\", \"b\", \"c\", \"d\", \"e\"] E\u011fer .. yerine ... kullan\u0131rsak, yani (0..5) dersek, 5 hari\u00e7 demi\u015f oluruz; ( 0 ... 5 ) . to_a # => [0, 1, 2, 3, 4] ( \"a\" ... \"e\" ) . to_a # => [\"a\", \"b\", \"c\", \"d\"] Son de\u011fer hari\u00e7 mi dahil mi anlamak i\u00e7in exclude_end? method\u2019unu kullan\u0131r\u0131z; ( 5 .. 10 ) . exclude_end? # => false ( 5 ... 10 ) . exclude_end? # => true Range asl\u0131nda bir Class \u2019d\u0131r ve her Class gibi; r = Range . new ( 0 , 2 ) # => 0..2 r . to_a # => [0, 1, 2] kullan\u0131labilir. == ya da eql? method\u2019u ile kar\u015f\u0131la\u015ft\u0131r\u0131labilir; ( 0 .. 2 ) == ( 0 .. 2 ) # => true ( 0 .. 2 ) . eql? ( 0 .. 2 ) # => true ( 0 .. 2 ) == ( 0 ... 2 ) # => false ( 0 .. 2 ) == Range . new ( 0 , 2 ) # => true ( 0 .. 2 ) . eql? ( Range . new ( 0 , 2 )) # => true begin , first , cover? , include? , member? , end , last Aral\u0131\u011f\u0131n ba\u015flama de\u011ferini almak i\u00e7in begin ya da first kullanabildi\u011fimiz gibi, first \u2019e parametre ge\u00e7erek, ilk N de\u011feri de okuyabiliriz; ( 5 .. 10 ) . begin # => 5 ( 5 .. 10 ) . first # => 5 ( 5 .. 10 ) . first ( 2 ) # => [5, 6] # ilk 2 de\u011feri ver Belirledi\u011fimiz aral\u0131k i\u00e7inde sorgu yapmak i\u00e7in cover? ya da include? ya da member? method\u2019unu kullan\u0131r\u0131z. cover? kullan\u0131rken e\u011fer verdi\u011fimiz de\u011fer aral\u0131k i\u00e7indeyse sonu\u00e7 true d\u00f6ner; ( 5 .. 10 ) . cover? ( 6 ) # => true ( 5 .. 10 ) . cover? ( 4 ) # => false ( 5 .. 10 ) . cover? ( 11 ) # => false ( 5 .. 10 ) . cover? ( 9 ) # => true ( \"a\" .. \"z\" ) . cover? ( \"b\" ) # => true ( \"a\" .. \"z\" ) . cover? ( \"1\" ) # => false ( \"a\" .. \"z\" ) . cover? ( 1 ) # => false ( \"a\" .. \"z\" ) . cover? ( \"abc\" ) # => true include? ile cover? aras\u0131ndaki fark ise \u015fudur; cover? a verilen parametredeki de\u011fer, \u00f6rnekteki abc teker teker range i\u00e7inde var m\u0131? yani a var m\u0131? b var m\u0131? c var m\u0131? \u015feklinde olurken, include? da abc var m\u0131? \u015feklindedir; ( \"a\" .. \"z\" ) . cover? ( \"abc\" ) # => true ( \"a\" .. \"z\" ) . include? ( \"abc\" ) # => false ( \"a\" .. \"z\" ) . cover? ( \"a\" ) # => true ( \"a\" .. \"z\" ) . include? ( \"a\" ) # => true Tahmin edece\u011finiz gibi, end ile son de\u011feri al\u0131r\u0131z. ( 5 .. 10 ) . end # => 10 ( 5 ... 10 ) . end # => 10 last ile de ayn\u0131 first deki gibi son ya da son N de\u011feri okuruz; ( 5 .. 10 ) . last # => 10 ( 5 .. 10 ) . last ( 3 ) # => [8, 9, 10] min , max , size min ve max ile tan\u0131ml\u0131 aral\u0131ktaki en b\u00fcy\u00fck/k\u00fc\u00e7\u00fck de\u011feri al\u0131r\u0131z, size bize boyu verir; ( 5 .. 10 ) . min # => 5 ( 5 .. 10 ) . max # => 10 ( 5 .. 10 ) . size # => 6 step ile ka\u00e7ar ka\u00e7ar artaca\u011f\u0131n\u0131 veririz; r = Range . new ( 0 , 5 ) r . step ( 2 ) # => #<Enumerator: 0..5:step(2)> r . step ( 2 ) . to_a # => [0, 2, 4]","title":"Ranges"},{"location":"bolum-05/02-ranges/#ranges","text":"Ba\u015f\u0131, sonu olan, tan\u0131mlanan belli bir aral\u0131ktaki de\u011ferleri g\u00f6steren nesneler Range s\u0131n\u0131f\u0131ndad\u0131r. \u00d6rne\u011fin 0\u2019la 5 aras\u0131ndaki say\u0131lar Range olarak ifade edilebilir; ( 0 .. 5 ) # => 0..5 ( 0 .. 5 ) . class # => Range ( 0 .. 5 ) . to_a # => [0, 1, 2, 3, 4, 5] ( 0 .. 5 ) . to_a . join # => \"012345\" ( 0 .. 5 ) . each # => #<Enumerator: 0..5:each> (0..5) ifadesinde 0 ve 5 dahil olmak \u00fczere bir aral\u0131k tan\u0131mlad\u0131k. \u0130stedi\u011fimiz gibi i\u015fleyebiliriz. ( - 10 .. 0 ) . to_a # => [-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0] ( 0 ..- 10 ) . to_a # => [] ( \"a\" .. \"e\" ) . to_a # => [\"a\", \"b\", \"c\", \"d\", \"e\"] E\u011fer .. yerine ... kullan\u0131rsak, yani (0..5) dersek, 5 hari\u00e7 demi\u015f oluruz; ( 0 ... 5 ) . to_a # => [0, 1, 2, 3, 4] ( \"a\" ... \"e\" ) . to_a # => [\"a\", \"b\", \"c\", \"d\"] Son de\u011fer hari\u00e7 mi dahil mi anlamak i\u00e7in exclude_end? method\u2019unu kullan\u0131r\u0131z; ( 5 .. 10 ) . exclude_end? # => false ( 5 ... 10 ) . exclude_end? # => true Range asl\u0131nda bir Class \u2019d\u0131r ve her Class gibi; r = Range . new ( 0 , 2 ) # => 0..2 r . to_a # => [0, 1, 2] kullan\u0131labilir. == ya da eql? method\u2019u ile kar\u015f\u0131la\u015ft\u0131r\u0131labilir; ( 0 .. 2 ) == ( 0 .. 2 ) # => true ( 0 .. 2 ) . eql? ( 0 .. 2 ) # => true ( 0 .. 2 ) == ( 0 ... 2 ) # => false ( 0 .. 2 ) == Range . new ( 0 , 2 ) # => true ( 0 .. 2 ) . eql? ( Range . new ( 0 , 2 )) # => true begin , first , cover? , include? , member? , end , last Aral\u0131\u011f\u0131n ba\u015flama de\u011ferini almak i\u00e7in begin ya da first kullanabildi\u011fimiz gibi, first \u2019e parametre ge\u00e7erek, ilk N de\u011feri de okuyabiliriz; ( 5 .. 10 ) . begin # => 5 ( 5 .. 10 ) . first # => 5 ( 5 .. 10 ) . first ( 2 ) # => [5, 6] # ilk 2 de\u011feri ver Belirledi\u011fimiz aral\u0131k i\u00e7inde sorgu yapmak i\u00e7in cover? ya da include? ya da member? method\u2019unu kullan\u0131r\u0131z. cover? kullan\u0131rken e\u011fer verdi\u011fimiz de\u011fer aral\u0131k i\u00e7indeyse sonu\u00e7 true d\u00f6ner; ( 5 .. 10 ) . cover? ( 6 ) # => true ( 5 .. 10 ) . cover? ( 4 ) # => false ( 5 .. 10 ) . cover? ( 11 ) # => false ( 5 .. 10 ) . cover? ( 9 ) # => true ( \"a\" .. \"z\" ) . cover? ( \"b\" ) # => true ( \"a\" .. \"z\" ) . cover? ( \"1\" ) # => false ( \"a\" .. \"z\" ) . cover? ( 1 ) # => false ( \"a\" .. \"z\" ) . cover? ( \"abc\" ) # => true include? ile cover? aras\u0131ndaki fark ise \u015fudur; cover? a verilen parametredeki de\u011fer, \u00f6rnekteki abc teker teker range i\u00e7inde var m\u0131? yani a var m\u0131? b var m\u0131? c var m\u0131? \u015feklinde olurken, include? da abc var m\u0131? \u015feklindedir; ( \"a\" .. \"z\" ) . cover? ( \"abc\" ) # => true ( \"a\" .. \"z\" ) . include? ( \"abc\" ) # => false ( \"a\" .. \"z\" ) . cover? ( \"a\" ) # => true ( \"a\" .. \"z\" ) . include? ( \"a\" ) # => true Tahmin edece\u011finiz gibi, end ile son de\u011feri al\u0131r\u0131z. ( 5 .. 10 ) . end # => 10 ( 5 ... 10 ) . end # => 10 last ile de ayn\u0131 first deki gibi son ya da son N de\u011feri okuruz; ( 5 .. 10 ) . last # => 10 ( 5 .. 10 ) . last ( 3 ) # => [8, 9, 10] min , max , size min ve max ile tan\u0131ml\u0131 aral\u0131ktaki en b\u00fcy\u00fck/k\u00fc\u00e7\u00fck de\u011feri al\u0131r\u0131z, size bize boyu verir; ( 5 .. 10 ) . min # => 5 ( 5 .. 10 ) . max # => 10 ( 5 .. 10 ) . size # => 6 step ile ka\u00e7ar ka\u00e7ar artaca\u011f\u0131n\u0131 veririz; r = Range . new ( 0 , 5 ) r . step ( 2 ) # => #<Enumerator: 0..5:step(2)> r . step ( 2 ) . to_a # => [0, 2, 4]","title":"Ranges"},{"location":"bolum-05/03-file-system-ve-io-dosya-sistemi/","text":"File System ve IO (Dosya Sistemi) File IO s\u0131n\u0131f\u0131ndan \u00f6zellikler i\u00e7eren File s\u0131n\u0131f\u0131, fiziki dosyalarla i\u015flem yapmam\u0131z\u0131 sa\u011flayan \u00f6zellikleri sunar bize. Ruby\u2019nin \u00fczerinde \u00e7al\u0131\u015ft\u0131\u011f\u0131 i\u015fletim sistemine g\u00f6re de file permission yani dosya \u00fczerindeki yetki sistemi de devrededir. Default olarak gelen Constant\u2019lar\u0131: File . constants # => [:Separator, :SEPARATOR, :ALT_SEPARATOR, :PATH_SEPARATOR, :Constants, :Stat, :WaitReadable, :WaitWritable, :EAGAINWaitReadable, :EAGAINWaitWritable, :EWOULDBLOCKWaitReadable, :EWOULDBLOCKWaitWritable, :EINPROGRESSWaitReadable, :EINPROGRESSWaitWritable, :SEEK_SET, :SEEK_CUR, :SEEK_END, :RDONLY, :WRONLY, :RDWR, :APPEND, :CREAT, :EXCL, :NONBLOCK, :TRUNC, :NOCTTY, :BINARY, :SYNC, :DSYNC, :NOFOLLOW, :LOCK_SH, :LOCK_EX, :LOCK_UN, :LOCK_NB, :NULL, :FNM_NOESCAPE, :FNM_PATHNAME, :FNM_DOTMATCH, :FNM_CASEFOLD, :FNM_EXTGLOB, :FNM_SYSCASE] File :: ALT_SEPARATOR # => nil # Bu Ruby\u2019nin \u00e7al\u0131\u015ft\u0131\u011f\u0131 platforma \u00f6zeldir File :: PATH_SEPARATOR # => \":\" File :: SEPARATOR # => \"/\" File :: Separator # => \"/\" \u00d6rne\u011fin Windows\u2019da \u00e7al\u0131\u015fan Ruby\u2019de SEPARATOR ters slash \\ \u015feklinde gelecektir. Public Class Method\u2019lar\u0131 absolute_path , expand_path , join , split String olarak verilen path bilgisini absolute path \u2019e \u00e7evirir. E\u011fer ikinci parametre verilmezse CWD ( current working directory ) yani o an i\u00e7in i\u00e7inde \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131z directory bilgisi kullan\u0131l\u0131r. File . absolute_path ( \"~\" ) # => \"/~\" File . absolute_path ( \".gitignore\" , \"~\" ) # => \"/~/.gitignore\" expand_path de bir nevi absolute path\u2019e \u00e7evirir: File . expand_path ( \"~/.gitignore\" ) # => \"/Users/vigo/.gitignore\" Keza daha kompleks path bulma i\u015flerinde de kullan\u0131l\u0131r. Bu durumda __FILE__ sabiti hayat\u0131m\u0131z\u0131 kolayla\u015ft\u0131r\u0131r. O an Ruby script\u2019inin \u00e7al\u0131\u015ft\u0131\u011f\u0131 dosyan\u0131n path\u2019i __FILE__ sabitindedir. \u00d6rne\u011fin a\u015fa\u011f\u0131daki gibi bir directory yap\u0131s\u0131 olsa: proje/ \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 users.rb \u2514\u2500\u2500 main.rb ve lib/users.rb i\u00e7inden, d\u0131\u015far\u0131da bulunan main.rb dosyas\u0131n\u0131n path\u2019ine ula\u015fmak istesek; File . expand_path ( \"../../main.rb\" , __FILE__ ) \u015feklinde kullan\u0131r\u0131z. join kullanarak, Ruby\u2019nin \u00e7al\u0131\u015ft\u0131\u011f\u0131 i\u015fletim sistemine ba\u011fl\u0131 olarak, File::SEPARATOR kullanarak ge\u00e7ilen string\u2019leri birle\u015ftiririz: File . join ( \"usr\" , \"local\" , \"bin\" ) # => \"usr/local/bin\" Dizin ve dosya ayr\u0131\u015ft\u0131rmas\u0131n\u0131 da split ile yapar\u0131z: File . split ( \"usr/local/bin/foo\" ) # => [\"usr/local/bin\", \"foo\"] atime , ctime , mtime Dosyaya son eri\u015filen tarihi atime ile, dosyada yap\u0131lm\u0131\u015f olan son de\u011fi\u015fiklik tarihini de ctime ile, son de\u011fi\u015fiklik zaman\u0131n\u0131 da mtime ile al\u0131r\u0131z. File . atime ( \"/Users/vigo/.gitignore\" ) # => 2014-11-05 11:45:10 +0200 File . ctime ( \"/Users/vigo/.gitignore\" ) # => 2014-08-04 11:33:14 +0300 File . mtime ( \"/Users/vigo/.gitignore\" ) # => 2014-10-29 15:05:15 +0200 basename , dirname , extname Path i\u00e7inden dosya ad\u0131n\u0131 almak i\u00e7in basename kullan\u0131r\u0131z. E\u011fer parametre olarak ataca\u011f\u0131m\u0131z \u015feyi ( \u00f6rne\u011fin extension olarak .gif, .rb gibi ) ge\u00e7ersek bize sadece dosyan\u0131n ad\u0131n\u0131 verir. File . basename ( \"/Users/vigo/test.rb\" ) # => \"test.rb\" File . basename ( \"/Users/vigo/test.rb\" , \".rb\" ) # => \"test\" Bu i\u015fin tersini de dirname ile yapar\u0131z, yani directory ad\u0131 gerekince: File . dirname ( \"/Users/vigo/test.rb\" ) # => \"/Users/vigo\" \u015fekinde kullan\u0131r\u0131z. Dosyan\u0131n extension\u2019\u0131n\u0131 \u00f6\u011frenmek i\u00e7in extname kullan\u0131r\u0131z. File . extname ( \"test_file.rb\" ) # => \".rb\" File . extname ( \"/foo/bar/test_file.rb\" ) # => \".rb\" File . extname ( \"test_file\" ) # => \"\" chmod , chown , lchmod , lchown Her iki komut da Unix\u2019den gelir. Change mod ve Change owner i\u015flerini yapmam\u0131z\u0131 sa\u011flar. chmod ile Unix izinlerini ayarlar\u0131z: -rw-r--r-- 1 vigo wheel 0 Aug 30 19 :19 file-01.txt |||||||||| |||||||| | +--- Others, Execute ( x ) 1 = 2 ^0 |||||||| +---- Others, Write ( w ) 2 = 2 ^1 |||||| | +----- Others, Read ( r ) 4 = 2 ^2 |||||| +------ Group, Execute ( x ) 1 = 2 ^0 |||| | +------- Group, Write ( w ) 2 = 2 ^1 |||| +-------- Group, Read ( r ) 4 = 2 ^2 || | +--------- Owner/User Execute ( e ) 1 = 2 ^0 || +---------- Owner/User Write ( w ) 2 = 2 ^1 | +----------- Owner/User Read ( r ) 4 = 2 ^2 +------------ Is Directory? ( d ) file-01.txt dosyas\u0131nda, User (yani dosyan\u0131n sahibi) R ead ve W rite hakk\u0131na sahiptir. Group ve Others ise sadece R ead hakk\u0131na sahiptir. Bu durumda varolan bu dosyanin chmod de\u011feri: Owner/User : Read, Write = > 4 + 2 = 6 Group : Read = > 4 = 4 Others : Read = > 4 = 4 ---------------------------------------- 644 unix file permission \u015feklindedir. Hatta Terminal\u2019den; stat -f \u2019%A\u2019 file-01.txt yaparsak 644 oldu\u011funu da g\u00f6rebiliriz. \u015eimdi bu dosyay\u0131 Ruby ile sadece sahibi taraf\u0131ndan okunur ve yaz\u0131l\u0131r yap\u0131p, ba\u015fka hi\u00e7bir kimse taraf\u0131ndan okunamaz ve yaz\u0131lamaz hale getirelim: File . chmod ( 0600 , \"file-01.txt\" ) Keza dosyan\u0131n sahibini de d\u00fczenlemek i\u00e7in chown kullan\u0131r\u0131z. Ayn\u0131 terminaldeki gibi KULLANICI:GRUP \u015feklinde, toplamda \u00fc\u00e7 parametre ge\u00e7eriz. \u0130lki kullan\u0131c\u0131y\u0131 belirler. nil ya da -1 ge\u00e7ti\u011fimiz taktirde ilgili \u015feyi set etmemi\u015f oluruz. Yani sadece grubu de\u011fi\u015ftireceksek kullan\u0131c\u0131 i\u00e7in nil ya da -1 ge\u00e7ebiliriz. File . chown ( nil , 20 , \"/tmp/file-01.txt\" ) # => 1 Grup ID olarak 20 ge\u00e7tik, OSX\u2019deki id 20 kar\u015f\u0131l\u0131k olarak staff grubuna denk gelir. lchmod ve lchown ile normal chmod , chown fark\u0131, l ile ba\u015flayanlar sembolik linkleri takip etmezler. ftype , stat , lstat , size Dosyan\u0131n ne t\u00fcr bir dosya oldu\u011funu ftype ile anlar\u0131z: File . ftype ( \"/tmp/file-01.txt\" ) # => \"file\" File . ftype ( \"/usr/\" ) # => \"directory\" File . ftype ( \"/dev/null\" ) # => \"characterSpecial\" stat ile aynen biraz \u00f6nce shell\u2019den yapt\u0131\u011f\u0131m\u0131z ( stat -f \u2019%A\u2019 file-01.txt ) gibi ayn\u0131 i\u015fi Ruby\u2019den de yapabiliriz: File . stat ( \"/tmp/file-01.txt\" ) # => #<File::Stat dev=0x1000004, ino=1540444, mode=0100600, nlink=1, uid=501, gid=20, rdev=0x0, size=4, blksize=4096, blocks=8, atime=2014-11-12 14:41:49 +0200, mtime=2014-11-12 14:40:13 +0200, ctime=2014-11-12 14:45:28 +0200> File . stat ( \"/tmp/file-01.txt\" ) . uid # => 501 File . stat ( \"/tmp/file-01.txt\" ) . gid # => 20 File . stat ( \"/tmp/file-01.txt\" ) . mtime # => 2014-11-12 14:40:13 +0200 lstat da ayn\u0131 i\u015fi yapar fakat ayn\u0131 lchmod ve lchown daki gibi sembolik linkleri takip etmez! Dosyan\u0131n byte cinsinden b\u00fcy\u00fckl\u00fc\u011f\u00fcn\u00fc almak i\u00e7in size kullan\u0131r\u0131z: File . size ( \"/Users/vigo/.gitignore\" ) # => 323 delete , unlink , link , rename , readlink , symlink Her ikisi de dosya silmeye yarar. E\u011fer dosya ba\u015far\u0131yla silinirse 1 d\u00f6ner, aksi halde hata al\u0131r\u0131z! File . delete ( \"/tmp/foo.txt\" ) # => 1 yani silindi File . delete ( \"/tmp/foo1.txt\" ) # => No such file or directory link ile HARD LINK olu\u015fturuyoruz. Bunu dosyan\u0131n bir kopyas\u0131 / yans\u0131mas\u0131 gibi d\u00fc\u015f\u00fcnebilirsiz. Orijinal dosya de\u011fi\u015ftik\u00e7e linklenmi\u015f dosya da g\u00fcncel i\u00e7eri\u011fe sahip olur. Link\u2019in hangi dosyaya ba\u011fl\u0131 oldu\u011funu da readlink ile okuruz: File . link ( \"orijinal_dosya\" , \"linklenecek_dosya\" ) File . readlink ( \"linklenecek_dosya\" ) # => \"orijinal_dosya\" Sembolik link yani symlink i\u00e7in; File . symlink ( \"foo.txt\" , \"bar.txt\" ) # => 0 File . readlink ( \"bar.txt\" ) # => \"foo.txt\" Komut sat\u0131r\u0131ndan bak\u0131nca; - rw - r -- r -- 1 vigo wheel 0 Dec 13 16 : 08 foo . txt lrwxr - xr - x 1 vigo wheel 7 Dec 13 16 : 08 bar . txt -> foo . txt \u015feklinde bar.txt dosyas\u0131n\u0131n foo.txt dosyas\u0131na linklendi\u011fini g\u00f6r\u00fcr\u00fcz. Dosya ismini de\u011fi\u015ftirmek i\u00e7in rename kullan\u0131r\u0131z. File . rename ( \"/tmp/file-01.txt\" , \"/tmp/file-01.txt.bak\" ) # => 0 file? , directory? , executable? , exist? , identical? , readable? , size? , Dosya ger\u00e7ekten fiziki bir dosya m\u0131? ya da directory mi? ya da bu dosya var m\u0131? # file? File . file? ( \"/tmp/file-01.txt\" ) # => true (evet) File . file? ( \"/tmp/file-02.txt\" ) # => false # directory? File . directory? ( \"/tmp/file-02.txt\" ) # => false File . directory? ( \"/tmp/test_folder\" ) # => true (evet) # dosya var m\u0131? File . exist? ( \"/tmp/file-01.txt\" ) # => true (var) File . exist? ( \"/tmp/file-02.txt\" ) # => false Daha \u00f6nce dosya izinlerinden bahsetmi\u015f, baz\u0131 dosyalar\u0131n executable oldu\u011funu s\u00f6ylemi\u015ftik. Acaba dosya \u00e7al\u0131\u015ft\u0131r\u0131labilir yani executable m\u0131? File . executable? ( \"/tmp/file-01.txt\" ) # => false - rw - r -- r -- 1 vigo wheel 0 Nov 15 10 : 39 file - 01 . txt File . executable? ( \"/tmp/execuatable_file\" ) # => true - rwxr - xr - x 1 vigo wheel 0 Nov 15 10 : 43 execuatable_file Executable olan dosyada x flag aktif g\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi :) new , open open method\u2019u ile new ayn\u0131 i\u015fi yapar. Dosya a\u00e7maya yarar. Dosyay\u0131 a\u00e7arken hangi duruma g\u00f6re a\u00e7aca\u011f\u0131m\u0131z\u0131 yani okumak i\u00e7in mi? yazmak i\u00e7in mi? yoksa varolan dosyaya ek yapmak i\u00e7in mi? belirtmemiz gerekir. f = File . new ( \"/tmp/test.txt\" , \"w\" ) f . puts \"Merhaba\" f . close /tmp/test.txt adl\u0131 bir dosya olu\u015fturup i\u00e7ine puts ile Merhaba yazd\u0131k. E\u011fer cat /tmp/test.txt yaparsan\u0131z kontrol edebilirsiniz. Dikkat ettiyseniz mode olarak \"w\" kulland\u0131k. Bu mode\u2019lar neler? Mode A\u00e7\u0131klama r Read-only, sadece okumak i\u00e7in. Bu default mode\u2019dur. r+ Read+write, hatta read + prepend, pointer\u2019\u0131 ba\u015fa al\u0131r, yani bu method\u2019la bi\u015fi yazarsan\u0131z, yazd\u0131\u011f\u0131n\u0131z \u015fey dosyan\u0131n ba\u015f\u0131na eklenir. w Write-only, sadece yazmak i\u00e7indir. E\u011fer dosya yoksa hata verir! w+ Read+Write, hatta read + append, pointer\u2019\u0131 dosyan\u0131n sonuna al\u0131r ve yazd\u0131klar\u0131n\u0131z\u0131 sona ekler. E\u011fer dosya yoksa hata verir! a Write-only, E\u011fer dosya varsa pointer\u2019\u0131 sona al\u0131r ve sona ek yapar, dosya yoksa s\u0131f\u0131rdan yeni dosya \u00fcretir. a+ Read+write, Ayn\u0131 a gibi \u00e7al\u0131\u015f\u0131r, sona ek yapar, hem okumaya hem de yazmaya izin verir. b Binary mode t Text mode fnmatch , fnmatch? File Name Match yani dosya ad\u0131 e\u015fle\u015ftirmek. RegEx pattern\u2019ine g\u00f6re dosya ad\u0131 yakalamak / kontrol etmek i\u00e7in kullan\u0131l\u0131r. 2 zorunlu ve 1 opsiyonel olmak \u00fczere 3 parametre alabilir. Pattern, dosya ad\u0131 ve opsiyonal olarak Flag\u2019ler... File . fnmatch ( \u2019 foo \u2019 , \u2019 foobar . rb \u2019 ) # => false File . fnmatch ( \u2019 foo * \u2019 , \u2019 foobar . rb \u2019 ) # => true File . fnmatch ( \u2019 * foo * \u2019 , \u2019 test_foobar . rb \u2019 ) # => true \u015eimdi; File . fnmatch ( \u2019 **. rb \u2019 , \u2019 . / main . rb \u2019 ) # => false Bu i\u015flemin true d\u00f6nemsi i\u00e7in FNM_DOTMATCH flag\u2019ini kullanaca\u011f\u0131z: File . fnmatch ( \u2019 **. rb \u2019 , \u2019 . / main . rb \u2019 , File :: FNM_DOTMATCH ) # => true 0:0 1:0 FNM_DOTMATCH Nokta ile ba\u015flayan dosyalarda * kullan\u0131m\u0131na izin ver FNM_EXTGLOB {a,b,c} gibi paternlerde global aramaya izin ver FNM_PATHNAME Path ayra\u00e7lar\u0131nda * kullan\u0131m\u0131n\u0131 engelle FNM_CASEFOLD Case in-sensitive yani b\u00fcy\u00fck/k\u00fc\u00e7\u00fck harf ay\u0131rt etme! File::FNM_NOESCAPE ESCAPE kodu kullan File . fnmatch ( \u2019 * \u2019 , \u2019 / \u2019 , File :: FNM_PATHNAME ) # => false File . fnmatch ( \u2019 FOO * \u2019 , \u2019 foo . rb \u2019 , File :: FNM_CASEFOLD ) # => true File . fnmatch ( \u2019 f { o , a } o * \u2019 , \u2019 foo . rb \u2019 , File :: FNM_EXTGLOB ) # => true File . fnmatch ( \u2019 f { o , a } o * \u2019 , \u2019 fao . rb \u2019 , File :: FNM_EXTGLOB ) # => true File . fnmatch ( \u2019 \\ foo * \u2019 , \u2019 \\ foo . rb \u2019 ) # => false File . fnmatch ( \u2019 \\ foo * \u2019 , \u2019 \\ foo . rb \u2019 , File :: FNM_NOESCAPE ) # => true IO T\u00fcm giri\u015f/\u00e7\u0131k\u0131\u015f (Input/Output) i\u015flerinin kalbi burada atar. File s\u0131n\u0131f\u0131 da IO \u2019nun alt s\u0131n\u0131f\u0131d\u0131r. Binary okuma/yazma i\u015flemleri, multi tasking i\u015flemler ( Process spawning, async i\u015fler ) hep bu s\u0131n\u0131f sayesinde \u00e7al\u0131\u015f\u0131r. Ruby 101 seviyesi i\u00e7in biraz karma\u015f\u0131k olsa dahi, sadece fikriniz olmas\u0131 a\u00e7\u0131s\u0131ndan, en bilinen ve kullan\u0131lan birka\u00e7 method\u2019a de\u011finmek istiyorum. binread Binary read, yani byte-byte okuma i\u015flemi i\u00e7in kullan\u0131l\u0131r. Opsiyonel olarak ge\u00e7ilen 2.parametre, ka\u00e7 byte okumak istedi\u011fimizi, 3.parametre de offset yani ka\u00e7 byte \u00f6teden okumaya ba\u015flamak gerek bunu bildirir. Yani elinizde bir dosya olsun, dosyan\u0131n ilk 100 byte\u2019\u0131n\u0131 20.byte\u2019tan itibaren okuman\u0131z gerekirse kullanaca\u011f\u0131n\u0131z method budur :) # 1 byte atlayarak 3 byte okuduk ve IO . binread ( \"test.png\" , 3 , 1 ) # => \"PNG\" binwrite Tahmin edece\u011finiz gibi binread in tersi, yani Binary olarak yazma i\u015fini yapan method. Ayn\u0131 \u015fekilde opsiyonel 2 ve 3.parametreleri kullanabilirsiniz. copystream Birebir kopya yapmaya yarar. \u0130lk parametre SOURCE yani neyi kopyalacaks\u0131n\u0131z, ikinci parametre DESTINATION yani nereye kopyalacaks\u0131n\u0131z, e\u011fer kullan\u0131rsan\u0131z 3.parametre kopyalanacak byte adedi, e\u011fer 4.parametre kullan\u0131rsan\u0131z ayn\u0131 read/write daki gibi offset de\u011feri olarak kullanabilirsiniz. foreach Elimizde test-file.txt olsun ve i\u00e7inde; sat\u0131r 1 sat\u0131r 2 yazs\u0131n... Sat\u0131r-sat\u0131r i\u00e7inde dola\u015fmak i\u00e7in; IO . foreach ( \"test-file.txt\" ){ | x | print \"bu sat\u0131r: \" , x } Dedi\u011fimizde \u00e7\u0131kt\u0131; bu sat\u0131r: sat\u0131r 1 bu sat\u0131r: sat\u0131r 2 \u015feklinde i\u00e7eriye block pas edip kullanabiliriz. popen Subprocess yani alt i\u015flemler a\u00e7mak i\u00e7in kullan\u0131l\u0131r. \u00d6zellikle Ruby \u00fczerinden SHELL komutlar\u0131 \u00e7a\u011f\u0131rmak i\u00e7in \u00e7ok kullan\u0131lan bir y\u00f6ntemdir. Asenkron i\u015fler. # Bu i\u015flem asenkron/alt i\u015flem olarak \u00e7al\u0131\u015f\u0131r... IO . popen ( \"date\" ) do | response | system_date = response . gets puts \"system_date: #{ system_date } \" end /tmp/ dizinini listeleyelim: p = IO . popen ( \"ls /tmp/\" ) p . pid # => 52389 p . readlines # => [\"D8D75028-234B-4F49-9358-C4C4775B4A08_IN\\n\", \"D8D75028-234B-4F49-9358-C4C4775B4A08_OUT\\n\", \"F7C71944B49B446081C0603DE90E4855_IN\\n\", \"F7C71944B49B446081C0603DE90E4855_OUT\\n\", \"KSOutOfProcessFetcher.501.OlaJUhhgKAnFsX7fZ0FyXTFxIgg=\\n\", \"com.apple.launchd.4H4RVax25p\\n\", \"com.apple.launchd.Kn8Wcx4NQX\\n\", \"fo\\n\", \"lilo.12159\\n\", \"swtag.log\\n\", \"test-file.txt\\n\"] G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi pid yani Process ID : 52389, e\u011fer shell\u2019den; ps ax | grep 52389 derseniz; 52389 ?? Z 0 : 00.00 ( ls ) gibi ilgili i\u015flemi g\u00f6r\u00fcrs\u00fcn\u00fcz.","title":"File System ve IO (Dosya Sistemi)"},{"location":"bolum-05/03-file-system-ve-io-dosya-sistemi/#file-system-ve-io-dosya-sistemi","text":"","title":"File System ve IO (Dosya Sistemi)"},{"location":"bolum-05/03-file-system-ve-io-dosya-sistemi/#file","text":"IO s\u0131n\u0131f\u0131ndan \u00f6zellikler i\u00e7eren File s\u0131n\u0131f\u0131, fiziki dosyalarla i\u015flem yapmam\u0131z\u0131 sa\u011flayan \u00f6zellikleri sunar bize. Ruby\u2019nin \u00fczerinde \u00e7al\u0131\u015ft\u0131\u011f\u0131 i\u015fletim sistemine g\u00f6re de file permission yani dosya \u00fczerindeki yetki sistemi de devrededir. Default olarak gelen Constant\u2019lar\u0131: File . constants # => [:Separator, :SEPARATOR, :ALT_SEPARATOR, :PATH_SEPARATOR, :Constants, :Stat, :WaitReadable, :WaitWritable, :EAGAINWaitReadable, :EAGAINWaitWritable, :EWOULDBLOCKWaitReadable, :EWOULDBLOCKWaitWritable, :EINPROGRESSWaitReadable, :EINPROGRESSWaitWritable, :SEEK_SET, :SEEK_CUR, :SEEK_END, :RDONLY, :WRONLY, :RDWR, :APPEND, :CREAT, :EXCL, :NONBLOCK, :TRUNC, :NOCTTY, :BINARY, :SYNC, :DSYNC, :NOFOLLOW, :LOCK_SH, :LOCK_EX, :LOCK_UN, :LOCK_NB, :NULL, :FNM_NOESCAPE, :FNM_PATHNAME, :FNM_DOTMATCH, :FNM_CASEFOLD, :FNM_EXTGLOB, :FNM_SYSCASE] File :: ALT_SEPARATOR # => nil # Bu Ruby\u2019nin \u00e7al\u0131\u015ft\u0131\u011f\u0131 platforma \u00f6zeldir File :: PATH_SEPARATOR # => \":\" File :: SEPARATOR # => \"/\" File :: Separator # => \"/\" \u00d6rne\u011fin Windows\u2019da \u00e7al\u0131\u015fan Ruby\u2019de SEPARATOR ters slash \\ \u015feklinde gelecektir.","title":"File"},{"location":"bolum-05/03-file-system-ve-io-dosya-sistemi/#public-class-methodlar","text":"absolute_path , expand_path , join , split String olarak verilen path bilgisini absolute path \u2019e \u00e7evirir. E\u011fer ikinci parametre verilmezse CWD ( current working directory ) yani o an i\u00e7in i\u00e7inde \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131z directory bilgisi kullan\u0131l\u0131r. File . absolute_path ( \"~\" ) # => \"/~\" File . absolute_path ( \".gitignore\" , \"~\" ) # => \"/~/.gitignore\" expand_path de bir nevi absolute path\u2019e \u00e7evirir: File . expand_path ( \"~/.gitignore\" ) # => \"/Users/vigo/.gitignore\" Keza daha kompleks path bulma i\u015flerinde de kullan\u0131l\u0131r. Bu durumda __FILE__ sabiti hayat\u0131m\u0131z\u0131 kolayla\u015ft\u0131r\u0131r. O an Ruby script\u2019inin \u00e7al\u0131\u015ft\u0131\u011f\u0131 dosyan\u0131n path\u2019i __FILE__ sabitindedir. \u00d6rne\u011fin a\u015fa\u011f\u0131daki gibi bir directory yap\u0131s\u0131 olsa: proje/ \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 users.rb \u2514\u2500\u2500 main.rb ve lib/users.rb i\u00e7inden, d\u0131\u015far\u0131da bulunan main.rb dosyas\u0131n\u0131n path\u2019ine ula\u015fmak istesek; File . expand_path ( \"../../main.rb\" , __FILE__ ) \u015feklinde kullan\u0131r\u0131z. join kullanarak, Ruby\u2019nin \u00e7al\u0131\u015ft\u0131\u011f\u0131 i\u015fletim sistemine ba\u011fl\u0131 olarak, File::SEPARATOR kullanarak ge\u00e7ilen string\u2019leri birle\u015ftiririz: File . join ( \"usr\" , \"local\" , \"bin\" ) # => \"usr/local/bin\" Dizin ve dosya ayr\u0131\u015ft\u0131rmas\u0131n\u0131 da split ile yapar\u0131z: File . split ( \"usr/local/bin/foo\" ) # => [\"usr/local/bin\", \"foo\"] atime , ctime , mtime Dosyaya son eri\u015filen tarihi atime ile, dosyada yap\u0131lm\u0131\u015f olan son de\u011fi\u015fiklik tarihini de ctime ile, son de\u011fi\u015fiklik zaman\u0131n\u0131 da mtime ile al\u0131r\u0131z. File . atime ( \"/Users/vigo/.gitignore\" ) # => 2014-11-05 11:45:10 +0200 File . ctime ( \"/Users/vigo/.gitignore\" ) # => 2014-08-04 11:33:14 +0300 File . mtime ( \"/Users/vigo/.gitignore\" ) # => 2014-10-29 15:05:15 +0200 basename , dirname , extname Path i\u00e7inden dosya ad\u0131n\u0131 almak i\u00e7in basename kullan\u0131r\u0131z. E\u011fer parametre olarak ataca\u011f\u0131m\u0131z \u015feyi ( \u00f6rne\u011fin extension olarak .gif, .rb gibi ) ge\u00e7ersek bize sadece dosyan\u0131n ad\u0131n\u0131 verir. File . basename ( \"/Users/vigo/test.rb\" ) # => \"test.rb\" File . basename ( \"/Users/vigo/test.rb\" , \".rb\" ) # => \"test\" Bu i\u015fin tersini de dirname ile yapar\u0131z, yani directory ad\u0131 gerekince: File . dirname ( \"/Users/vigo/test.rb\" ) # => \"/Users/vigo\" \u015fekinde kullan\u0131r\u0131z. Dosyan\u0131n extension\u2019\u0131n\u0131 \u00f6\u011frenmek i\u00e7in extname kullan\u0131r\u0131z. File . extname ( \"test_file.rb\" ) # => \".rb\" File . extname ( \"/foo/bar/test_file.rb\" ) # => \".rb\" File . extname ( \"test_file\" ) # => \"\" chmod , chown , lchmod , lchown Her iki komut da Unix\u2019den gelir. Change mod ve Change owner i\u015flerini yapmam\u0131z\u0131 sa\u011flar. chmod ile Unix izinlerini ayarlar\u0131z: -rw-r--r-- 1 vigo wheel 0 Aug 30 19 :19 file-01.txt |||||||||| |||||||| | +--- Others, Execute ( x ) 1 = 2 ^0 |||||||| +---- Others, Write ( w ) 2 = 2 ^1 |||||| | +----- Others, Read ( r ) 4 = 2 ^2 |||||| +------ Group, Execute ( x ) 1 = 2 ^0 |||| | +------- Group, Write ( w ) 2 = 2 ^1 |||| +-------- Group, Read ( r ) 4 = 2 ^2 || | +--------- Owner/User Execute ( e ) 1 = 2 ^0 || +---------- Owner/User Write ( w ) 2 = 2 ^1 | +----------- Owner/User Read ( r ) 4 = 2 ^2 +------------ Is Directory? ( d ) file-01.txt dosyas\u0131nda, User (yani dosyan\u0131n sahibi) R ead ve W rite hakk\u0131na sahiptir. Group ve Others ise sadece R ead hakk\u0131na sahiptir. Bu durumda varolan bu dosyanin chmod de\u011feri: Owner/User : Read, Write = > 4 + 2 = 6 Group : Read = > 4 = 4 Others : Read = > 4 = 4 ---------------------------------------- 644 unix file permission \u015feklindedir. Hatta Terminal\u2019den; stat -f \u2019%A\u2019 file-01.txt yaparsak 644 oldu\u011funu da g\u00f6rebiliriz. \u015eimdi bu dosyay\u0131 Ruby ile sadece sahibi taraf\u0131ndan okunur ve yaz\u0131l\u0131r yap\u0131p, ba\u015fka hi\u00e7bir kimse taraf\u0131ndan okunamaz ve yaz\u0131lamaz hale getirelim: File . chmod ( 0600 , \"file-01.txt\" ) Keza dosyan\u0131n sahibini de d\u00fczenlemek i\u00e7in chown kullan\u0131r\u0131z. Ayn\u0131 terminaldeki gibi KULLANICI:GRUP \u015feklinde, toplamda \u00fc\u00e7 parametre ge\u00e7eriz. \u0130lki kullan\u0131c\u0131y\u0131 belirler. nil ya da -1 ge\u00e7ti\u011fimiz taktirde ilgili \u015feyi set etmemi\u015f oluruz. Yani sadece grubu de\u011fi\u015ftireceksek kullan\u0131c\u0131 i\u00e7in nil ya da -1 ge\u00e7ebiliriz. File . chown ( nil , 20 , \"/tmp/file-01.txt\" ) # => 1 Grup ID olarak 20 ge\u00e7tik, OSX\u2019deki id 20 kar\u015f\u0131l\u0131k olarak staff grubuna denk gelir. lchmod ve lchown ile normal chmod , chown fark\u0131, l ile ba\u015flayanlar sembolik linkleri takip etmezler. ftype , stat , lstat , size Dosyan\u0131n ne t\u00fcr bir dosya oldu\u011funu ftype ile anlar\u0131z: File . ftype ( \"/tmp/file-01.txt\" ) # => \"file\" File . ftype ( \"/usr/\" ) # => \"directory\" File . ftype ( \"/dev/null\" ) # => \"characterSpecial\" stat ile aynen biraz \u00f6nce shell\u2019den yapt\u0131\u011f\u0131m\u0131z ( stat -f \u2019%A\u2019 file-01.txt ) gibi ayn\u0131 i\u015fi Ruby\u2019den de yapabiliriz: File . stat ( \"/tmp/file-01.txt\" ) # => #<File::Stat dev=0x1000004, ino=1540444, mode=0100600, nlink=1, uid=501, gid=20, rdev=0x0, size=4, blksize=4096, blocks=8, atime=2014-11-12 14:41:49 +0200, mtime=2014-11-12 14:40:13 +0200, ctime=2014-11-12 14:45:28 +0200> File . stat ( \"/tmp/file-01.txt\" ) . uid # => 501 File . stat ( \"/tmp/file-01.txt\" ) . gid # => 20 File . stat ( \"/tmp/file-01.txt\" ) . mtime # => 2014-11-12 14:40:13 +0200 lstat da ayn\u0131 i\u015fi yapar fakat ayn\u0131 lchmod ve lchown daki gibi sembolik linkleri takip etmez! Dosyan\u0131n byte cinsinden b\u00fcy\u00fckl\u00fc\u011f\u00fcn\u00fc almak i\u00e7in size kullan\u0131r\u0131z: File . size ( \"/Users/vigo/.gitignore\" ) # => 323 delete , unlink , link , rename , readlink , symlink Her ikisi de dosya silmeye yarar. E\u011fer dosya ba\u015far\u0131yla silinirse 1 d\u00f6ner, aksi halde hata al\u0131r\u0131z! File . delete ( \"/tmp/foo.txt\" ) # => 1 yani silindi File . delete ( \"/tmp/foo1.txt\" ) # => No such file or directory link ile HARD LINK olu\u015fturuyoruz. Bunu dosyan\u0131n bir kopyas\u0131 / yans\u0131mas\u0131 gibi d\u00fc\u015f\u00fcnebilirsiz. Orijinal dosya de\u011fi\u015ftik\u00e7e linklenmi\u015f dosya da g\u00fcncel i\u00e7eri\u011fe sahip olur. Link\u2019in hangi dosyaya ba\u011fl\u0131 oldu\u011funu da readlink ile okuruz: File . link ( \"orijinal_dosya\" , \"linklenecek_dosya\" ) File . readlink ( \"linklenecek_dosya\" ) # => \"orijinal_dosya\" Sembolik link yani symlink i\u00e7in; File . symlink ( \"foo.txt\" , \"bar.txt\" ) # => 0 File . readlink ( \"bar.txt\" ) # => \"foo.txt\" Komut sat\u0131r\u0131ndan bak\u0131nca; - rw - r -- r -- 1 vigo wheel 0 Dec 13 16 : 08 foo . txt lrwxr - xr - x 1 vigo wheel 7 Dec 13 16 : 08 bar . txt -> foo . txt \u015feklinde bar.txt dosyas\u0131n\u0131n foo.txt dosyas\u0131na linklendi\u011fini g\u00f6r\u00fcr\u00fcz. Dosya ismini de\u011fi\u015ftirmek i\u00e7in rename kullan\u0131r\u0131z. File . rename ( \"/tmp/file-01.txt\" , \"/tmp/file-01.txt.bak\" ) # => 0 file? , directory? , executable? , exist? , identical? , readable? , size? , Dosya ger\u00e7ekten fiziki bir dosya m\u0131? ya da directory mi? ya da bu dosya var m\u0131? # file? File . file? ( \"/tmp/file-01.txt\" ) # => true (evet) File . file? ( \"/tmp/file-02.txt\" ) # => false # directory? File . directory? ( \"/tmp/file-02.txt\" ) # => false File . directory? ( \"/tmp/test_folder\" ) # => true (evet) # dosya var m\u0131? File . exist? ( \"/tmp/file-01.txt\" ) # => true (var) File . exist? ( \"/tmp/file-02.txt\" ) # => false Daha \u00f6nce dosya izinlerinden bahsetmi\u015f, baz\u0131 dosyalar\u0131n executable oldu\u011funu s\u00f6ylemi\u015ftik. Acaba dosya \u00e7al\u0131\u015ft\u0131r\u0131labilir yani executable m\u0131? File . executable? ( \"/tmp/file-01.txt\" ) # => false - rw - r -- r -- 1 vigo wheel 0 Nov 15 10 : 39 file - 01 . txt File . executable? ( \"/tmp/execuatable_file\" ) # => true - rwxr - xr - x 1 vigo wheel 0 Nov 15 10 : 43 execuatable_file Executable olan dosyada x flag aktif g\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi :) new , open open method\u2019u ile new ayn\u0131 i\u015fi yapar. Dosya a\u00e7maya yarar. Dosyay\u0131 a\u00e7arken hangi duruma g\u00f6re a\u00e7aca\u011f\u0131m\u0131z\u0131 yani okumak i\u00e7in mi? yazmak i\u00e7in mi? yoksa varolan dosyaya ek yapmak i\u00e7in mi? belirtmemiz gerekir. f = File . new ( \"/tmp/test.txt\" , \"w\" ) f . puts \"Merhaba\" f . close /tmp/test.txt adl\u0131 bir dosya olu\u015fturup i\u00e7ine puts ile Merhaba yazd\u0131k. E\u011fer cat /tmp/test.txt yaparsan\u0131z kontrol edebilirsiniz. Dikkat ettiyseniz mode olarak \"w\" kulland\u0131k. Bu mode\u2019lar neler? Mode A\u00e7\u0131klama r Read-only, sadece okumak i\u00e7in. Bu default mode\u2019dur. r+ Read+write, hatta read + prepend, pointer\u2019\u0131 ba\u015fa al\u0131r, yani bu method\u2019la bi\u015fi yazarsan\u0131z, yazd\u0131\u011f\u0131n\u0131z \u015fey dosyan\u0131n ba\u015f\u0131na eklenir. w Write-only, sadece yazmak i\u00e7indir. E\u011fer dosya yoksa hata verir! w+ Read+Write, hatta read + append, pointer\u2019\u0131 dosyan\u0131n sonuna al\u0131r ve yazd\u0131klar\u0131n\u0131z\u0131 sona ekler. E\u011fer dosya yoksa hata verir! a Write-only, E\u011fer dosya varsa pointer\u2019\u0131 sona al\u0131r ve sona ek yapar, dosya yoksa s\u0131f\u0131rdan yeni dosya \u00fcretir. a+ Read+write, Ayn\u0131 a gibi \u00e7al\u0131\u015f\u0131r, sona ek yapar, hem okumaya hem de yazmaya izin verir. b Binary mode t Text mode fnmatch , fnmatch? File Name Match yani dosya ad\u0131 e\u015fle\u015ftirmek. RegEx pattern\u2019ine g\u00f6re dosya ad\u0131 yakalamak / kontrol etmek i\u00e7in kullan\u0131l\u0131r. 2 zorunlu ve 1 opsiyonel olmak \u00fczere 3 parametre alabilir. Pattern, dosya ad\u0131 ve opsiyonal olarak Flag\u2019ler... File . fnmatch ( \u2019 foo \u2019 , \u2019 foobar . rb \u2019 ) # => false File . fnmatch ( \u2019 foo * \u2019 , \u2019 foobar . rb \u2019 ) # => true File . fnmatch ( \u2019 * foo * \u2019 , \u2019 test_foobar . rb \u2019 ) # => true \u015eimdi; File . fnmatch ( \u2019 **. rb \u2019 , \u2019 . / main . rb \u2019 ) # => false Bu i\u015flemin true d\u00f6nemsi i\u00e7in FNM_DOTMATCH flag\u2019ini kullanaca\u011f\u0131z: File . fnmatch ( \u2019 **. rb \u2019 , \u2019 . / main . rb \u2019 , File :: FNM_DOTMATCH ) # => true 0:0 1:0 FNM_DOTMATCH Nokta ile ba\u015flayan dosyalarda * kullan\u0131m\u0131na izin ver FNM_EXTGLOB {a,b,c} gibi paternlerde global aramaya izin ver FNM_PATHNAME Path ayra\u00e7lar\u0131nda * kullan\u0131m\u0131n\u0131 engelle FNM_CASEFOLD Case in-sensitive yani b\u00fcy\u00fck/k\u00fc\u00e7\u00fck harf ay\u0131rt etme! File::FNM_NOESCAPE ESCAPE kodu kullan File . fnmatch ( \u2019 * \u2019 , \u2019 / \u2019 , File :: FNM_PATHNAME ) # => false File . fnmatch ( \u2019 FOO * \u2019 , \u2019 foo . rb \u2019 , File :: FNM_CASEFOLD ) # => true File . fnmatch ( \u2019 f { o , a } o * \u2019 , \u2019 foo . rb \u2019 , File :: FNM_EXTGLOB ) # => true File . fnmatch ( \u2019 f { o , a } o * \u2019 , \u2019 fao . rb \u2019 , File :: FNM_EXTGLOB ) # => true File . fnmatch ( \u2019 \\ foo * \u2019 , \u2019 \\ foo . rb \u2019 ) # => false File . fnmatch ( \u2019 \\ foo * \u2019 , \u2019 \\ foo . rb \u2019 , File :: FNM_NOESCAPE ) # => true","title":"Public Class Method\u2019lar\u0131"},{"location":"bolum-05/03-file-system-ve-io-dosya-sistemi/#io","text":"T\u00fcm giri\u015f/\u00e7\u0131k\u0131\u015f (Input/Output) i\u015flerinin kalbi burada atar. File s\u0131n\u0131f\u0131 da IO \u2019nun alt s\u0131n\u0131f\u0131d\u0131r. Binary okuma/yazma i\u015flemleri, multi tasking i\u015flemler ( Process spawning, async i\u015fler ) hep bu s\u0131n\u0131f sayesinde \u00e7al\u0131\u015f\u0131r. Ruby 101 seviyesi i\u00e7in biraz karma\u015f\u0131k olsa dahi, sadece fikriniz olmas\u0131 a\u00e7\u0131s\u0131ndan, en bilinen ve kullan\u0131lan birka\u00e7 method\u2019a de\u011finmek istiyorum. binread Binary read, yani byte-byte okuma i\u015flemi i\u00e7in kullan\u0131l\u0131r. Opsiyonel olarak ge\u00e7ilen 2.parametre, ka\u00e7 byte okumak istedi\u011fimizi, 3.parametre de offset yani ka\u00e7 byte \u00f6teden okumaya ba\u015flamak gerek bunu bildirir. Yani elinizde bir dosya olsun, dosyan\u0131n ilk 100 byte\u2019\u0131n\u0131 20.byte\u2019tan itibaren okuman\u0131z gerekirse kullanaca\u011f\u0131n\u0131z method budur :) # 1 byte atlayarak 3 byte okuduk ve IO . binread ( \"test.png\" , 3 , 1 ) # => \"PNG\" binwrite Tahmin edece\u011finiz gibi binread in tersi, yani Binary olarak yazma i\u015fini yapan method. Ayn\u0131 \u015fekilde opsiyonel 2 ve 3.parametreleri kullanabilirsiniz. copystream Birebir kopya yapmaya yarar. \u0130lk parametre SOURCE yani neyi kopyalacaks\u0131n\u0131z, ikinci parametre DESTINATION yani nereye kopyalacaks\u0131n\u0131z, e\u011fer kullan\u0131rsan\u0131z 3.parametre kopyalanacak byte adedi, e\u011fer 4.parametre kullan\u0131rsan\u0131z ayn\u0131 read/write daki gibi offset de\u011feri olarak kullanabilirsiniz. foreach Elimizde test-file.txt olsun ve i\u00e7inde; sat\u0131r 1 sat\u0131r 2 yazs\u0131n... Sat\u0131r-sat\u0131r i\u00e7inde dola\u015fmak i\u00e7in; IO . foreach ( \"test-file.txt\" ){ | x | print \"bu sat\u0131r: \" , x } Dedi\u011fimizde \u00e7\u0131kt\u0131; bu sat\u0131r: sat\u0131r 1 bu sat\u0131r: sat\u0131r 2 \u015feklinde i\u00e7eriye block pas edip kullanabiliriz. popen Subprocess yani alt i\u015flemler a\u00e7mak i\u00e7in kullan\u0131l\u0131r. \u00d6zellikle Ruby \u00fczerinden SHELL komutlar\u0131 \u00e7a\u011f\u0131rmak i\u00e7in \u00e7ok kullan\u0131lan bir y\u00f6ntemdir. Asenkron i\u015fler. # Bu i\u015flem asenkron/alt i\u015flem olarak \u00e7al\u0131\u015f\u0131r... IO . popen ( \"date\" ) do | response | system_date = response . gets puts \"system_date: #{ system_date } \" end /tmp/ dizinini listeleyelim: p = IO . popen ( \"ls /tmp/\" ) p . pid # => 52389 p . readlines # => [\"D8D75028-234B-4F49-9358-C4C4775B4A08_IN\\n\", \"D8D75028-234B-4F49-9358-C4C4775B4A08_OUT\\n\", \"F7C71944B49B446081C0603DE90E4855_IN\\n\", \"F7C71944B49B446081C0603DE90E4855_OUT\\n\", \"KSOutOfProcessFetcher.501.OlaJUhhgKAnFsX7fZ0FyXTFxIgg=\\n\", \"com.apple.launchd.4H4RVax25p\\n\", \"com.apple.launchd.Kn8Wcx4NQX\\n\", \"fo\\n\", \"lilo.12159\\n\", \"swtag.log\\n\", \"test-file.txt\\n\"] G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi pid yani Process ID : 52389, e\u011fer shell\u2019den; ps ax | grep 52389 derseniz; 52389 ?? Z 0 : 00.00 ( ls ) gibi ilgili i\u015flemi g\u00f6r\u00fcrs\u00fcn\u00fcz.","title":"IO"},{"location":"bolum-05/04-exception-handling/","text":"Exception Handling @wip","title":"Exception Handling"},{"location":"bolum-05/04-exception-handling/#exception-handling","text":"@wip","title":"Exception Handling"},{"location":"bolum-05/05-kernel-modulu/","text":"Kernel Mod\u00fcl\u00fc @wip","title":"Kernel Mod\u00fcl\u00fc"},{"location":"bolum-05/05-kernel-modulu/#kernel-modulu","text":"@wip","title":"Kernel Mod\u00fcl\u00fc"},{"location":"bolum-06/","text":"B\u00f6l\u00fcm 6 Bu b\u00f6l\u00fcmde; Monkey Patching Regular Expressions * Time ve Date Nesneleri * Ruby Paketleri: RubyGems Paket Y\u00f6neticisi: Bundler * Komut Sat\u0131r\u0131 (Command-Line) Kullan\u0131m\u0131 * Meta Programming konular\u0131n\u0131 i\u015fleyece\u011fiz","title":"\u0130ndeks"},{"location":"bolum-06/#bolum-6","text":"Bu b\u00f6l\u00fcmde; Monkey Patching Regular Expressions * Time ve Date Nesneleri * Ruby Paketleri: RubyGems Paket Y\u00f6neticisi: Bundler * Komut Sat\u0131r\u0131 (Command-Line) Kullan\u0131m\u0131 * Meta Programming konular\u0131n\u0131 i\u015fleyece\u011fiz","title":"B\u00f6l\u00fcm 6"},{"location":"bolum-06/01-monkey-patching/","text":"Monkey Patching Ruby\u2019nin en \u015faibeli \u00f6zelliklerinden biridir. Kimileri i\u00e7in m\u00fcthi\u015f bir \u015fey kimileri i\u00e7in de \u00e7ok tehlikeli bir \u00f6zelliktir. 7.7\u2019de bahsetti\u011fim Meta Programming konusu ile de \u00e7ok yak\u0131ndan alakal\u0131d\u0131r. Ruby\u2019deki t\u00fcm s\u0131n\u0131flar a\u00e7\u0131kt\u0131r. Yani Kernel\u2019dan gelen herhangi bir s\u0131n\u0131f\u0131 modifiye etmek m\u00fcmk\u00fcnd\u00fcr. Bu durum yanl\u0131\u015f ellerde \u00e7ok tehlikeli olabilir. Yani, String s\u0131n\u0131f\u0131ndaki herhangi bir method\u2019u bozmak m\u00fcmk\u00fcnd\u00fcr. \u00d6rne\u011fin, String#length methodunu de\u011fi\u015ftirelim: \"Hello\" . length # => 5 # Bu normali # Monkey Patching yap\u0131yoruz ve length method\u2019unu de\u011fi\u015ftiriyoruz. class String def length \"Uzunluk: #{ self . size } karakterdir.\" end end \"Hello\" . length # => \"Uzunluk: 5 karakterdir.\" Normal \u015fartlar alt\u0131nda length methodu Fixnum d\u00f6nmesi gerekirken, bozdu\u011fumuz method bize String d\u00f6nd\u00fc. Anlatabilmek i\u00e7in bu denli abart\u0131 bir \u00f6rnek vermek istedim. D\u00fc\u015f\u00fcnsenize, kulland\u0131\u011f\u0131n\u0131z herhangi bir k\u00fct\u00fcphane, kafas\u0131na g\u00f6re, standart olan herhangi bir method\u2019u bu \u015fekilde bozsa? T\u00fcm kodunuz \u00e7orbaya d\u00f6ner ve i\u00e7inden \u00e7\u0131kamaz bir hale gelir. Peki as\u0131l kullan\u0131m amac\u0131 bu mudur? Tabiiki de\u011fil. Bize kolayl\u0131k sa\u011flayan i\u015flerde kullanmam\u0131z gerekiyor. \u00d6rne\u011fin, basit bir matematik i\u015flemi i\u00e7in, 5 kere 5 \u00f6nermesini kullanmak istiyoruz: class Fixnum def kere ( n ) self * n end end Fixnum i\u00e7ine kere diye bir method takt\u0131k. Haydi kullanal\u0131m: 5 . kere ( 5 ) # => 25 5 . kere ( 5 ) . kere ( 2 ) # => 50 \u0130\u015fte bu t\u00fcr bir Monkey Patching i\u015fe yarar ve kullan\u0131labilitesi y\u00fcksek olan bir y\u00f6ntemdir. Keza Ruby on Rails webframework\u2019\u00fc neredeyse bu mant\u0131k \u00fczerine kurulmu\u015ftur. \u00d6rne\u011fin 5 g\u00fcn \u00f6nce \u015feklinde bir \u00f6nerme yapmak istiyoruz. class Fixnum def g\u00fcn self * 24 * 60 * 60 end def \u00f6nce Time . now - self end def sonra Time . now + self end end \u015eimdi \u015f\u00f6yle bir \u015fey yapal\u0131m: Time . now # => 2015-02-09 12:55:33 +0200 5 . g\u00fcn . \u00f6 nce # => 2015-02-04 12:55:33 +0200 1 . g\u00fcn . sonra # => 2015-02-10 12:55:33 +0200 Fixnum yani basit say\u0131lara .g\u00fcn.\u00f6nce ve .g\u00fcn.sonra gibi iki tane method ekledik :)","title":"Monkey Patching"},{"location":"bolum-06/01-monkey-patching/#monkey-patching","text":"Ruby\u2019nin en \u015faibeli \u00f6zelliklerinden biridir. Kimileri i\u00e7in m\u00fcthi\u015f bir \u015fey kimileri i\u00e7in de \u00e7ok tehlikeli bir \u00f6zelliktir. 7.7\u2019de bahsetti\u011fim Meta Programming konusu ile de \u00e7ok yak\u0131ndan alakal\u0131d\u0131r. Ruby\u2019deki t\u00fcm s\u0131n\u0131flar a\u00e7\u0131kt\u0131r. Yani Kernel\u2019dan gelen herhangi bir s\u0131n\u0131f\u0131 modifiye etmek m\u00fcmk\u00fcnd\u00fcr. Bu durum yanl\u0131\u015f ellerde \u00e7ok tehlikeli olabilir. Yani, String s\u0131n\u0131f\u0131ndaki herhangi bir method\u2019u bozmak m\u00fcmk\u00fcnd\u00fcr. \u00d6rne\u011fin, String#length methodunu de\u011fi\u015ftirelim: \"Hello\" . length # => 5 # Bu normali # Monkey Patching yap\u0131yoruz ve length method\u2019unu de\u011fi\u015ftiriyoruz. class String def length \"Uzunluk: #{ self . size } karakterdir.\" end end \"Hello\" . length # => \"Uzunluk: 5 karakterdir.\" Normal \u015fartlar alt\u0131nda length methodu Fixnum d\u00f6nmesi gerekirken, bozdu\u011fumuz method bize String d\u00f6nd\u00fc. Anlatabilmek i\u00e7in bu denli abart\u0131 bir \u00f6rnek vermek istedim. D\u00fc\u015f\u00fcnsenize, kulland\u0131\u011f\u0131n\u0131z herhangi bir k\u00fct\u00fcphane, kafas\u0131na g\u00f6re, standart olan herhangi bir method\u2019u bu \u015fekilde bozsa? T\u00fcm kodunuz \u00e7orbaya d\u00f6ner ve i\u00e7inden \u00e7\u0131kamaz bir hale gelir. Peki as\u0131l kullan\u0131m amac\u0131 bu mudur? Tabiiki de\u011fil. Bize kolayl\u0131k sa\u011flayan i\u015flerde kullanmam\u0131z gerekiyor. \u00d6rne\u011fin, basit bir matematik i\u015flemi i\u00e7in, 5 kere 5 \u00f6nermesini kullanmak istiyoruz: class Fixnum def kere ( n ) self * n end end Fixnum i\u00e7ine kere diye bir method takt\u0131k. Haydi kullanal\u0131m: 5 . kere ( 5 ) # => 25 5 . kere ( 5 ) . kere ( 2 ) # => 50 \u0130\u015fte bu t\u00fcr bir Monkey Patching i\u015fe yarar ve kullan\u0131labilitesi y\u00fcksek olan bir y\u00f6ntemdir. Keza Ruby on Rails webframework\u2019\u00fc neredeyse bu mant\u0131k \u00fczerine kurulmu\u015ftur. \u00d6rne\u011fin 5 g\u00fcn \u00f6nce \u015feklinde bir \u00f6nerme yapmak istiyoruz. class Fixnum def g\u00fcn self * 24 * 60 * 60 end def \u00f6nce Time . now - self end def sonra Time . now + self end end \u015eimdi \u015f\u00f6yle bir \u015fey yapal\u0131m: Time . now # => 2015-02-09 12:55:33 +0200 5 . g\u00fcn . \u00f6 nce # => 2015-02-04 12:55:33 +0200 1 . g\u00fcn . sonra # => 2015-02-10 12:55:33 +0200 Fixnum yani basit say\u0131lara .g\u00fcn.\u00f6nce ve .g\u00fcn.sonra gibi iki tane method ekledik :)","title":"Monkey Patching"},{"location":"bolum-06/02-regular-expressions/","text":"Regular Expressions @wip","title":"Regular Expressions"},{"location":"bolum-06/02-regular-expressions/#regular-expressions","text":"@wip","title":"Regular Expressions"},{"location":"bolum-06/03-time-ve-date-nesneleri/","text":"Time ve Date Nesneleri Zaman, tarih ve saat gibi i\u015flemleri yapmak i\u00e7in Ruby ile birlikte gelen Time ve Date s\u0131n\u0131flar\u0131ndan bahsedece\u011fim. En basit tan\u0131m\u0131yla saatin ka\u00e7 oldu\u011funu ya da now yani \u015fimdi / \u015fu anda y\u0131 bulmak i\u00e7in: Time Time . now # => 2015-04-28 08:49:20 +0300 yapmam\u0131z yeterlidir. Saniye baz\u0131nda ekleme ya da \u00e7\u0131kartma yaparak ba\u015fka zamanlar\u0131 da bulabiliriz. 1 saat \u00f6nceyi bulmak i\u00e7in 60 saniye * 60 dakika yapmam\u0131z yeterli. Time . now - ( 60 * 60 ) # => 2015-04-28 07:51:01 +0300 Hemen Ruby\u2019sel bir hareketle ufak bir \u015fey yapal\u0131m: class Fixnum def seconds self end def minutes self * 60 end def hours self * 60 * 60 end def days self * 60 * 60 * 24 end end # 10 g\u00fcn sonray\u0131 bulal\u0131m Time . now + 10 . days # => 2015-05-08 08:54:02 +0300 Saat farklar\u0131 y\u00fcz\u00fcnden \u00e7e\u015fitli Time Zone \u2019lar mevcut. An itibariyle ( 28 Nisan 2015 ) yerel zamana bakt\u0131\u011f\u0131mda: Time . local ( 2015 , 4 , 28 , 8 , 54 ) # => 2015-04-28 08:54:00 +0300 Peki GMT \u2019ye g\u00f6re durum ne? Time . gm ( 2015 , 4 , 28 , 8 , 54 ) # => 2015-04-28 08:54:00 UTC \u015eimdi kendi istedi\u011fimiz bir zaman\u0131 olu\u015ftural\u0131m. Do\u011fdu\u011fum y\u0131l ve ay\u0131 kullanarak bir zaman olu\u015fturup kabaca hangi g\u00fcne denk geldi\u011fini bulal\u0131m. Sadece YIL ve AY kullan\u0131yoruz! t = Time . new ( 1972 , 8 ) # => 1972-08-01 00:00:00 +0300 t . monday? # => false t . tuesday? # => true Ruby bize otomatik olarak ay\u0131n birini i\u015faret etti ve 1 A\u011fustos 1972\u2019nin sal\u0131 g\u00fcn\u00fcne denk geldi\u011fini tuesday? method\u2019u ile anlad\u0131k. Tahmin edebilece\u011finiz gibi, \u0130ngilizce olarak, g\u00fcnleri kontrol edebiliyoruz. Yani sunday? , monday? ... gibi E\u011fer UNIX\u2019in epoch zaman format\u0131nda istersek, yapmam\u0131z gereken to_i method\u2019u ile integer\u2019a \u00e7evirmek: Time . new ( 1972 , 8 ) . to_i # => 81464400 E\u011fer elimizde epoch cinsinden bir zaman varsa: Time . at ( 81464400 ) # => 1972-08-01 00:00:00 +0300 Time . at ( 81464400 ) . year # => 1972 \u015feklinde de kullanabiliriz. Bunlara ek olarak; Time . now . zone # => \"EEST\" Time . now . day # => 29 Time . now . wday # => 3 # \u00e7ar\u015famba Time . now . utc? # => false Time . now . gmt? # => false Zamanlar aras\u0131ndaki fark\u0131 bulmak i\u00e7in de ayn\u0131 matematik i\u015flemi gibi yaparm\u0131\u015f gibi davranabilirsiniz. birth_day = Time . new ( 1972 , 8 ) # A\u011fustos 1972 Time . now . to_i # => 1430284388 birth_day . to_i # => 81464400 Time . now . to_i - birth_day . to_i # => 1348819988 saniye 1348819870 / ( 60 * 60 * 24 ) # => 15611 g\u00fcn 1348819870 / ( 60 * 60 * 24 * 30 ) # => 520 ay 1348819870 / ( 60 * 60 * 24 * 30 * 12 ) # => 43 y\u0131l Ayni \u015fekilde kar\u015f\u0131la\u015ft\u0131rma i\u015flemleri de matematik i\u015flemleri gibi. Do\u011fdu\u011fum y\u0131l ile bug\u00fcn\u00fc kar\u015f\u0131la\u015ft\u0131ral\u0131m: birth_day = Time . new ( 1972 , 8 ) now = Time . now tomorrow = now + ( 60 * 60 * 24 ) now . to_i # => 1430284645 tomorrow . to_i # => 1430371045 birth_day . to_i # => 81464400 now . to_i > birth_day . to_i # => true bug\u00fcn > do\u011fum tarihi now . to_i > tomorrow . to_i # => false bug\u00fcn < yar\u0131n tomorrow . to_i > now . to_i # => true yar\u0131n > bug\u00fcn Zaman\u0131 Formatl\u0131 \u015eekilde G\u00f6stermek Tarih bilgisini istedi\u011fimiz \u015fekilde format ederek \u00e7\u0131kt\u0131 alabiliriz. t = Time . now t . strftime ( \"Bug\u00fcn %d %B %Y, %A, saat: %H:%M\" ) # => \"Bug\u00fcn 01 May 2015, Friday, saat: 12:35\" Dikkat ettiyseniz \u0130ngilizce olarak \u00e7\u0131kt\u0131y\u0131 ald\u0131k. Ne yaz\u0131k ki Ruby\u2019de locale kavram\u0131 yok. Bu y\u00fczden T\u00fcrk\u00e7e \u00e7\u0131kt\u0131 almak i\u00e7in I18n gem\u2019ini kullanmam\u0131z gerekiyor. $ gem install i18n Daha sonra herhangi bir dizin alt\u0131nda; $ cd ~ $ mkdir i18n-works $ cd i18n-works/ $ mkdir locales $ cd locales/ $ curl -O https://raw.githubusercontent.com/svenfuchs/rails-i18n/master/rails/locale/tr.yml $ cd ../.. $ touch run.rb \u015fimdi run.rb dosyas\u0131 i\u00e7ine; require \u2019 i18n \u2019 I18n . load_path = Dir [ \u2019 . / locales /*. yml \u2019 ] I18n . locale = :tr puts I18n . locale t = Time . now puts I18n . localize t , :format => \"Bug\u00fcn %d %B %Y, %A, saat: %H:%M\" yapt\u0131\u011f\u0131m\u0131zda \u00e7\u0131kt\u0131: tr Bug\u00fcn 01 May\u0131s 2015, Cuma, saat: 12:55 \u015feklinde olacakt\u0131r. Kullan\u0131mda: %<flags><width><modifier><conversion> \u015feklinde bir y\u00f6ntem bulunmakta. Flag\u2019ler - don \u2019 t pad a numerical output _ use spaces for padding 0 use zeros for padding ^ upcase the result string # change case : use colons for % z Hemen \u00f6rneklerle g\u00f6relim, ilk olarak - , _ ve 0 kullan\u0131m\u0131na bakal\u0131m: t = Time . now # => 2015-05-02 11:35:26 +0300 t . strftime ( \"%d\" ) # => \"02\" # \u015fimdi - ile yap\u0131yoruz t . strftime ( \"%-d\" ) # => \"2\" # 0\u2019la doldurmad\u0131... # \u015fimdi _ ile yap\u0131yoruz t . strftime ( \"%_d\" ) # => \" 2\" # SPACE karakteri ile doldurdu... # \u015fimdi 0 ile yap\u0131yoruz t . strftime ( \"%0d\" ) # => \" 02\" # 0 ile doldurdu... \u015eimdi ^ , # ve : flag\u2019lerine bakal\u0131m: t . strftime ( \"%A\" ) # => \"Saturday\" t . strftime ( \"%^A\" ) # => \"SATURDAY\" # upcase yapt\u0131 t . strftime ( \"%#A\" ) # => \"SATURDAY\" # changecase demek, upcase ise down, downcase ise up yapmak demek. # saturday downcase geldi, upcase oldu t . strftime ( \"%z\" ) # => \"+0300\" t . strftime ( \"%:z\" ) # => \"+03:00\" # : ile ay\u0131rd\u0131 width t . strftime ( \"%d\" ) # => \"02\" t . strftime ( \"%10d\" ) # => \"0000000002\" # 10 basamak yapt\u0131. Formatlama \u0130\u015faret A\u00e7\u0131klama %Y 4 dijitli y\u0131l %C y\u0131l/100, y\u00fczy\u0131l i\u00e7in %y y\u0131l mod 100, 2015 i\u00e7in 15 gelir. %m Y\u0131l\u0131n ay\u0131. (01..12) %B Ay\u0131n tam ad\u0131 (January) %b ya da %h Ay\u0131n k\u0131sa ad\u0131 (Jan) %d Ay\u0131n g\u00fcn\u00fc, 0 eklemeli (01..31) %e Ay\u0131n g\u00fcn\u00fc, SPACE karakteri eklemeli ( 1..31) %j Y\u0131l\u0131n g\u00fcn\u00fc (001..366) %H Saat, 24-saat format\u0131nda 0 eklemeli (00..23) %k Saat, 24-saat format\u0131nda SPACE karakteri eklemeli ( 0..23) %I Saat, 12-saat format\u0131nda 0 eklemeli (01..12) %l Saat, 12-saat format\u0131nda SPACE karakteri eklemeli ( 1..12) %P Meridyen g\u00f6stergeci, k\u00fc\u00e7\u00fck harf ( am ya da pm ) %p Meridyen g\u00f6stergeci, b\u00fcy\u00fck harf ( AM ya da PM ) %M Dakika (00..59) %S Saniye (00..60) %L Milisaniye (000..999) %N Kesirli saniye, varsay\u0131lan 9 dijitli %z saat ve dakika ofsetli UTC zaman ku\u015fa\u011f\u0131 (time zone) %Z Zaman ku\u015fa\u011f\u0131n\u0131n harfsel kar\u015f\u0131l\u0131\u011f\u0131 %A Haftan\u0131n g\u00fcn\u00fc, tam yaz\u0131m %a Haftan\u0131n g\u00fcn\u00fc, k\u0131sa yaz\u0131m %u Haftan\u0131n ka\u00e7\u0131nc\u0131 g\u00fcn\u00fc, Pazartesi 1 %w Haftan\u0131n ka\u00e7\u0131nc\u0131 g\u00fcn\u00fc, Pazar 0 %c \"%a %b %e %T %Y\" \u015feklinde %D \"%m/%d/%y\" \u015feklinde %F ISO 8601 - \"%Y-%m-%d\" %v VMS - \"%e-%^b-%4Y\" %x %D ile ayn\u0131 %X %T ile ayn\u0131 %r 12 saat cinsinden saat \"%I:%M:%S %p\" %R 24 saat cinsinden saat \"%H:%M\" %T 23 saat cinsinden saat \"%H:%M:%S\" \u00d6rnek t = Time . now # => 2015-05-16 14:29:43 +0300 t . strftime ( \"%N\" ) # => \"691659000\" t . strftime ( \"%3N\" ) # => \"691\" # milisaniye, 3 dijit t . strftime ( \"%6N\" ) # => \"691659\" # mikrosaniye, 6 dijit t . strftime ( \"%z\" ) # => \"+0300\" t . strftime ( \"%Z\" ) # => \"EEST\" # Eastern European Summer Time yani # yaz saati :) t . strftime ( \"%A\" ) # Sunday t . strftime ( \"%a\" ) # Sun t . strftime ( \"%u\" ) # \"7\" t . strftime ( \"%w\" ) # \"0\" @wip","title":"Time ve Date Nesneleri"},{"location":"bolum-06/03-time-ve-date-nesneleri/#time-ve-date-nesneleri","text":"Zaman, tarih ve saat gibi i\u015flemleri yapmak i\u00e7in Ruby ile birlikte gelen Time ve Date s\u0131n\u0131flar\u0131ndan bahsedece\u011fim. En basit tan\u0131m\u0131yla saatin ka\u00e7 oldu\u011funu ya da now yani \u015fimdi / \u015fu anda y\u0131 bulmak i\u00e7in:","title":"Time ve Date Nesneleri"},{"location":"bolum-06/03-time-ve-date-nesneleri/#time","text":"Time . now # => 2015-04-28 08:49:20 +0300 yapmam\u0131z yeterlidir. Saniye baz\u0131nda ekleme ya da \u00e7\u0131kartma yaparak ba\u015fka zamanlar\u0131 da bulabiliriz. 1 saat \u00f6nceyi bulmak i\u00e7in 60 saniye * 60 dakika yapmam\u0131z yeterli. Time . now - ( 60 * 60 ) # => 2015-04-28 07:51:01 +0300 Hemen Ruby\u2019sel bir hareketle ufak bir \u015fey yapal\u0131m: class Fixnum def seconds self end def minutes self * 60 end def hours self * 60 * 60 end def days self * 60 * 60 * 24 end end # 10 g\u00fcn sonray\u0131 bulal\u0131m Time . now + 10 . days # => 2015-05-08 08:54:02 +0300 Saat farklar\u0131 y\u00fcz\u00fcnden \u00e7e\u015fitli Time Zone \u2019lar mevcut. An itibariyle ( 28 Nisan 2015 ) yerel zamana bakt\u0131\u011f\u0131mda: Time . local ( 2015 , 4 , 28 , 8 , 54 ) # => 2015-04-28 08:54:00 +0300 Peki GMT \u2019ye g\u00f6re durum ne? Time . gm ( 2015 , 4 , 28 , 8 , 54 ) # => 2015-04-28 08:54:00 UTC \u015eimdi kendi istedi\u011fimiz bir zaman\u0131 olu\u015ftural\u0131m. Do\u011fdu\u011fum y\u0131l ve ay\u0131 kullanarak bir zaman olu\u015fturup kabaca hangi g\u00fcne denk geldi\u011fini bulal\u0131m. Sadece YIL ve AY kullan\u0131yoruz! t = Time . new ( 1972 , 8 ) # => 1972-08-01 00:00:00 +0300 t . monday? # => false t . tuesday? # => true Ruby bize otomatik olarak ay\u0131n birini i\u015faret etti ve 1 A\u011fustos 1972\u2019nin sal\u0131 g\u00fcn\u00fcne denk geldi\u011fini tuesday? method\u2019u ile anlad\u0131k. Tahmin edebilece\u011finiz gibi, \u0130ngilizce olarak, g\u00fcnleri kontrol edebiliyoruz. Yani sunday? , monday? ... gibi E\u011fer UNIX\u2019in epoch zaman format\u0131nda istersek, yapmam\u0131z gereken to_i method\u2019u ile integer\u2019a \u00e7evirmek: Time . new ( 1972 , 8 ) . to_i # => 81464400 E\u011fer elimizde epoch cinsinden bir zaman varsa: Time . at ( 81464400 ) # => 1972-08-01 00:00:00 +0300 Time . at ( 81464400 ) . year # => 1972 \u015feklinde de kullanabiliriz. Bunlara ek olarak; Time . now . zone # => \"EEST\" Time . now . day # => 29 Time . now . wday # => 3 # \u00e7ar\u015famba Time . now . utc? # => false Time . now . gmt? # => false Zamanlar aras\u0131ndaki fark\u0131 bulmak i\u00e7in de ayn\u0131 matematik i\u015flemi gibi yaparm\u0131\u015f gibi davranabilirsiniz. birth_day = Time . new ( 1972 , 8 ) # A\u011fustos 1972 Time . now . to_i # => 1430284388 birth_day . to_i # => 81464400 Time . now . to_i - birth_day . to_i # => 1348819988 saniye 1348819870 / ( 60 * 60 * 24 ) # => 15611 g\u00fcn 1348819870 / ( 60 * 60 * 24 * 30 ) # => 520 ay 1348819870 / ( 60 * 60 * 24 * 30 * 12 ) # => 43 y\u0131l Ayni \u015fekilde kar\u015f\u0131la\u015ft\u0131rma i\u015flemleri de matematik i\u015flemleri gibi. Do\u011fdu\u011fum y\u0131l ile bug\u00fcn\u00fc kar\u015f\u0131la\u015ft\u0131ral\u0131m: birth_day = Time . new ( 1972 , 8 ) now = Time . now tomorrow = now + ( 60 * 60 * 24 ) now . to_i # => 1430284645 tomorrow . to_i # => 1430371045 birth_day . to_i # => 81464400 now . to_i > birth_day . to_i # => true bug\u00fcn > do\u011fum tarihi now . to_i > tomorrow . to_i # => false bug\u00fcn < yar\u0131n tomorrow . to_i > now . to_i # => true yar\u0131n > bug\u00fcn","title":"Time"},{"location":"bolum-06/03-time-ve-date-nesneleri/#zaman-formatl-sekilde-gostermek","text":"Tarih bilgisini istedi\u011fimiz \u015fekilde format ederek \u00e7\u0131kt\u0131 alabiliriz. t = Time . now t . strftime ( \"Bug\u00fcn %d %B %Y, %A, saat: %H:%M\" ) # => \"Bug\u00fcn 01 May 2015, Friday, saat: 12:35\" Dikkat ettiyseniz \u0130ngilizce olarak \u00e7\u0131kt\u0131y\u0131 ald\u0131k. Ne yaz\u0131k ki Ruby\u2019de locale kavram\u0131 yok. Bu y\u00fczden T\u00fcrk\u00e7e \u00e7\u0131kt\u0131 almak i\u00e7in I18n gem\u2019ini kullanmam\u0131z gerekiyor. $ gem install i18n Daha sonra herhangi bir dizin alt\u0131nda; $ cd ~ $ mkdir i18n-works $ cd i18n-works/ $ mkdir locales $ cd locales/ $ curl -O https://raw.githubusercontent.com/svenfuchs/rails-i18n/master/rails/locale/tr.yml $ cd ../.. $ touch run.rb \u015fimdi run.rb dosyas\u0131 i\u00e7ine; require \u2019 i18n \u2019 I18n . load_path = Dir [ \u2019 . / locales /*. yml \u2019 ] I18n . locale = :tr puts I18n . locale t = Time . now puts I18n . localize t , :format => \"Bug\u00fcn %d %B %Y, %A, saat: %H:%M\" yapt\u0131\u011f\u0131m\u0131zda \u00e7\u0131kt\u0131: tr Bug\u00fcn 01 May\u0131s 2015, Cuma, saat: 12:55 \u015feklinde olacakt\u0131r. Kullan\u0131mda: %<flags><width><modifier><conversion> \u015feklinde bir y\u00f6ntem bulunmakta. Flag\u2019ler - don \u2019 t pad a numerical output _ use spaces for padding 0 use zeros for padding ^ upcase the result string # change case : use colons for % z Hemen \u00f6rneklerle g\u00f6relim, ilk olarak - , _ ve 0 kullan\u0131m\u0131na bakal\u0131m: t = Time . now # => 2015-05-02 11:35:26 +0300 t . strftime ( \"%d\" ) # => \"02\" # \u015fimdi - ile yap\u0131yoruz t . strftime ( \"%-d\" ) # => \"2\" # 0\u2019la doldurmad\u0131... # \u015fimdi _ ile yap\u0131yoruz t . strftime ( \"%_d\" ) # => \" 2\" # SPACE karakteri ile doldurdu... # \u015fimdi 0 ile yap\u0131yoruz t . strftime ( \"%0d\" ) # => \" 02\" # 0 ile doldurdu... \u015eimdi ^ , # ve : flag\u2019lerine bakal\u0131m: t . strftime ( \"%A\" ) # => \"Saturday\" t . strftime ( \"%^A\" ) # => \"SATURDAY\" # upcase yapt\u0131 t . strftime ( \"%#A\" ) # => \"SATURDAY\" # changecase demek, upcase ise down, downcase ise up yapmak demek. # saturday downcase geldi, upcase oldu t . strftime ( \"%z\" ) # => \"+0300\" t . strftime ( \"%:z\" ) # => \"+03:00\" # : ile ay\u0131rd\u0131 width t . strftime ( \"%d\" ) # => \"02\" t . strftime ( \"%10d\" ) # => \"0000000002\" # 10 basamak yapt\u0131. Formatlama \u0130\u015faret A\u00e7\u0131klama %Y 4 dijitli y\u0131l %C y\u0131l/100, y\u00fczy\u0131l i\u00e7in %y y\u0131l mod 100, 2015 i\u00e7in 15 gelir. %m Y\u0131l\u0131n ay\u0131. (01..12) %B Ay\u0131n tam ad\u0131 (January) %b ya da %h Ay\u0131n k\u0131sa ad\u0131 (Jan) %d Ay\u0131n g\u00fcn\u00fc, 0 eklemeli (01..31) %e Ay\u0131n g\u00fcn\u00fc, SPACE karakteri eklemeli ( 1..31) %j Y\u0131l\u0131n g\u00fcn\u00fc (001..366) %H Saat, 24-saat format\u0131nda 0 eklemeli (00..23) %k Saat, 24-saat format\u0131nda SPACE karakteri eklemeli ( 0..23) %I Saat, 12-saat format\u0131nda 0 eklemeli (01..12) %l Saat, 12-saat format\u0131nda SPACE karakteri eklemeli ( 1..12) %P Meridyen g\u00f6stergeci, k\u00fc\u00e7\u00fck harf ( am ya da pm ) %p Meridyen g\u00f6stergeci, b\u00fcy\u00fck harf ( AM ya da PM ) %M Dakika (00..59) %S Saniye (00..60) %L Milisaniye (000..999) %N Kesirli saniye, varsay\u0131lan 9 dijitli %z saat ve dakika ofsetli UTC zaman ku\u015fa\u011f\u0131 (time zone) %Z Zaman ku\u015fa\u011f\u0131n\u0131n harfsel kar\u015f\u0131l\u0131\u011f\u0131 %A Haftan\u0131n g\u00fcn\u00fc, tam yaz\u0131m %a Haftan\u0131n g\u00fcn\u00fc, k\u0131sa yaz\u0131m %u Haftan\u0131n ka\u00e7\u0131nc\u0131 g\u00fcn\u00fc, Pazartesi 1 %w Haftan\u0131n ka\u00e7\u0131nc\u0131 g\u00fcn\u00fc, Pazar 0 %c \"%a %b %e %T %Y\" \u015feklinde %D \"%m/%d/%y\" \u015feklinde %F ISO 8601 - \"%Y-%m-%d\" %v VMS - \"%e-%^b-%4Y\" %x %D ile ayn\u0131 %X %T ile ayn\u0131 %r 12 saat cinsinden saat \"%I:%M:%S %p\" %R 24 saat cinsinden saat \"%H:%M\" %T 23 saat cinsinden saat \"%H:%M:%S\" \u00d6rnek t = Time . now # => 2015-05-16 14:29:43 +0300 t . strftime ( \"%N\" ) # => \"691659000\" t . strftime ( \"%3N\" ) # => \"691\" # milisaniye, 3 dijit t . strftime ( \"%6N\" ) # => \"691659\" # mikrosaniye, 6 dijit t . strftime ( \"%z\" ) # => \"+0300\" t . strftime ( \"%Z\" ) # => \"EEST\" # Eastern European Summer Time yani # yaz saati :) t . strftime ( \"%A\" ) # Sunday t . strftime ( \"%a\" ) # Sun t . strftime ( \"%u\" ) # \"7\" t . strftime ( \"%w\" ) # \"0\" @wip","title":"Zaman\u0131 Formatl\u0131 \u015eekilde G\u00f6stermek"},{"location":"bolum-06/04-ruby-paketleri-ruby_gems/","text":"Ruby paketleri: RubyGems Ruby, benzeri di\u011fer dillerdeki gibi kendine ait bir paket y\u00f6neticisine sahiptir. Ruby paketlerine Gem denir. Gem\u2019ler asl\u0131nda tekrar tekrar kullan\u0131labilecek Ruby kodlar\u0131n\u0131n paketlenmi\u015f halleridir ve herhangi bir Ruby uygulamas\u0131na \u00e7ok kolay entegre edilebilir. Genelde t\u00fcm paketler http://rubygems.org sitesinde sunulur. \u0130ster local ( yerel ) ister \u00f6zel repository isterseniz de RubyGems sitesinden bu paketleri kurabilirsiniz. Ruby kurulumunda gem ad\u0131nda bir komut eklenir sisteme. E\u011fer gem --help derseniz, ilgili kullan\u0131mlar\u0131 ve komutlar\u0131 listeleyebilirsiniz. RubyGems, efsane isim Jim Weirich taraf\u0131ndan yaz\u0131lm\u0131\u015ft\u0131. Kendisi 2014 \u015eubat\u2019ta aram\u0131zdan ayr\u0131ld\u0131. Herhangi bir paketi kurmak i\u00e7in gem install PAKET_ADI \u015feklinde yazmak yeterli fakat genelde Ruby\u2019nin kurulu oldu\u011fu yer sistem dosyalar\u0131n\u0131n kurulu oldu\u011fu yerde oldu\u011fu i\u00e7in e\u011fer Ruby versiyon y\u00f6neticisi (rvm ya da rbenv) kullanm\u0131yorsan\u0131z sudo ile ile i\u015flem yapman\u0131z gerekir: sudo gem install PAKET_ADI . Tavsiyem Rbenv ya da RVM gibi bir paket y\u00f6neticisi kullanman\u0131z. Bir sonraki b\u00f6l\u00fcmde g\u00f6rece\u011fimiz Bundler arac\u0131yla hem sisteminizi gereksiz gem\u2019lerden korumu\u015f olaca\u011f\u0131z hem de istedi\u011fimiz projede istedi\u011fimiz gem versiyonunu kullanm\u0131\u015f olaca\u011f\u0131z.","title":"Ruby Paketleri: RubyGems"},{"location":"bolum-06/04-ruby-paketleri-ruby_gems/#ruby-paketleri-rubygems","text":"Ruby, benzeri di\u011fer dillerdeki gibi kendine ait bir paket y\u00f6neticisine sahiptir. Ruby paketlerine Gem denir. Gem\u2019ler asl\u0131nda tekrar tekrar kullan\u0131labilecek Ruby kodlar\u0131n\u0131n paketlenmi\u015f halleridir ve herhangi bir Ruby uygulamas\u0131na \u00e7ok kolay entegre edilebilir. Genelde t\u00fcm paketler http://rubygems.org sitesinde sunulur. \u0130ster local ( yerel ) ister \u00f6zel repository isterseniz de RubyGems sitesinden bu paketleri kurabilirsiniz. Ruby kurulumunda gem ad\u0131nda bir komut eklenir sisteme. E\u011fer gem --help derseniz, ilgili kullan\u0131mlar\u0131 ve komutlar\u0131 listeleyebilirsiniz. RubyGems, efsane isim Jim Weirich taraf\u0131ndan yaz\u0131lm\u0131\u015ft\u0131. Kendisi 2014 \u015eubat\u2019ta aram\u0131zdan ayr\u0131ld\u0131. Herhangi bir paketi kurmak i\u00e7in gem install PAKET_ADI \u015feklinde yazmak yeterli fakat genelde Ruby\u2019nin kurulu oldu\u011fu yer sistem dosyalar\u0131n\u0131n kurulu oldu\u011fu yerde oldu\u011fu i\u00e7in e\u011fer Ruby versiyon y\u00f6neticisi (rvm ya da rbenv) kullanm\u0131yorsan\u0131z sudo ile ile i\u015flem yapman\u0131z gerekir: sudo gem install PAKET_ADI . Tavsiyem Rbenv ya da RVM gibi bir paket y\u00f6neticisi kullanman\u0131z. Bir sonraki b\u00f6l\u00fcmde g\u00f6rece\u011fimiz Bundler arac\u0131yla hem sisteminizi gereksiz gem\u2019lerden korumu\u015f olaca\u011f\u0131z hem de istedi\u011fimiz projede istedi\u011fimiz gem versiyonunu kullanm\u0131\u015f olaca\u011f\u0131z.","title":"Ruby paketleri: RubyGems"},{"location":"bolum-06/05-paket-yoneticisi-bundler/","text":"Paket y\u00f6neticisi: Bundler @wip","title":"Paket Y\u00f6neticisi: Bundler"},{"location":"bolum-06/05-paket-yoneticisi-bundler/#paket-yoneticisi-bundler","text":"@wip","title":"Paket y\u00f6neticisi: Bundler"},{"location":"bolum-06/06-komut-satiri-command-line-kullanimi/","text":"Komut Sat\u0131r\u0131 (Command-Line) Kullan\u0131m\u0131 @wip","title":"Komut Sat\u0131r\u0131 (Command-Line) Kullan\u0131m\u0131"},{"location":"bolum-06/06-komut-satiri-command-line-kullanimi/#komut-satr-command-line-kullanm","text":"@wip","title":"Komut Sat\u0131r\u0131 (Command-Line) Kullan\u0131m\u0131"},{"location":"bolum-06/07-meta-programming/","text":"Meta Programming Ruby\u2019deki Meta Programming , yaz\u0131lan kodun run-time \u2019da pek \u00e7ok \u015feyi de\u011fi\u015ftirmesi, Kernel\u2019dan gelen sistem fonksiyonlar\u0131n\u0131 manipule etmesi ( Class, Module, Instance ile ilgili \u015feyler ) \u015feklindedir. Hatta bazen yazd\u0131\u011f\u0131n\u0131z program\u0131 restart etmeden bile kodu de\u011fi\u015fikli\u011fi yapmak m\u00fcmk\u00fcn olur. Baz\u0131 komutlar, kullan\u0131m \u015fekilleri ger\u00e7ekten de \u00e7ok tehlikeli olabilir! \u00d6zellikle d\u0131\u015f d\u00fcnyadan gelecek input\u2019lar\u0131n run-time\u2019da yorumlanmas\u0131 pek de \u00f6nerilen bir y\u00f6ntem de\u011fildir. Yani burada g\u00f6rece\u011fimiz baz\u0131 y\u00f6ntemleri bilelim ama ger\u00e7ek d\u00fcnyada pek fazla uygulamayal\u0131m ! Class\u2019lar De\u011fi\u015ftirilebilir! \u0130ster Kernel ister d\u0131\u015far\u0131dan eklenen, her t\u00fcr Class modifiye edilebilir: class String def foo \"foo: #{ self } \" end end a = \"hello\" a . foo # => \"foo: hello\" String Class\u2019\u0131na kafam\u0131za g\u00f6re foo method\u2019u ekledik. Class\u2019lar\u0131n Birden Fazla initialize Y\u00f6ntemi Olabilir! Bu Class Overloading yani Class ya da method\u2019u ezmek olarak d\u00fc\u015f\u00fcn\u00fclebilir. Class\u2019\u0131n bir tane initialize method\u2019u oldu\u011fu i\u00e7in, ko\u015fullu olarak Class\u2019a ba\u015flang\u0131\u00e7 seviyesinde m\u00fcdahale edebiliriz: # Dortgen.new([sol_ust_x, sol_ust_y], boy, en) # Dortgen.new([sol_ust_x, sol_ust_y], [sag_alt_x, sag_alt_y]) class Dortgen def initialize ( * args ) if args . size < 2 || args . size > 3 \"Bu s\u0131n\u0131f en az 2 en fazla 3 parametre al\u0131r\" else \"Do\u011fru parametre kullan\u0131m\u0131\" end end end Dortgen . new ( [ 0 , 0 ] , 10 , 10 ) # => #<Dortgen:0x007fe3ea1330f0> Dortgen . new ( [ 0 , 0 ] , [ 10 , 10 ] ) # => #<Dortgen:0x007fe3ea132d58> \u0130ster 2, ister 3 parametre ile initialize etti\u011fimiz Dortgen s\u0131n\u0131f\u0131, parametre kullan\u0131m\u0131na g\u00f6re farkl\u0131 \u00e7\u0131kt\u0131lar \u00fcretebilir. Anonim Class Anonim Class\u2019lar, Singleton , Ghost ya da Metaclass diye de adland\u0131r\u0131l\u0131r. Asl\u0131nda her Ruby Class\u2019\u0131 kendine ait anonim bir s\u0131n\u0131fa ve method\u2019lara sahiptir. Tek fark\u0131 kendisine ait olmas\u0131d\u0131r. class Developer class << self def personality \"Awesome\" end end end Developer . new # => #<Developer:0x007fc9048a2738> Developer . personality # => \"Awesome\" a = Developer . new a # => #<Developer:0x007fc9048a2120> a . class # => Developer a . class . personality # => \"Awesome\" a . personality # => undefined method `personality\u2019 for #<Developer:0x007fd3ca0a0e10> (NoMethodError) Developer s\u0131n\u0131f\u0131n\u0131n kendi class \u2019\u0131na anonim bir method takt\u0131k. Class\u2019dan instance \u00fcretmeden Developer.personality \u015feklinde eri\u015febilirken, a instance\u2019\u0131ndan gitmek istedi\u011fimizde yani a.personality dedi\u011fimizde hata mesaj\u0131 ald\u0131k. Oysa o methods sadece a.class a ait :) Yapt\u0131\u011f\u0131m\u0131z i\u015f asl\u0131nda bir Singleton olu\u015fturma oldu. define_method Class i\u00e7inde run-time yani dinamik olarak method olu\u015fturabilirsiniz: class Developer define_method :personality do | arg | \"You are #{ arg } developer!\" end end Developer . new . personality ( \"an awesome\" ) # => \"You are an awesome developer!\" a = Developer . new a . personality ( \"an awesome\" ) # => \"You are an awesome developer!\" a . class . instance_methods ( false ) # => [:personality] send send method\u2019u Object s\u0131n\u0131f\u0131ndan gelen bir method\u2019dur. S\u0131n\u0131fa g\u00f6nderece\u011fimiz mesaj ilk parametre olup bu da asl\u0131nda \u00e7a\u011f\u0131raca\u011f\u0131m\u0131z method ad\u0131d\u0131r. class Developer def hello ( * args ) \"Hello #{ args . join ( \" \" ) } \" end end d = Developer . new d . send ( :hello , \"vigo\" , \"how are you?\" ) # => \"Hello vigo how are you?\" Unutmay\u0131n, sadece public method\u2019lara eri\u015febilirsiniz! remove_method ve undef_method Ad\u0131ndan da anla\u015f\u0131laca\u011f\u0131 gibi method\u2019u yoketmek i\u00e7in kullan\u0131l\u0131r ama e\u011fer remove_method ile iptal edilmek istenilen method, t\u00fcredi\u011fi \u00fcst s\u0131n\u0131f\u0131nda var ise ne yaz\u0131k ki yok edilemez. Bu durumda da undef_method devreye girer: class Developer def method_missing ( m , * args , & block ) \" #{ m } is not available!\" end def hello \"Hello from class Developer\" end end class TurkishDeveloper < Developer def hello \"Hello from class TurkishDeveloper\" end end d = TurkishDeveloper . new d . hello # => \"Hello from class TurkishDeveloper\" class TurkishDeveloper remove_method :hello end d . hello # => \"Hello from class Developer\" # \u00fcst s\u0131n\u0131fta varoldu\u011fu i\u00e7in \u00e7al\u0131\u015ft\u0131! E\u011fer; class TurkishDeveloper undef_method :hello end d . hello # => \"hello is not available!\" yaparsak, method komple u\u00e7ar ve method_missing ile yakalad\u0131\u011f\u0131m\u0131z kod blo\u011fu \u00e7al\u0131\u015f\u0131r. eval Pek \u00e7ok programlama dilinde evaluate etmekten gelen, yani String formundaki metnin \u00e7al\u0131\u015fabilir kod par\u00e7as\u0131 haline gelmesi olay\u0131d\u0131r eval : eval ( \"5 + 5\" ) # => 10 eval ( \u2019 \"Hello\" . downcase \u2019 ) # => \"hello\" Asl\u0131nda \u00e7ok tehlikelidir. Yani programatik hi\u00e7bir kontrol olmadan d\u00fcmd\u00fcz metnin executable hale getirilmesidir ve hi\u00e7bir zaman \u00f6nerilmez. G\u00fcvenlik zafiyeti do\u011furabilir. instance_eval Yaz\u0131lan kod blo\u011funu sanki Class\u2019\u0131n bir method\u2019uymu\u015f gibi \u00e7al\u0131\u015ft\u0131r\u0131r: class Developer def initialize @star = 10 end end d = Developer . new d . instance_eval do puts self puts @star end # #<Developer:0x007fe549a91e70> # 10 ya da; class Developer end Developer . instance_eval do def who \"vigo\" end end Developer . who # => \"vigo\" \u015feklinde kullan\u0131l\u0131r. Ayn\u0131 \u015fekilde sadece public olan method\u2019lar i\u00e7in ge\u00e7erlidir. module_eval ve class_eval \u0130kisi de ayn\u0131 i\u015fi yapar. D\u0131\u015far\u0131dan Class de\u011fi\u015fkenlerine eri\u015fmek i\u00e7in kullan\u0131l\u0131r: class Developer @@geek_rate = 10 end Developer . class_eval ( \"@@geek_rate\" ) # => 10 Ayn\u0131 \u015fekilde method tan\u0131mlamak i\u00e7in; class Developer end Developer . class_eval do def who \"vigo\" end end Developer . new . who # => \"vigo\" class_variable_get ve class_variable_set Class konusunda Class ve Instance Variables aras\u0131ndaki fark\u0131 g\u00f6rm\u00fc\u015ft\u00fck. Bu iki method yard\u0131m\u0131yla s\u0131n\u0131f de\u011fi\u015fkenine eri\u015fmek ve de\u011ferini de\u011fi\u015ftirmek m\u00fcmk\u00fcn: class Developer @@geek_rate = 10 end Developer . class_variable_set ( :@@geek_rate , \"100\" ) # => \"100\" Developer . class_variable_get ( :@@geek_rate ) # => \"100\" instance_variable_get ve instance_variable_set Ayn\u0131 \u00f6nceki gibi, bu method\u2019lar da sadece Instance Variable i\u00e7in \u00e7al\u0131\u015f\u0131r: class Developer def initialize ( name , star ) @name = name @star = star end def show \"Name: #{ @name } , Star: #{ @star } \" end end d = Developer . new ( \"vigo\" , 10 ) d . instance_variable_get ( :@name ) # => \"vigo\" d . instance_variable_get ( :@star ) # => 10 d . show # => \"Name: vigo, Star: 10\" d . instance_variable_set ( :@name , \"lego\" ) # => \"lego\" d . show # => \"Name: lego, Star: 10\" const_get ve const_set Constant yani sabitleri Class ve Module konusunda g\u00f6rm\u00fc\u015ft\u00fck. const_set ile Class\u2019a sabit de\u011fer at\u0131yoruz, const_get ile de ilgili de\u011feri okuyoruz: class Box end Box . const_set ( \"NAME\" , \"web\" ) # => \"web\" Box . const_get ( \"NAME\" ) # => \"web\" Box :: NAME # => \"web\" a = Box . new a . class . constants # => [:NAME] a . class :: NAME # => \"web\"","title":"Meta Programming"},{"location":"bolum-06/07-meta-programming/#meta-programming","text":"Ruby\u2019deki Meta Programming , yaz\u0131lan kodun run-time \u2019da pek \u00e7ok \u015feyi de\u011fi\u015ftirmesi, Kernel\u2019dan gelen sistem fonksiyonlar\u0131n\u0131 manipule etmesi ( Class, Module, Instance ile ilgili \u015feyler ) \u015feklindedir. Hatta bazen yazd\u0131\u011f\u0131n\u0131z program\u0131 restart etmeden bile kodu de\u011fi\u015fikli\u011fi yapmak m\u00fcmk\u00fcn olur. Baz\u0131 komutlar, kullan\u0131m \u015fekilleri ger\u00e7ekten de \u00e7ok tehlikeli olabilir! \u00d6zellikle d\u0131\u015f d\u00fcnyadan gelecek input\u2019lar\u0131n run-time\u2019da yorumlanmas\u0131 pek de \u00f6nerilen bir y\u00f6ntem de\u011fildir. Yani burada g\u00f6rece\u011fimiz baz\u0131 y\u00f6ntemleri bilelim ama ger\u00e7ek d\u00fcnyada pek fazla uygulamayal\u0131m !","title":"Meta Programming"},{"location":"bolum-06/07-meta-programming/#classlar-degistirilebilir","text":"\u0130ster Kernel ister d\u0131\u015far\u0131dan eklenen, her t\u00fcr Class modifiye edilebilir: class String def foo \"foo: #{ self } \" end end a = \"hello\" a . foo # => \"foo: hello\" String Class\u2019\u0131na kafam\u0131za g\u00f6re foo method\u2019u ekledik.","title":"Class\u2019lar De\u011fi\u015ftirilebilir!"},{"location":"bolum-06/07-meta-programming/#classlarn-birden-fazla-initialize-yontemi-olabilir","text":"Bu Class Overloading yani Class ya da method\u2019u ezmek olarak d\u00fc\u015f\u00fcn\u00fclebilir. Class\u2019\u0131n bir tane initialize method\u2019u oldu\u011fu i\u00e7in, ko\u015fullu olarak Class\u2019a ba\u015flang\u0131\u00e7 seviyesinde m\u00fcdahale edebiliriz: # Dortgen.new([sol_ust_x, sol_ust_y], boy, en) # Dortgen.new([sol_ust_x, sol_ust_y], [sag_alt_x, sag_alt_y]) class Dortgen def initialize ( * args ) if args . size < 2 || args . size > 3 \"Bu s\u0131n\u0131f en az 2 en fazla 3 parametre al\u0131r\" else \"Do\u011fru parametre kullan\u0131m\u0131\" end end end Dortgen . new ( [ 0 , 0 ] , 10 , 10 ) # => #<Dortgen:0x007fe3ea1330f0> Dortgen . new ( [ 0 , 0 ] , [ 10 , 10 ] ) # => #<Dortgen:0x007fe3ea132d58> \u0130ster 2, ister 3 parametre ile initialize etti\u011fimiz Dortgen s\u0131n\u0131f\u0131, parametre kullan\u0131m\u0131na g\u00f6re farkl\u0131 \u00e7\u0131kt\u0131lar \u00fcretebilir.","title":"Class\u2019lar\u0131n Birden Fazla initialize Y\u00f6ntemi Olabilir!"},{"location":"bolum-06/07-meta-programming/#anonim-class","text":"Anonim Class\u2019lar, Singleton , Ghost ya da Metaclass diye de adland\u0131r\u0131l\u0131r. Asl\u0131nda her Ruby Class\u2019\u0131 kendine ait anonim bir s\u0131n\u0131fa ve method\u2019lara sahiptir. Tek fark\u0131 kendisine ait olmas\u0131d\u0131r. class Developer class << self def personality \"Awesome\" end end end Developer . new # => #<Developer:0x007fc9048a2738> Developer . personality # => \"Awesome\" a = Developer . new a # => #<Developer:0x007fc9048a2120> a . class # => Developer a . class . personality # => \"Awesome\" a . personality # => undefined method `personality\u2019 for #<Developer:0x007fd3ca0a0e10> (NoMethodError) Developer s\u0131n\u0131f\u0131n\u0131n kendi class \u2019\u0131na anonim bir method takt\u0131k. Class\u2019dan instance \u00fcretmeden Developer.personality \u015feklinde eri\u015febilirken, a instance\u2019\u0131ndan gitmek istedi\u011fimizde yani a.personality dedi\u011fimizde hata mesaj\u0131 ald\u0131k. Oysa o methods sadece a.class a ait :) Yapt\u0131\u011f\u0131m\u0131z i\u015f asl\u0131nda bir Singleton olu\u015fturma oldu. define_method Class i\u00e7inde run-time yani dinamik olarak method olu\u015fturabilirsiniz: class Developer define_method :personality do | arg | \"You are #{ arg } developer!\" end end Developer . new . personality ( \"an awesome\" ) # => \"You are an awesome developer!\" a = Developer . new a . personality ( \"an awesome\" ) # => \"You are an awesome developer!\" a . class . instance_methods ( false ) # => [:personality] send send method\u2019u Object s\u0131n\u0131f\u0131ndan gelen bir method\u2019dur. S\u0131n\u0131fa g\u00f6nderece\u011fimiz mesaj ilk parametre olup bu da asl\u0131nda \u00e7a\u011f\u0131raca\u011f\u0131m\u0131z method ad\u0131d\u0131r. class Developer def hello ( * args ) \"Hello #{ args . join ( \" \" ) } \" end end d = Developer . new d . send ( :hello , \"vigo\" , \"how are you?\" ) # => \"Hello vigo how are you?\" Unutmay\u0131n, sadece public method\u2019lara eri\u015febilirsiniz! remove_method ve undef_method Ad\u0131ndan da anla\u015f\u0131laca\u011f\u0131 gibi method\u2019u yoketmek i\u00e7in kullan\u0131l\u0131r ama e\u011fer remove_method ile iptal edilmek istenilen method, t\u00fcredi\u011fi \u00fcst s\u0131n\u0131f\u0131nda var ise ne yaz\u0131k ki yok edilemez. Bu durumda da undef_method devreye girer: class Developer def method_missing ( m , * args , & block ) \" #{ m } is not available!\" end def hello \"Hello from class Developer\" end end class TurkishDeveloper < Developer def hello \"Hello from class TurkishDeveloper\" end end d = TurkishDeveloper . new d . hello # => \"Hello from class TurkishDeveloper\" class TurkishDeveloper remove_method :hello end d . hello # => \"Hello from class Developer\" # \u00fcst s\u0131n\u0131fta varoldu\u011fu i\u00e7in \u00e7al\u0131\u015ft\u0131! E\u011fer; class TurkishDeveloper undef_method :hello end d . hello # => \"hello is not available!\" yaparsak, method komple u\u00e7ar ve method_missing ile yakalad\u0131\u011f\u0131m\u0131z kod blo\u011fu \u00e7al\u0131\u015f\u0131r. eval Pek \u00e7ok programlama dilinde evaluate etmekten gelen, yani String formundaki metnin \u00e7al\u0131\u015fabilir kod par\u00e7as\u0131 haline gelmesi olay\u0131d\u0131r eval : eval ( \"5 + 5\" ) # => 10 eval ( \u2019 \"Hello\" . downcase \u2019 ) # => \"hello\" Asl\u0131nda \u00e7ok tehlikelidir. Yani programatik hi\u00e7bir kontrol olmadan d\u00fcmd\u00fcz metnin executable hale getirilmesidir ve hi\u00e7bir zaman \u00f6nerilmez. G\u00fcvenlik zafiyeti do\u011furabilir. instance_eval Yaz\u0131lan kod blo\u011funu sanki Class\u2019\u0131n bir method\u2019uymu\u015f gibi \u00e7al\u0131\u015ft\u0131r\u0131r: class Developer def initialize @star = 10 end end d = Developer . new d . instance_eval do puts self puts @star end # #<Developer:0x007fe549a91e70> # 10 ya da; class Developer end Developer . instance_eval do def who \"vigo\" end end Developer . who # => \"vigo\" \u015feklinde kullan\u0131l\u0131r. Ayn\u0131 \u015fekilde sadece public olan method\u2019lar i\u00e7in ge\u00e7erlidir. module_eval ve class_eval \u0130kisi de ayn\u0131 i\u015fi yapar. D\u0131\u015far\u0131dan Class de\u011fi\u015fkenlerine eri\u015fmek i\u00e7in kullan\u0131l\u0131r: class Developer @@geek_rate = 10 end Developer . class_eval ( \"@@geek_rate\" ) # => 10 Ayn\u0131 \u015fekilde method tan\u0131mlamak i\u00e7in; class Developer end Developer . class_eval do def who \"vigo\" end end Developer . new . who # => \"vigo\" class_variable_get ve class_variable_set Class konusunda Class ve Instance Variables aras\u0131ndaki fark\u0131 g\u00f6rm\u00fc\u015ft\u00fck. Bu iki method yard\u0131m\u0131yla s\u0131n\u0131f de\u011fi\u015fkenine eri\u015fmek ve de\u011ferini de\u011fi\u015ftirmek m\u00fcmk\u00fcn: class Developer @@geek_rate = 10 end Developer . class_variable_set ( :@@geek_rate , \"100\" ) # => \"100\" Developer . class_variable_get ( :@@geek_rate ) # => \"100\" instance_variable_get ve instance_variable_set Ayn\u0131 \u00f6nceki gibi, bu method\u2019lar da sadece Instance Variable i\u00e7in \u00e7al\u0131\u015f\u0131r: class Developer def initialize ( name , star ) @name = name @star = star end def show \"Name: #{ @name } , Star: #{ @star } \" end end d = Developer . new ( \"vigo\" , 10 ) d . instance_variable_get ( :@name ) # => \"vigo\" d . instance_variable_get ( :@star ) # => 10 d . show # => \"Name: vigo, Star: 10\" d . instance_variable_set ( :@name , \"lego\" ) # => \"lego\" d . show # => \"Name: lego, Star: 10\" const_get ve const_set Constant yani sabitleri Class ve Module konusunda g\u00f6rm\u00fc\u015ft\u00fck. const_set ile Class\u2019a sabit de\u011fer at\u0131yoruz, const_get ile de ilgili de\u011feri okuyoruz: class Box end Box . const_set ( \"NAME\" , \"web\" ) # => \"web\" Box . const_get ( \"NAME\" ) # => \"web\" Box :: NAME # => \"web\" a = Box . new a . class . constants # => [:NAME] a . class :: NAME # => \"web\"","title":"Anonim Class"},{"location":"bolum-07/","text":"B\u00f6l\u00fcm 7 Bu b\u00f6l\u00fcmde; Kod Yazma Tarz\u0131 (Style Guide) konular\u0131n\u0131 i\u015fleyece\u011fiz","title":"\u0130ndeks"},{"location":"bolum-07/#bolum-7","text":"Bu b\u00f6l\u00fcmde; Kod Yazma Tarz\u0131 (Style Guide) konular\u0131n\u0131 i\u015fleyece\u011fiz","title":"B\u00f6l\u00fcm 7"},{"location":"bolum-07/01-kod-yazma-tarzi-style-guide/","text":"Kod Yazma Tarz\u0131 (Style Guide) A\u015fa\u011f\u0131daki kurallar, kodun do\u011fru \u00e7al\u0131\u015fmas\u0131ndan ziyade, kullan\u0131c\u0131 taraf\u0131ndan do\u011fru okunup alg\u0131lanmas\u0131 i\u00e7in d\u00fc\u015f\u00fcn\u00fclm\u00fc\u015f, kabul edilmi\u015f kurallard\u0131r. Ruby\u2019e ait resmi bir durum olmasa da, genelde t\u00fcm kullan\u0131c\u0131lar bu kurallara uymaya \u00e7al\u0131\u015f\u0131r. Bu kurallar\u0131 ben GitHub \u2019dan ald\u0131m. soft-tabs yani TAB karakteri yerine 2 adet space karakteri ile girinti yap\u0131lmal\u0131 M\u00fcmk\u00fcnse sat\u0131r uzunlu\u011fu 80 karakteri ge\u00e7mesin! Sat\u0131r sonlar\u0131nda bo\u015f karakter white-space b\u0131rakmay\u0131n! Her rb dosyas\u0131 ya da Ruby kodu i\u00e7eren dosya bo\u015f bir sat\u0131rla bitsin. Operat\u00f6rler, virg\u00fcl, iki nokta, noktal\u0131 virg\u00fcl, { ve } lerin etraf\u0131nda mutlaka bo\u015fluk space karakteri olsun! Yanl\u0131\u015f a = 1 a , b = 1 , 3 1 > 2 ? true :false ; puts \"Merhaba\" [ 1 , 2 , 3 ]. each { | n | puts n } Do\u011fru a = 1 a , b = 1 , 3 1 > 2 ? true : false ; puts \"Merhaba\" [ 1 , 2 , 3 ]. each { | n | puts n } Parantez ve K\u00f6\u015feli parantez kullan\u0131rken, ne \u00f6ncesine ne de sonras\u0131na bo\u015f karakter space koyma! Do\u011fru my_method ( arg1 , arg2 ) . other [ 1 , 2 , 3 ]. length \u00dcnlemden sonra bo\u015f karakter space kullanma !array.include?(element) when ve case kullan\u0131rken girinti durumunu a\u015fa\u011f\u0131daki gibi yap: case when song . name == \"Misty\" puts \"Not again!\" when song . duration > 120 puts \"Too long!\" when Time . now . hour > 21 puts \"It\u2019s too late\" else song . play end kind = case year when 1850 .. 1889 then \"Blues\" when 1890 .. 1909 then \"Ragtime\" when 1910 .. 1929 then \"New Orleans Jazz\" when 1930 .. 1939 then \"Swing\" when 1940 .. 1950 then \"Bebop\" else \"Jazz\" end Method\u2019lar aras\u0131nda 1 sat\u0131r bo\u015fluk ver, gerekiyorsa mant\u0131kl\u0131 bir \u015fekilde i\u00e7eride ayr\u0131m yap! def some_method data = initialize ( options ) data . manipulate! data . result end def some_method result end Syntax E\u011fer method\u2019a parametre ge\u00e7iyorsan parantez yaz! def some_method # arg\u00fcmans\u0131z end def some_method_with_arguments ( arg1 , arg2 ) # arg\u00fcmanl\u0131 end for kullan\u0131m\u0131na dikkat edin, kafan\u0131za g\u00f6re heryerde kullanmay\u0131n: arr = [ 1 , 2 , 3 ] # k\u00f6t\u00fc \u00f6rnek for i in arr do puts i end # iyi \u00f6rnek arr . each { | i | puts i } \u0130\u00e7 i\u00e7e ternary kullanmaktan ka\u00e7\u0131n\u0131n! Okunabilirli\u011fi azalt\u0131yor! # k\u00f6t\u00fc some_condition ? ( nested_condition ? nested_something : nested_something_else ) : something_else # iyi if some_condition nested_condition ? nested_something : nested_something_else else something_else end and ve or yerine && ve || kullan\u0131n M\u00fcmk\u00fcn olduk\u00e7a if leri tek sat\u0131r \u015feklinde kullan\u0131n: # k\u00f6t\u00fc if some_condition do_something end # iyi do_something if some_condition unless i\u00e7inde else kullanmaktan ka\u00e7\u0131n\u0131n: # k\u00f6t\u00fc unless success? puts \"hata\" else puts \"ok\" end # good if success? puts \"ok\" else puts \"hata\" end Tek sat\u0131rl\u0131k blok i\u015flerinde { } , \u00e7ok sat\u0131rl\u0131k blok i\u015flerinde do end kullan\u0131n. return kelimesini gerekmedik\u00e7e kullanmay\u0131n. Method\u2019larda parametre olarak default de\u011fer atarken = etraf\u0131nda space kullan\u0131n. # k\u00f6t\u00fc def some_method ( arg1 = :default , arg2 = nil , arg3 =[] ) # kod... end # iyi def some_method ( arg1 = :default , arg2 = nil , arg3 = [] ) # kod... end Varl\u0131k operat\u00f6r\u00fc kullanmaktan \u00e7ekinmeyin! # e\u011fer isim nil ya da false ise isim de\u011fi\u015fkenine \"vigo\" ata isim ||= \"vigo\" Boolean de\u011ferler i\u00e7in ||= kullanmay\u0131n! # k\u00f6t\u00fc enabled ||= true # iyi enabled = true if enabled . nil? Parantezli kullan\u0131mda method\u2019dan sonra space kullanmay\u0131n: # k\u00f6t\u00fc f ( 3 + 2 ) + 1 # iyi f ( 3 + 2 ) + 1 Block i\u00e7inde kullanmayaca\u011f\u0131n\u0131z de\u011fi\u015fken i\u00e7in de\u011fer atamas\u0131 yapmay\u0131n: # k\u00f6t\u00fc, k bo\u015fa gitti result = hash . map { | k , v | v + 1 } # iyi result = hash . map { | _ , v | v + 1 } Veri tipi kontrol\u00fc i\u00e7in === kullanmay\u0131n! is_a ya da kind_of? kullan\u0131n. Naming (\u0130simlendirmeler) Method ve de\u011fi\u015fken isimleri i\u00e7in snake_case kullan\u0131n. Class ve Mod\u00fcl i\u00e7in CamelCase kullan\u0131n. Constant i\u00e7in SCREAMING_SNAKE_CASE kullan\u0131n. Boolean sonu\u00e7 d\u00f6nen method\u2019lar ? ile bitmeli: User.is_valid? Tehlike, nesneyi modifiye eden / de\u011fi\u015ftiren method\u2019lar ! ile bitmeli! User.delete! Class Singleton tan\u0131mlarken self kullan\u0131n: class TestClass # k\u00f6t\u00fc def TestClass . some_method # kod end # iyi def self . some_other_method # kod end end private , public , protected olan method\u2019larda girintileme method ad\u0131yla ayn\u0131 hizada olsun ve ilgili method\u2019un bir \u00fcst sat\u0131r\u0131 bo\u015f kals\u0131n: class SomeClass def public_method # ... end private def private_method # ... end end Exceptions Ak\u0131\u015f kontol\u00fc i\u00e7in kullanmay\u0131n! # k\u00f6t\u00fc begin n / d rescue ZeroDivisionError puts \"0\u2019a b\u00f6l\u00fcnme hatas\u0131!\" end # iyi if d . zero? puts \"0\u2019a b\u00f6l\u00fcnme hatas\u0131!\" else n / d end Di\u011fer String\u2019leri concat ederken interpolasyon kullan\u0131n: # k\u00f6t\u00fc email_with_name = user . name + \" <\" + user . email + \">\" # iyi email_with_name = \" #{ user . name } < #{ user . email } >\" Gerekmedik\u00e7e de\u011fer atamalar\u0131nda tek t\u0131rnak \u2019 kullanmay\u0131n, \u00e7ift t\u0131rna\u011f\u0131 tercih edin \" String concat i\u015flerinde Array \u2019e ekleme tekni\u011fini kullanabilirsiniz, h\u0131zl\u0131 da olur: html = \"\" html << \"<h1>Page title</h1>\" paragraphs . each do | paragraph | html << \"<p> #{ paragraph } </p>\" end","title":"Kod Yazma Tarz\u0131 (Style Guide)"},{"location":"bolum-07/01-kod-yazma-tarzi-style-guide/#kod-yazma-tarz-style-guide","text":"A\u015fa\u011f\u0131daki kurallar, kodun do\u011fru \u00e7al\u0131\u015fmas\u0131ndan ziyade, kullan\u0131c\u0131 taraf\u0131ndan do\u011fru okunup alg\u0131lanmas\u0131 i\u00e7in d\u00fc\u015f\u00fcn\u00fclm\u00fc\u015f, kabul edilmi\u015f kurallard\u0131r. Ruby\u2019e ait resmi bir durum olmasa da, genelde t\u00fcm kullan\u0131c\u0131lar bu kurallara uymaya \u00e7al\u0131\u015f\u0131r. Bu kurallar\u0131 ben GitHub \u2019dan ald\u0131m. soft-tabs yani TAB karakteri yerine 2 adet space karakteri ile girinti yap\u0131lmal\u0131 M\u00fcmk\u00fcnse sat\u0131r uzunlu\u011fu 80 karakteri ge\u00e7mesin! Sat\u0131r sonlar\u0131nda bo\u015f karakter white-space b\u0131rakmay\u0131n! Her rb dosyas\u0131 ya da Ruby kodu i\u00e7eren dosya bo\u015f bir sat\u0131rla bitsin. Operat\u00f6rler, virg\u00fcl, iki nokta, noktal\u0131 virg\u00fcl, { ve } lerin etraf\u0131nda mutlaka bo\u015fluk space karakteri olsun! Yanl\u0131\u015f a = 1 a , b = 1 , 3 1 > 2 ? true :false ; puts \"Merhaba\" [ 1 , 2 , 3 ]. each { | n | puts n } Do\u011fru a = 1 a , b = 1 , 3 1 > 2 ? true : false ; puts \"Merhaba\" [ 1 , 2 , 3 ]. each { | n | puts n } Parantez ve K\u00f6\u015feli parantez kullan\u0131rken, ne \u00f6ncesine ne de sonras\u0131na bo\u015f karakter space koyma! Do\u011fru my_method ( arg1 , arg2 ) . other [ 1 , 2 , 3 ]. length \u00dcnlemden sonra bo\u015f karakter space kullanma !array.include?(element) when ve case kullan\u0131rken girinti durumunu a\u015fa\u011f\u0131daki gibi yap: case when song . name == \"Misty\" puts \"Not again!\" when song . duration > 120 puts \"Too long!\" when Time . now . hour > 21 puts \"It\u2019s too late\" else song . play end kind = case year when 1850 .. 1889 then \"Blues\" when 1890 .. 1909 then \"Ragtime\" when 1910 .. 1929 then \"New Orleans Jazz\" when 1930 .. 1939 then \"Swing\" when 1940 .. 1950 then \"Bebop\" else \"Jazz\" end Method\u2019lar aras\u0131nda 1 sat\u0131r bo\u015fluk ver, gerekiyorsa mant\u0131kl\u0131 bir \u015fekilde i\u00e7eride ayr\u0131m yap! def some_method data = initialize ( options ) data . manipulate! data . result end def some_method result end","title":"Kod Yazma Tarz\u0131 (Style Guide)"},{"location":"bolum-07/01-kod-yazma-tarzi-style-guide/#syntax","text":"E\u011fer method\u2019a parametre ge\u00e7iyorsan parantez yaz! def some_method # arg\u00fcmans\u0131z end def some_method_with_arguments ( arg1 , arg2 ) # arg\u00fcmanl\u0131 end for kullan\u0131m\u0131na dikkat edin, kafan\u0131za g\u00f6re heryerde kullanmay\u0131n: arr = [ 1 , 2 , 3 ] # k\u00f6t\u00fc \u00f6rnek for i in arr do puts i end # iyi \u00f6rnek arr . each { | i | puts i } \u0130\u00e7 i\u00e7e ternary kullanmaktan ka\u00e7\u0131n\u0131n! Okunabilirli\u011fi azalt\u0131yor! # k\u00f6t\u00fc some_condition ? ( nested_condition ? nested_something : nested_something_else ) : something_else # iyi if some_condition nested_condition ? nested_something : nested_something_else else something_else end and ve or yerine && ve || kullan\u0131n M\u00fcmk\u00fcn olduk\u00e7a if leri tek sat\u0131r \u015feklinde kullan\u0131n: # k\u00f6t\u00fc if some_condition do_something end # iyi do_something if some_condition unless i\u00e7inde else kullanmaktan ka\u00e7\u0131n\u0131n: # k\u00f6t\u00fc unless success? puts \"hata\" else puts \"ok\" end # good if success? puts \"ok\" else puts \"hata\" end Tek sat\u0131rl\u0131k blok i\u015flerinde { } , \u00e7ok sat\u0131rl\u0131k blok i\u015flerinde do end kullan\u0131n. return kelimesini gerekmedik\u00e7e kullanmay\u0131n. Method\u2019larda parametre olarak default de\u011fer atarken = etraf\u0131nda space kullan\u0131n. # k\u00f6t\u00fc def some_method ( arg1 = :default , arg2 = nil , arg3 =[] ) # kod... end # iyi def some_method ( arg1 = :default , arg2 = nil , arg3 = [] ) # kod... end Varl\u0131k operat\u00f6r\u00fc kullanmaktan \u00e7ekinmeyin! # e\u011fer isim nil ya da false ise isim de\u011fi\u015fkenine \"vigo\" ata isim ||= \"vigo\" Boolean de\u011ferler i\u00e7in ||= kullanmay\u0131n! # k\u00f6t\u00fc enabled ||= true # iyi enabled = true if enabled . nil? Parantezli kullan\u0131mda method\u2019dan sonra space kullanmay\u0131n: # k\u00f6t\u00fc f ( 3 + 2 ) + 1 # iyi f ( 3 + 2 ) + 1 Block i\u00e7inde kullanmayaca\u011f\u0131n\u0131z de\u011fi\u015fken i\u00e7in de\u011fer atamas\u0131 yapmay\u0131n: # k\u00f6t\u00fc, k bo\u015fa gitti result = hash . map { | k , v | v + 1 } # iyi result = hash . map { | _ , v | v + 1 } Veri tipi kontrol\u00fc i\u00e7in === kullanmay\u0131n! is_a ya da kind_of? kullan\u0131n.","title":"Syntax"},{"location":"bolum-07/01-kod-yazma-tarzi-style-guide/#naming-isimlendirmeler","text":"Method ve de\u011fi\u015fken isimleri i\u00e7in snake_case kullan\u0131n. Class ve Mod\u00fcl i\u00e7in CamelCase kullan\u0131n. Constant i\u00e7in SCREAMING_SNAKE_CASE kullan\u0131n. Boolean sonu\u00e7 d\u00f6nen method\u2019lar ? ile bitmeli: User.is_valid? Tehlike, nesneyi modifiye eden / de\u011fi\u015ftiren method\u2019lar ! ile bitmeli! User.delete!","title":"Naming (\u0130simlendirmeler)"},{"location":"bolum-07/01-kod-yazma-tarzi-style-guide/#class","text":"Singleton tan\u0131mlarken self kullan\u0131n: class TestClass # k\u00f6t\u00fc def TestClass . some_method # kod end # iyi def self . some_other_method # kod end end private , public , protected olan method\u2019larda girintileme method ad\u0131yla ayn\u0131 hizada olsun ve ilgili method\u2019un bir \u00fcst sat\u0131r\u0131 bo\u015f kals\u0131n: class SomeClass def public_method # ... end private def private_method # ... end end","title":"Class"},{"location":"bolum-07/01-kod-yazma-tarzi-style-guide/#exceptions","text":"Ak\u0131\u015f kontol\u00fc i\u00e7in kullanmay\u0131n! # k\u00f6t\u00fc begin n / d rescue ZeroDivisionError puts \"0\u2019a b\u00f6l\u00fcnme hatas\u0131!\" end # iyi if d . zero? puts \"0\u2019a b\u00f6l\u00fcnme hatas\u0131!\" else n / d end","title":"Exceptions"},{"location":"bolum-07/01-kod-yazma-tarzi-style-guide/#diger","text":"String\u2019leri concat ederken interpolasyon kullan\u0131n: # k\u00f6t\u00fc email_with_name = user . name + \" <\" + user . email + \">\" # iyi email_with_name = \" #{ user . name } < #{ user . email } >\" Gerekmedik\u00e7e de\u011fer atamalar\u0131nda tek t\u0131rnak \u2019 kullanmay\u0131n, \u00e7ift t\u0131rna\u011f\u0131 tercih edin \" String concat i\u015flerinde Array \u2019e ekleme tekni\u011fini kullanabilirsiniz, h\u0131zl\u0131 da olur: html = \"\" html << \"<h1>Page title</h1>\" paragraphs . each do | paragraph | html << \"<p> #{ paragraph } </p>\" end","title":"Di\u011fer"},{"location":"bolum-08/","text":"Ger\u00e7ek Hayat Ruby \u00d6rnekleri Bu b\u00f6l\u00fcmde, ger\u00e7ek d\u00fcnyadaki Ruby konular\u0131na de\u011finece\u011fim. Bunlar\u0131n ba\u015f\u0131nda da Neden Ruby? sorusuna cevap vermeye \u00e7al\u0131\u015faca\u011f\u0131m. Bence Ruby d\u00fcnyas\u0131n\u0131 \u00f6ne \u00e7\u0131kartan en b\u00fcy\u00fck farkl\u0131l\u0131k Test Driven Development metodolojisinin \u00e7ok geli\u015fmi\u015f olmas\u0131. Onlarca test k\u00fct\u00fcphanesi, test suite ve benzeri \u015feyler bence di\u011fer dillerde bu kadar ileri seviyede de\u011fil. Yapt\u0131\u011f\u0131n\u0131z uygulamay\u0131 END TO END yani A'dan Z'ye test etmek, tek tek t\u00fcm senaryolar\u0131 \u00e7\u0131kartmak ve neredeyse s\u0131f\u0131r hata ile i\u015f yapmak m\u00fcmk\u00fcn. Behaviour Driven Development ( BDD ), Continues Integration ( CI ), test ve build otomasyonu da \u00e7ok s\u0131k kullanaca\u011f\u0131m\u0131z \u015feylerden biri! Genel anlamda konu ba\u015fl\u0131klar\u0131m\u0131z; Neden Ruby? Ruby ve TDD/BDD/CI * Kendi Rubygem'imizi yapal\u0131m! * Sinatra ve Web *","title":"\u0130ndeks"},{"location":"bolum-08/#gercek-hayat-ruby-ornekleri","text":"Bu b\u00f6l\u00fcmde, ger\u00e7ek d\u00fcnyadaki Ruby konular\u0131na de\u011finece\u011fim. Bunlar\u0131n ba\u015f\u0131nda da Neden Ruby? sorusuna cevap vermeye \u00e7al\u0131\u015faca\u011f\u0131m. Bence Ruby d\u00fcnyas\u0131n\u0131 \u00f6ne \u00e7\u0131kartan en b\u00fcy\u00fck farkl\u0131l\u0131k Test Driven Development metodolojisinin \u00e7ok geli\u015fmi\u015f olmas\u0131. Onlarca test k\u00fct\u00fcphanesi, test suite ve benzeri \u015feyler bence di\u011fer dillerde bu kadar ileri seviyede de\u011fil. Yapt\u0131\u011f\u0131n\u0131z uygulamay\u0131 END TO END yani A'dan Z'ye test etmek, tek tek t\u00fcm senaryolar\u0131 \u00e7\u0131kartmak ve neredeyse s\u0131f\u0131r hata ile i\u015f yapmak m\u00fcmk\u00fcn. Behaviour Driven Development ( BDD ), Continues Integration ( CI ), test ve build otomasyonu da \u00e7ok s\u0131k kullanaca\u011f\u0131m\u0131z \u015feylerden biri! Genel anlamda konu ba\u015fl\u0131klar\u0131m\u0131z; Neden Ruby? Ruby ve TDD/BDD/CI * Kendi Rubygem'imizi yapal\u0131m! * Sinatra ve Web *","title":"Ger\u00e7ek Hayat Ruby \u00d6rnekleri"},{"location":"bolum-08/01-neden-ruby/","text":"Neden Ruby? Yaz\u0131l\u0131m hayat\u0131ma Commodore 16 BASIC dili ile ba\u015flad\u0131m. Daha sonra Commodore 64 \u2019e ge\u00e7tim, Assembly (Makine Dili), daha sonra da Amiga \u2019da da Assembly\u2019ye devam ettim. Bir g\u00fcn geldi ve makine dili \u00e7\u00f6p oldu :) Teknoloji de\u011fi\u015fti :) 90\u2019l\u0131 y\u0131llarda Windows ve ASP diliyle tan\u0131\u015ft\u0131m. ASP\u2019nin ilk g\u00fcnleri, VBScript :) Uzunca bir s\u00fcre ASP ile yola devam ettikten sonra PHP ile tan\u0131\u015ft\u0131m ve \"oooh be D\u00dcNYA varm\u0131\u015f\" dedim. PHP ile hat\u0131r\u0131 say\u0131l\u0131r pek \u00e7ok proje yapt\u0131m. Daha sonra, sevgili karde\u015fim F\u0131rat Can Ba\u015far\u0131r \u2019\u0131n y\u00f6nlendirmesiyle Python ve Django ile tan\u0131\u015ft\u0131m. \u00d6zellikle web development i\u015fleriyle u\u011fra\u015fan biri, PHP\u2019den sonra Python ve Django\u2019yu g\u00f6r\u00fcnce hakikatten akl\u0131 duruyor! \u00d6zellikle Django ile birlikte gelen Admin Panel olay\u0131 insan\u0131n tabiri caizse dibini d\u00fc\u015f\u00fcr\u00fcyor! Daha sonra anla\u015f\u0131l\u0131yor ki, bu panel, sadece developer i\u00e7in. Yani sadece geli\u015ftirme ama\u00e7l\u0131. \u0130lk anda \"ooof, bununla hemen h\u0131zl\u0131ca i\u015fleri \u00e7\u0131kart\u0131r\u0131m\" diyorsunuz hakl\u0131 olarak. Teoride m\u00fcmk\u00fcn de. Ancak b\u00fcy\u00fck bir i\u015fe kalk\u0131\u015ft\u0131\u011f\u0131n\u0131zda bu Admin Panel kabusunuz oluyor ve i\u015fi g\u00fcc\u00fc b\u0131rak\u0131p sadece bu paneli customize ( yani \u00f6zelle\u015ftirme ) etmekle u\u011fra\u015f\u0131yorsunuz. Keza Python 2 mi? 3 m\u00fc? gibi durumlar da s\u00f6z konusu. Python 3 neredeyse tamamen farkl\u0131. An itibariyle ( 30 Kas\u0131m 2014 ) halen Django ve Python3 deste\u011fi resmi olarak gelmi\u015f de\u011fil. 20 A\u011fustos 2021 Django version 3+ oldu, Python 3 default oldu. Python 3.9 var, Python 4 yolda :) Bunun d\u0131\u015f\u0131nda Python toplulu\u011fu \u00e7ok a\u011f\u0131r hareket ediyor. Yeni \u00e7\u0131kan bir servisin mod\u00fcl olarak haz\u0131rlanmas\u0131 ya da en son 3 sene \u00f6nce g\u00fcncellenmi\u015f, y\u00fczlerce pull-request\u2019in bekledi\u011fi GitHub projeleri mi istersiniz? Bu konular beni geli\u015ftirici olarak zorlad\u0131. Amac\u0131m h\u0131zla i\u015fimi d\u00fczg\u00fcn bir \u015fekilde yap\u0131p yoluma devam etmekten ba\u015fka bir \u015fey de\u011fil. Programming is Fun! Yani Programlama e\u011flencelidir! ne demek bu? \u0130lk bak\u0131\u015fta insan d\u00fc\u015f\u00fcn\u00fcyor, programlama dilinin neresi e\u011flenceli olabilir ki? Neticede bilimsel bir i\u015flem diye d\u00fc\u015f\u00fcn\u00fcyor insan. Taa ki Ruby ile u\u011fra\u015fmaya ba\u015flayana kadar... \u0130lk dikkat \u00e7eken \u015fey, Ruby dilinin insan diline \u00e7ok benzemesi. Yani \u0130ngilizce bilen biri i\u00e7in okunmas\u0131 \u00e7ok kolay. Hi\u00e7 Ruby bilmeyen biri bile rahatl\u0131kla ne t\u00fcr bir i\u015flem oldu\u011funu anlayabilir. Daha \u00f6nce hi\u00e7bir programlama dilinde rastlamad\u0131\u011f\u0131m bir if kullan\u0131m\u0131: puts \"vigo\" if a > 2 Bu \u015fu demek, e\u011fer a \u2019n\u0131n de\u011feri 2 \u2019den b\u00fcy\u00fckse ekrana vigo yaz. Asp, Python, Php, Perl, C gibi dillerde genelde if blo\u011fu i\u00e7inde ya da oneline yani tek sat\u0131rda ifade \u015feklinde olurken ilk kez Ruby\u2019de if ko\u015fulunun bu \u015fekilde kullan\u0131ld\u0131\u011f\u0131n\u0131 g\u00f6rd\u00fcm. unless kelime anlam\u0131 olarak if not anlam\u0131ndad\u0131r. Yani e\u011fer x \u2019in de\u011feri false ise \u015funu yap derken: puts \"vigo\" unless x gibi bir kullan\u0131m s\u00f6z konusu. yani a\u015fa\u011f\u0131daki gibi de kullan\u0131labilir ama mant\u0131ksal olarak tercih edilmez: puts \"vigo\" if ! x Keza method isimleri, standart k\u00fct\u00fcphane ile gelen \u00f6zellikler gayet ak\u0131lda kal\u0131c\u0131 ve mant\u0131kl\u0131. Ruby sizin ad\u0131n\u0131za pek \u00e7ok \u015feyi d\u00fc\u015f\u00fcn\u00fcp haz\u0131r kullan\u0131ma sunuyor. Acaba bug\u00fcn g\u00fcnlerden cuma m\u0131? Hemen bakal\u0131m: Time . now . friday? # => true # evet Asl\u0131nda \u00e7ok basit ama \u00e7ok i\u015fe yarayan bir \u00f6zellik. Bu tarz konulara Syntactic Sugar deniliyor. \u00c7ok G\u00fc\u00e7l\u00fc ve \u00c7al\u0131\u015fkan Ruby Toplulu\u011fu Ne yaz\u0131k ki \u00fclkemizde \u00e7ok da bilinen ya da tercih edilen bir dil olmamas\u0131na ra\u011fmen, d\u00fcnyada durum \u00e7ok farkl\u0131. Pek \u00e7ok tan\u0131d\u0131k proje Ruby, Ruby on Rails, Sinatra gibi Ruby d\u00fcnyas\u0131n\u0131n ara\u00e7lar\u0131n\u0131 kullanmakta. Python\u2019dan gelen bir geli\u015ftirici olarak, ya\u015fad\u0131\u011f\u0131m en b\u00fcy\u00fck s\u0131k\u0131nt\u0131lardan biri de yava\u015f ilerleme durumuydu. Python\u2019u ben Alman M\u00fchendisli\u011fine benzetiyorum. Her \u015fey inan\u0131lmaz kurall\u0131, s\u00fcper sistemli olmak zorunda. Tamam bu \u00e7ok g\u00fczel bir yakla\u015f\u0131m, kabul ediyorum ama bazen a\u011f\u0131r kal\u0131yor. Bazen \u00f6yle bir Python mod\u00fcl\u00fcne ihtiyac\u0131n\u0131z oluyor ve bir bak\u0131yorsunuz son 3 y\u0131ld\u0131r g\u00fcncelleme yap\u0131lmam\u0131\u015f, GitHub\u2019da bekleyen 50 tane Pull Request, kodu kimin maintain etti\u011fi belli de\u011fil, uzay bo\u015flu\u011funda kendi kendine giden bir durumda kaderini bekliyor. Ruby toplulu\u011fu inan\u0131lmaz derecede \u00fcretken. Yeni bir API\u2019m\u0131 \u00e7\u0131kt\u0131? Hemen gem\u2019ini bulman\u0131z m\u00fcmk\u00fcn! Ruby mi \u00f6\u011frenmek istiyorsunuz? Tonlarca \u00fccretsiz/\u00fccretli online videolar, e\u011fitimler var! Kitap, kod, konferans akl\u0131n\u0131za ne gelirse... Ne yaz\u0131k ki bu denli aktif bir d\u00fcnyay\u0131 ben di\u011fer u\u011fra\u015ft\u0131\u011f\u0131m dillerde g\u00f6remedim. Bir i\u015fi yapman\u0131n pek \u00e7ok farkl\u0131 yolu olabilir! Son olarak, Ruby\u2019deki en \u00e7ok ho\u015fuma giden mentaliteden bahsetmek istiyorum. Bir i\u015fi do\u011fru yapman\u0131n birden fazla yolu olabilir. \u00d6rne\u011fin Python\u2019da sadece \"tek bir yol\" varken Ruby\u2019de farkl\u0131 farkl\u0131 y\u00f6ntemlerle, komutlarla ayn\u0131 i\u015fi de\u011fi\u015fik \u015fekillerde yapabilirsiniz ve hepsi de do\u011frudur! Neredeyse hi\u00e7bir programlama dili DSL (yani Domain Specific Language) yapmak i\u00e7in bu denli m\u00fcsait de\u011fil. Yani Ruby kullanarak kafan\u0131za g\u00f6re Ruby \u00fczerinde \u00e7al\u0131\u015fan ba\u015fka bir d\u00fcnya yapabilirsiniz! Neticede hayatta her \u015fey tercihler ve zevklerle ilgilidir. Ben kendi nedenlerimi belirtiyorum, bunlar size uymayabilir, hatta nefret bile edebilirsiniz. E\u011fer b\u00f6yle bir durum varsa, sizden ricam sakin bir \u015fekilde Ruby d\u00fcnyas\u0131n\u0131 incelemeniz. An itibariyle ne ile u\u011fra\u015f\u0131yorsan\u0131z ayn\u0131 \u015feyi Ruby ile yapmaya \u00e7al\u0131\u015fman\u0131z. Mutlaka deneyin. Denedikten, tad\u0131na bakt\u0131ktan sonra karar verin. Sevgili annem k\u00fc\u00e7\u00fckken hep derdi \"\u00f6nce bi tad\u0131na bak ondan sonra istemiyorsan yeme\u011fi yeme\" diye :) G\u00fcncel: 20 A\u011fustos 2021 An itibariyle gece g\u00fcnd\u00fcz Golang yaz\u0131yorum, yan\u0131nda da Django . Hangi dilde kod yazarsam yazay\u0131m mutlaka i\u00e7eride bir Rakefile oluyor ve ben Ruby kaslar\u0131m\u0131 hep \u00e7al\u0131\u015ft\u0131rmaya devam ediyorum...","title":"Neden Ruby?"},{"location":"bolum-08/01-neden-ruby/#neden-ruby","text":"Yaz\u0131l\u0131m hayat\u0131ma Commodore 16 BASIC dili ile ba\u015flad\u0131m. Daha sonra Commodore 64 \u2019e ge\u00e7tim, Assembly (Makine Dili), daha sonra da Amiga \u2019da da Assembly\u2019ye devam ettim. Bir g\u00fcn geldi ve makine dili \u00e7\u00f6p oldu :) Teknoloji de\u011fi\u015fti :) 90\u2019l\u0131 y\u0131llarda Windows ve ASP diliyle tan\u0131\u015ft\u0131m. ASP\u2019nin ilk g\u00fcnleri, VBScript :) Uzunca bir s\u00fcre ASP ile yola devam ettikten sonra PHP ile tan\u0131\u015ft\u0131m ve \"oooh be D\u00dcNYA varm\u0131\u015f\" dedim. PHP ile hat\u0131r\u0131 say\u0131l\u0131r pek \u00e7ok proje yapt\u0131m. Daha sonra, sevgili karde\u015fim F\u0131rat Can Ba\u015far\u0131r \u2019\u0131n y\u00f6nlendirmesiyle Python ve Django ile tan\u0131\u015ft\u0131m. \u00d6zellikle web development i\u015fleriyle u\u011fra\u015fan biri, PHP\u2019den sonra Python ve Django\u2019yu g\u00f6r\u00fcnce hakikatten akl\u0131 duruyor! \u00d6zellikle Django ile birlikte gelen Admin Panel olay\u0131 insan\u0131n tabiri caizse dibini d\u00fc\u015f\u00fcr\u00fcyor! Daha sonra anla\u015f\u0131l\u0131yor ki, bu panel, sadece developer i\u00e7in. Yani sadece geli\u015ftirme ama\u00e7l\u0131. \u0130lk anda \"ooof, bununla hemen h\u0131zl\u0131ca i\u015fleri \u00e7\u0131kart\u0131r\u0131m\" diyorsunuz hakl\u0131 olarak. Teoride m\u00fcmk\u00fcn de. Ancak b\u00fcy\u00fck bir i\u015fe kalk\u0131\u015ft\u0131\u011f\u0131n\u0131zda bu Admin Panel kabusunuz oluyor ve i\u015fi g\u00fcc\u00fc b\u0131rak\u0131p sadece bu paneli customize ( yani \u00f6zelle\u015ftirme ) etmekle u\u011fra\u015f\u0131yorsunuz. Keza Python 2 mi? 3 m\u00fc? gibi durumlar da s\u00f6z konusu. Python 3 neredeyse tamamen farkl\u0131. An itibariyle ( 30 Kas\u0131m 2014 ) halen Django ve Python3 deste\u011fi resmi olarak gelmi\u015f de\u011fil. 20 A\u011fustos 2021 Django version 3+ oldu, Python 3 default oldu. Python 3.9 var, Python 4 yolda :) Bunun d\u0131\u015f\u0131nda Python toplulu\u011fu \u00e7ok a\u011f\u0131r hareket ediyor. Yeni \u00e7\u0131kan bir servisin mod\u00fcl olarak haz\u0131rlanmas\u0131 ya da en son 3 sene \u00f6nce g\u00fcncellenmi\u015f, y\u00fczlerce pull-request\u2019in bekledi\u011fi GitHub projeleri mi istersiniz? Bu konular beni geli\u015ftirici olarak zorlad\u0131. Amac\u0131m h\u0131zla i\u015fimi d\u00fczg\u00fcn bir \u015fekilde yap\u0131p yoluma devam etmekten ba\u015fka bir \u015fey de\u011fil.","title":"Neden Ruby?"},{"location":"bolum-08/01-neden-ruby/#programming-is-fun","text":"Yani Programlama e\u011flencelidir! ne demek bu? \u0130lk bak\u0131\u015fta insan d\u00fc\u015f\u00fcn\u00fcyor, programlama dilinin neresi e\u011flenceli olabilir ki? Neticede bilimsel bir i\u015flem diye d\u00fc\u015f\u00fcn\u00fcyor insan. Taa ki Ruby ile u\u011fra\u015fmaya ba\u015flayana kadar... \u0130lk dikkat \u00e7eken \u015fey, Ruby dilinin insan diline \u00e7ok benzemesi. Yani \u0130ngilizce bilen biri i\u00e7in okunmas\u0131 \u00e7ok kolay. Hi\u00e7 Ruby bilmeyen biri bile rahatl\u0131kla ne t\u00fcr bir i\u015flem oldu\u011funu anlayabilir. Daha \u00f6nce hi\u00e7bir programlama dilinde rastlamad\u0131\u011f\u0131m bir if kullan\u0131m\u0131: puts \"vigo\" if a > 2 Bu \u015fu demek, e\u011fer a \u2019n\u0131n de\u011feri 2 \u2019den b\u00fcy\u00fckse ekrana vigo yaz. Asp, Python, Php, Perl, C gibi dillerde genelde if blo\u011fu i\u00e7inde ya da oneline yani tek sat\u0131rda ifade \u015feklinde olurken ilk kez Ruby\u2019de if ko\u015fulunun bu \u015fekilde kullan\u0131ld\u0131\u011f\u0131n\u0131 g\u00f6rd\u00fcm. unless kelime anlam\u0131 olarak if not anlam\u0131ndad\u0131r. Yani e\u011fer x \u2019in de\u011feri false ise \u015funu yap derken: puts \"vigo\" unless x gibi bir kullan\u0131m s\u00f6z konusu. yani a\u015fa\u011f\u0131daki gibi de kullan\u0131labilir ama mant\u0131ksal olarak tercih edilmez: puts \"vigo\" if ! x Keza method isimleri, standart k\u00fct\u00fcphane ile gelen \u00f6zellikler gayet ak\u0131lda kal\u0131c\u0131 ve mant\u0131kl\u0131. Ruby sizin ad\u0131n\u0131za pek \u00e7ok \u015feyi d\u00fc\u015f\u00fcn\u00fcp haz\u0131r kullan\u0131ma sunuyor. Acaba bug\u00fcn g\u00fcnlerden cuma m\u0131? Hemen bakal\u0131m: Time . now . friday? # => true # evet Asl\u0131nda \u00e7ok basit ama \u00e7ok i\u015fe yarayan bir \u00f6zellik. Bu tarz konulara Syntactic Sugar deniliyor.","title":"Programming is Fun!"},{"location":"bolum-08/01-neden-ruby/#cok-guclu-ve-calskan-ruby-toplulugu","text":"Ne yaz\u0131k ki \u00fclkemizde \u00e7ok da bilinen ya da tercih edilen bir dil olmamas\u0131na ra\u011fmen, d\u00fcnyada durum \u00e7ok farkl\u0131. Pek \u00e7ok tan\u0131d\u0131k proje Ruby, Ruby on Rails, Sinatra gibi Ruby d\u00fcnyas\u0131n\u0131n ara\u00e7lar\u0131n\u0131 kullanmakta. Python\u2019dan gelen bir geli\u015ftirici olarak, ya\u015fad\u0131\u011f\u0131m en b\u00fcy\u00fck s\u0131k\u0131nt\u0131lardan biri de yava\u015f ilerleme durumuydu. Python\u2019u ben Alman M\u00fchendisli\u011fine benzetiyorum. Her \u015fey inan\u0131lmaz kurall\u0131, s\u00fcper sistemli olmak zorunda. Tamam bu \u00e7ok g\u00fczel bir yakla\u015f\u0131m, kabul ediyorum ama bazen a\u011f\u0131r kal\u0131yor. Bazen \u00f6yle bir Python mod\u00fcl\u00fcne ihtiyac\u0131n\u0131z oluyor ve bir bak\u0131yorsunuz son 3 y\u0131ld\u0131r g\u00fcncelleme yap\u0131lmam\u0131\u015f, GitHub\u2019da bekleyen 50 tane Pull Request, kodu kimin maintain etti\u011fi belli de\u011fil, uzay bo\u015flu\u011funda kendi kendine giden bir durumda kaderini bekliyor. Ruby toplulu\u011fu inan\u0131lmaz derecede \u00fcretken. Yeni bir API\u2019m\u0131 \u00e7\u0131kt\u0131? Hemen gem\u2019ini bulman\u0131z m\u00fcmk\u00fcn! Ruby mi \u00f6\u011frenmek istiyorsunuz? Tonlarca \u00fccretsiz/\u00fccretli online videolar, e\u011fitimler var! Kitap, kod, konferans akl\u0131n\u0131za ne gelirse... Ne yaz\u0131k ki bu denli aktif bir d\u00fcnyay\u0131 ben di\u011fer u\u011fra\u015ft\u0131\u011f\u0131m dillerde g\u00f6remedim.","title":"\u00c7ok G\u00fc\u00e7l\u00fc ve \u00c7al\u0131\u015fkan Ruby Toplulu\u011fu"},{"location":"bolum-08/01-neden-ruby/#bir-isi-yapmann-pek-cok-farkl-yolu-olabilir","text":"Son olarak, Ruby\u2019deki en \u00e7ok ho\u015fuma giden mentaliteden bahsetmek istiyorum. Bir i\u015fi do\u011fru yapman\u0131n birden fazla yolu olabilir. \u00d6rne\u011fin Python\u2019da sadece \"tek bir yol\" varken Ruby\u2019de farkl\u0131 farkl\u0131 y\u00f6ntemlerle, komutlarla ayn\u0131 i\u015fi de\u011fi\u015fik \u015fekillerde yapabilirsiniz ve hepsi de do\u011frudur! Neredeyse hi\u00e7bir programlama dili DSL (yani Domain Specific Language) yapmak i\u00e7in bu denli m\u00fcsait de\u011fil. Yani Ruby kullanarak kafan\u0131za g\u00f6re Ruby \u00fczerinde \u00e7al\u0131\u015fan ba\u015fka bir d\u00fcnya yapabilirsiniz! Neticede hayatta her \u015fey tercihler ve zevklerle ilgilidir. Ben kendi nedenlerimi belirtiyorum, bunlar size uymayabilir, hatta nefret bile edebilirsiniz. E\u011fer b\u00f6yle bir durum varsa, sizden ricam sakin bir \u015fekilde Ruby d\u00fcnyas\u0131n\u0131 incelemeniz. An itibariyle ne ile u\u011fra\u015f\u0131yorsan\u0131z ayn\u0131 \u015feyi Ruby ile yapmaya \u00e7al\u0131\u015fman\u0131z. Mutlaka deneyin. Denedikten, tad\u0131na bakt\u0131ktan sonra karar verin. Sevgili annem k\u00fc\u00e7\u00fckken hep derdi \"\u00f6nce bi tad\u0131na bak ondan sonra istemiyorsan yeme\u011fi yeme\" diye :)","title":"Bir i\u015fi yapman\u0131n pek \u00e7ok farkl\u0131 yolu olabilir!"},{"location":"bolum-08/01-neden-ruby/#guncel-20-agustos-2021","text":"An itibariyle gece g\u00fcnd\u00fcz Golang yaz\u0131yorum, yan\u0131nda da Django . Hangi dilde kod yazarsam yazay\u0131m mutlaka i\u00e7eride bir Rakefile oluyor ve ben Ruby kaslar\u0131m\u0131 hep \u00e7al\u0131\u015ft\u0131rmaya devam ediyorum...","title":"G\u00fcncel: 20 A\u011fustos 2021"},{"location":"bolum-08/02-ruby-ve-tddbddci/","text":"Ruby ve TDD/BDD/CI @wip","title":"Ruby ve TDD/BDD/CI"},{"location":"bolum-08/02-ruby-ve-tddbddci/#ruby-ve-tddbddci","text":"@wip","title":"Ruby ve TDD/BDD/CI"},{"location":"bolum-08/03-kendi-rubygemimizi-yapalim/","text":"Kendi Rubygem'imizi yapal\u0131m! @wip","title":"Kendi Rubygem'imizi yapal\u0131m!"},{"location":"bolum-08/03-kendi-rubygemimizi-yapalim/#kendi-rubygemimizi-yapalm","text":"@wip","title":"Kendi Rubygem'imizi yapal\u0131m!"},{"location":"bolum-08/04-sinatra-ve-web/","text":"Sinatra ve Web Belkide en pop\u00fcler Ruby k\u00fct\u00fcphanesi micro-webframework Sinatra ile h\u0131zl\u0131ca mini web uygulamalar\u0131 yapmak, basit API servisleri haz\u0131rlamak ve sunucuya deploy etmek konular\u0131n\u0131 i\u015fleyece\u011fiz! @wip","title":"Sinatra ve Web"},{"location":"bolum-08/04-sinatra-ve-web/#sinatra-ve-web","text":"Belkide en pop\u00fcler Ruby k\u00fct\u00fcphanesi micro-webframework Sinatra ile h\u0131zl\u0131ca mini web uygulamalar\u0131 yapmak, basit API servisleri haz\u0131rlamak ve sunucuya deploy etmek konular\u0131n\u0131 i\u015fleyece\u011fiz! @wip","title":"Sinatra ve Web"}]}